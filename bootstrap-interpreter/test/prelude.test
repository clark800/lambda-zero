===============================================================================
"x\"
Syntax error: missing end quote for '"x\"' at line 1 column 1
===============================================================================
first(((1, 2)))
1
===============================================================================
iterate((1 +))(0).safeAt(2) ?? 0
2
===============================================================================
safeHead([7, 8]) ?? 0
7
===============================================================================
if False \n  (x -> x) \n(y -> y)
(y -> y)
===============================================================================
safeTail((x -> x) :: (y -> y)) ?? 0
(y -> y)
===============================================================================
safeHead(((x -> x) :: (y -> y)) :: (z -> z)) ?? 0
(_ -> (_ -> ((_ (x -> x)) (y -> y))))
===============================================================================
safeHead(sort(5 :: 60 :: 7 :: 14 :: 2 :: 5 :: 33 :: [])) ?? 0
2
===============================================================================
safeHead(5 :: (10 :: (15 :: (20 :: []))) |: (> 10)) ?? 0
15
===============================================================================
safeHead(replicate(7, 10)) ?? 0
10
===============================================================================
(x -> ""x)(0)
Syntax error: missing operator before 'x' at line 1 column 9
===============================================================================
main(input) := "Hello world"
Hello world
===============================================================================
main(input) := "abcdef".interleave(',')
a,b,c,d,e,f
===============================================================================
if "abcd" =*= 'a' .. 'd' then 1 else 0
1
===============================================================================
"aceswild".find(isEven) ?? 0
108
===============================================================================
"aces".find(isEven) ?? 0
0
===============================================================================
main(input) := "abbc" |: (x -> "bbcd".any((= x)))
bbc
===============================================================================
try Right(10) catch (e -> 5)
10
===============================================================================
try Left() catch (e -> 5)
5
===============================================================================
if isRight(Right(1)) then 1 else 0
1
===============================================================================
if isRight(Left()) then 1 else 0
0
===============================================================================
try Right(2).mapRight(2 *) catch (e -> 0)
4
===============================================================================
length("")
0
===============================================================================
first((1 , (2 *) ^<> 2))
1
===============================================================================
syntax( ) := infixL(99)\nf x := f(x)\nsafeHead (safeTail([1, 2, 3]) ?? [0]) ?? 0
2
===============================================================================
length([1, 2, 3, 4, 5, 6])
6
===============================================================================
[1, 2, 3, 4, 5, 6].safeAt(4) ?? 0
5
===============================================================================
if not isNil([]) then 1 else 0
0
===============================================================================
if not[].isNil then 1 else 0
0
===============================================================================
length(3 .. 9)
7
===============================================================================
(1 .. 10).safeAt(5) ?? 0
6
===============================================================================
if "!@#$%^".any((= '#')) then 1 else 0
1
===============================================================================
if not divides(2, 10) then 1 else 0
1
===============================================================================
first(swap((1, 2)))
2
===============================================================================
if "//123".startsWith("//") then 1 else 0
1
===============================================================================
parseNatural("1234567890") ?? 0
1234567890
===============================================================================
if "abc" <*= "abcd" then 1 else 0
1
===============================================================================
if "abc" <*= "ab" then 1 else 0
0
===============================================================================
if "acb" <*= "abc" then 1 else 0
0
===============================================================================
safeLast([1,2,3,4]) ?? 0
4
===============================================================================
a := (1, 2, 3) \n f(x, y, z) := 5 * x -- y + z \n f.a
6
===============================================================================
(a, b, c, d) := (1, 2, 3, 4) \n a + b * c + d
11
===============================================================================
((a, b, c), (d, e, f), (g, h, i)) := ((1, 2, 3), (4, 5, 6), (7, 8, 9)) \n c * h
24
===============================================================================
(Left() -> 0 ; Right(x) -> x * x)(Left())
0
===============================================================================
(Left() -> 0 ; Right(x) -> x * x)(Right(5))
25
===============================================================================
([] -> 0 ; x :: xs -> x * x)([])
0
===============================================================================
([] -> 0 ; x :: xs -> x * x)([3, 4, 5])
9
===============================================================================
(+ n -> n + 1 ; - n -> n + 2;)(- 0)
2
===============================================================================
(+ n -> n + 1 ; - n -> n -- 1)(+ 4)
5
===============================================================================
(+ n -> n + 1 ; - n -> n -- 1)(- 4)
3
===============================================================================
(p@(a, b) -> first(p) * (a + b))((4, 5))
36
===============================================================================
up 1000000000
1000000001
===============================================================================
up 0 + up up 0
3
===============================================================================
up 1000000000
1000000001
===============================================================================
1000000000 + up 1000000000
2000000001
===============================================================================
up 1000000000 + 1000000000
2000000001
===============================================================================
safeHead([]) ?? 0
0
===============================================================================
sum(1..10)
55
===============================================================================
f(x, y, z) := y * (z + 1) \n `f(2, 3, 5)
12
===============================================================================
f(x, y, z) := y * (z + 1) \n ``f(2, 3, 5)
15
===============================================================================
(syntax(%%) := infix(20), 0)
Syntax error: missing scope for definition ':=' at line 1 column 13
===============================================================================
try Right(1) catch (x -> x)
1
===============================================================================
Void ?? 2
2
===============================================================================
Just(1) ?? 2
1
===============================================================================
mapJust((* 2), Just(2)) ?? 0
4
===============================================================================
mapJust((* 2), Void) ?? 0
0
===============================================================================
maybe x := Just(1)\n x
1
===============================================================================
(maybe x := Void\n x) ?? 2
2
===============================================================================
try x := Right(1)\n x
1
===============================================================================
try (try x := Left(1)\n x) catch (_ -> 2)
2
===============================================================================
try x := Right(1)\n2
2
===============================================================================
try Right(1) catch (_ -> 2)
1
===============================================================================
try Left(1) catch (x -> x + 1)
2
===============================================================================
try Left(Right(2))\n  Left(x) -> 2 * x\n  Right(x) -> 3 * x
6
===============================================================================
try Left(1)\n  x -> x + 1
2
===============================================================================
(0 -> 0; up(n) -> 1)(0)
0
===============================================================================
(0 -> 0; up(n) -> 1)(5)
1
===============================================================================
(0 -> 0; n @ up n' -> n + n')(4)
7
===============================================================================
define x by match 3 to 0 -> 1; up(n) -> n * n;; x
4
==========================================================================
[1] |> x :: xs -> x; _ -> 0
1
==========================================================================
[] |> x :: xs -> x; _ -> 0
0
==========================================================================
Void |> Void -> 1; _ -> 2
1
==========================================================================
Just(3) |> Void -> 1; _ -> 2
2
==========================================================================
Void |> Just(x) -> x; _ -> 0
0
==========================================================================
Just(3) |> Just(x) -> x; _ -> 0
3
==========================================================================
Void |> Just(x) -> x; Void -> 1; _ -> 0
1
==========================================================================
Just(3) |> Void -> 1; Just(x) -> x; _ -> 0
3
==========================================================================
with [1] as x :: xs\n  x\n0
1
==========================================================================
with [] as x :: xs\n  x\n0
0
==========================================================================
