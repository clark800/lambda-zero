#* aatree.zero

AADatumT(a) ::= {AADatum(level : â„•, value : a)}

getValueAA(AADatum(_, value)) := value

define getLevelAA(tree)
    match tree
        Tip -> 0
        Fork(AADatum(n, _), _, _) -> n


define skewAA(tree)
    match tree
        case Tip; Tip
        case Fork(datum @ AADatum(n, _), left, right)
            match left
                case Tip; tree
                case Fork(datum' @ AADatum(n', _), left', right')
                    if n =/= n'
                        tree
                    Fork(datum', left', Fork(datum, right', right))


define splitAA(tree)
    match tree
        case Tip; Tip
        case Fork(datum @ AADatum(n, _), left, right)
            match right
                case Tip; tree
                case Fork(AADatum(n', value'), left', right')
                    if getLevelAA(right') =/= n
                        tree
                    datum' := AADatum(up n', value')
                    Fork(datum', Fork(datum, left, left'), right')


define insertAA((~<), hash, value, tree)
    ss := splitAA <> skewAA
    match tree
        case Tip; Fork(AADatum(1, value), Tip, Tip)
        case Fork(datum @ AADatum(n, value'), left, right)
            key := hash(value)
            key' := hash(value')
            if key ~< key'
                if key' ~< key
                    Fork(AADatum(n, value), left, right)
                ss(Fork(datum, insertAA((~<), hash, value, left), right))
            ss(Fork(datum, left, insertAA((~<), hash, value, right)))


define searchAA((~<), hash, key, tree)
    search((~<), hash <> getValueAA, key, tree).mapJust(getValueAA)


define flattenAA(tree)
    flatten(tree).map(getValueAA)


define extendAA((~<), hash, values, tree)
    values.fold(insertAA((~<), hash), tree)


define mergeAA((~<), hash, tree', tree)
    extendAA((~<), hash, flattenAA(tree'), tree)

#*
