--* prelude.zero
`` naming conventions
x, y, z unspecified type
f, g, h function type
n, m, k integer type
b, c    boolean type
p, q    boolean-valued function
mx      maybe of x
xs      list of x
xy      pair of x and y ``

-- undefined
undefined := error("")

-- function
x.f := f(x)                     -- uniform function call syntax
match := (.)
f || x := f(x)                  -- low precedence application
f <> g := x -> f(g(x))          -- function composition
`f(x, y) := f(y, x)             -- flip order of first two arguments of function
id(x) := x                      -- identity function
constant(x) := _ -> x           -- return value does not depend on parameter
on(f, g) := x -> y -> f(g(x), g(y)) -- apply binary f with unary g applied first
mirror(f)(x) := f(x, x)         -- convert binary function to unary function

-- boolean
Boolean ::= {false, true}
if(b, x, y) := b.match(false -> y; true -> x)
(?) := if
! b := b ? false || true
b /\ c := b ? c || false
b \/ c := b ? true || c
b => c := b ? c || true
b <=> c := b ? c || ! c
until(f, p, z) := p(z) ? z || f.until(p, f(z))
while(f, p, z) := f.until((!) <> p, z)

-- math
N ::= {zero, up(_ : N)}
Z ::= {positive(_ : N), negative(_ : N)}
Q ::= {(_ : Z) / (_ : Z)}
- n := 0 - n
abs(n) := n >= 0 ? n || -(n)
sign(n) := n = 0 ? 0 || n > 0 ? 1 || -1
min(n, m) := n <= m ? n || m
max(n, m) := n >= m ? n || m
mod(n, m) := n % m
isEven(n) := n.mod(2) = 0
isOdd(n) := n.mod(2) != 0
divides(n, m) := m.mod(n) = 0
factorial(n) := (n = 0) ? 1 || n * factorial(n - 1)
gcd(n, m) := (m = 0) ? n || gcd(m, n.mod(m))
n ^ m := (
    m = 0 ? 1
    m < 0 ? 1 // n ^ -(m)
    isEven(m) ? (*).mirror(n ^ (m // 2))
    n * n ^ (m - 1)
)

-- tuple
Unit ::= {()}
Pair(a, b) ::= {(_ : a, _ : b)}
Triple(a, b, c) ::= {(_ : a, _ : b, _ : c)}
Quadruple(w, x, y, z) ::= {(_ : w, _ : x, _ : y, _ : z)}
pair(a, b) := (a, b)
first((x, y)) := x
second((x, y)) := y
swap((x, y)) := (y, x)
mapFirst(xy, f) := (f(first(xy)), second(xy))
mapSecond(xy, f) := (first(xy), f(second(xy)))
mapPair(xx, f) := (f(first(xx)), f(second(xx)))
curry(f) := x -> y -> f((x, y))
uncurry(f) := xx -> f(first(xx), second(xx))

-- maybe
Maybe(a) ::= {nothing, just(_ : a)}
isNothing := nothing -> true; just(_) -> false
isJust := nothing -> false; just(_) -> true
mx >> f := mx.match(nothing -> nothing; just(x) -> f(x))   -- maybe bind
mx ?! d := mx.match(nothing -> d; just(x) -> x)    -- just value or default

-- list
List(a) ::= {[], (_ : a) :: (_ : List(a))}
prepend := `(::)
isEmpty := [] -> true; _ :: _ -> false
fold(xs, f, z) := xs.match([] -> z; x :: xs' -> f(x, fold(xs', f, z)))
cascade(xs, f, z) := xs.match([] -> z; x :: xs' -> cascade(xs', f, f(z, x)))
xs ++ ys := xs.fold((::), ys)                   -- concatenate two lists
join(xss) := xss.fold((++), [])            -- concatenate list of lists
length(xs) := xs.fold(constant(+ 1), 0)         -- get length of list
reverse(xs) := xs.cascade(`(::), [])
dropIf(ns, p) := ns.match([] -> []; n :: ns' -> p(n) ? ns' || ns)
takeWhile(xs, p) := xs.match(
    [] -> [];
    x :: xs' -> p(x) ? x :: takeWhile(xs', p) || []
)
dropWhile(xs, p) := xs.match(
    [] -> [];
    x :: xs' -> p(x) ? dropWhile(xs', p) || xs
)
takeSafe(xs, n) := n = 0 ? just([]) ||
    xs.match([] -> nothing; x :: xs' -> takeSafe(xs', n - 1) >> just <> (x ::))
dropSafe(xs, n) := n = 0 ? xs ||
    xs.match([] -> []; _ :: xs' -> dropSafe(xs', n - 1))
filter(xs, p) := fold(xs, x -> xs' -> if(p(x), x :: xs', xs'), [])
(|:) := filter
map(xs, f) := fold(xs, (::) <> f, [])          -- map function over list
zipWith(xs, f, ys) := xs.match(
    [] -> [];
    x :: xs' -> ys.match(
        [] -> [];
        y :: ys' -> f(x, y) :: zipWith(xs', f, ys')
    )
)
zip(xs, ys) := zipWith(xs, pair, ys)
unzip(xs) := (xs.map(first), xs.map(second))
interleave(xs, y) := (
    interleave' := [] -> []; x :: xs' -> y :: x :: interleave'(xs')
    xs.match([] -> []; x :: xs' -> x :: interleave'(xs'))
)
joinWith(xss, ys) := join(interleave(xss, ys))
bisect(xs, p) := (xs |: p, xs |: (!) <> p)
any(xs, p) := xs.map(p).fold((\/), false)     -- test if any element satisfies p
all(xs, p) := xs.map(p).fold((/\), true)      -- test if all elements satisfy p
find(xs, p) := xs.match(
    [] -> nothing;
    x :: xs' -> p(x) ? just(x) || xs'.find(p)
)
-- foldMap : a[] --> (a --> s --> b ** s) --> s --> (b[], s)
foldMap(xs, f, z) := xs.cascade((ys, s) -> x ->
    f(x, s).mapFirst(:: ys), ([], z)).mapFirst(reverse)

-- fallible function
f ^^ n := n < 0 ? error("(^^): negative") || n = 0 ? id || f <> f ^^ (n - 1)

-- fallible list
head := [] -> error("head: empty list"); x :: _ -> x
tail := [] -> error("tail: empty list"); _ :: xs -> xs
drop(xs, n) := (tail ^^ n)(xs)            -- drop n elements from front of list
take(xs, n) := n = 0 ? [] || head(xs) :: tail(xs).take(n - 1)
xs[n] := head(xs.drop(n))          -- get element of list at index
xs[start, end] := xs.drop(start).take(end - start)
last(xs) := tail.until(isEmpty <> tail, xs).head    -- get last element of list
dropLast(xs) :=
    isEmpty(xs) \/ isEmpty(tail(xs)) ? [] || head(xs) :: dropLast(tail(xs))
reduce(xs, f) := tail(xs).cascade(f, xs[0])

-- generic list constructors
iterate(f, x) := x :: iterate(f, f(x))       -- iteratively apply f
repeat(x) := x :: repeat(x)                  -- infinitely repeat one element
replicate(x, n) := ((x ::) ^^ n)([])         -- replicate one element n times
cycle(xs) := xs ++ cycle(xs)                 -- infinitely cycle list

-- integer list
n .. m := n > m ? [] || n :: (n + 1 .. m)
sort := [] -> []; n :: ns -> sort(ns |: (<= n)) ++ [n] ++ sort(ns |: (> n))
deduplicate := [] -> []; n :: ns -> n :: deduplicate(ns |: (!= n))
deduplicateBy(xs, (=?=)) := xs.match(
    [] -> [];
    x :: xs' -> x :: deduplicateBy(xs' |: (!) <> (=?= x), (=?=))
)
sum(ns) := ns.cascade((+), 0)
product(ns) := ns.cascade((*), 1)
minimum(ns) := ns.reduce(min)
maximum(ns) := ns.reduce(max)
countFrom := iterate(+ 1)
naturals := countFrom(0)
primes := (
    filterPrime := [] -> []; n :: ns -> n :: filterPrime(ns |: (% n != 0))
    filterPrime(countFrom(2))
)

-- string
xs =*= ys := xs.match(        -- string equality
    [] -> isEmpty(ys);
    x :: xs' -> ys.match(
        [] -> false;
        y :: ys' -> x = y /\ xs' =*= ys'
    )
)

ns <*= ms := ns.match(      -- string comparison
    [] -> true;
    n :: ns' -> ms.match(
        [] -> false;
        m :: ms' -> n < m \/ n = m /\ ns' <*= ms'
    )
)

indexOf(nss, key) := (
    indexOf'(list, depth) := (
        isEmpty(list) ? nothing
        list[0] =*= key ? just(depth)
        indexOf'(tail(list), depth + 1)
    )
    indexOf'(nss, 0)
)

contains(nss, key) := isJust(nss.indexOf(key))

startsWith(ns, ks) := ks.match(
    [] -> true;
    k :: ks' -> ns.match(
        [] -> false;
        n :: ns' -> n = k /\ startsWith(ns', ks')
    )
)

split(ns, p) := ns.match(
    [] -> ([], []);
    n :: ns' -> (
        p(ns) ? ([], ns)
        (before, after) := ns'.split(p)
        (n :: before, after)
    )
)

splitAt(xs, n) := (xs.take(n), xs.drop(n))
splitWhen(ns, p) := ns.split(p <> head)
splitOn(ns, delimiter) := ns.split(`startsWith(delimiter))

splitWith(ns, splitter) := (
    (before, after) := splitter(ns)
    before.isEmpty ? ([], ns)
    (before', after') := after.splitWith(splitter)
    (before ++ before', after')
)

partition(ns, splitter) := (
    ns.isEmpty ? []
    (before, after) := splitter(ns)
    before :: partition(after, splitter)
)

dropPrefix(ns, prefix) := ns.startsWith(prefix) ? ns.drop(length(prefix)) || ns

partitionBy(ns, p) := ns.partition(`splitWhen(p) <> `dropIf(p))
partitionOn(ns, delimiter) := ns.partition(
    `splitOn(delimiter) <> `dropPrefix(delimiter))

words(ns) := (ns.partitionOn(" ") |: (!) <> isEmpty)
lines(ns) := ns.partitionOn("\n")

-- ASCII character classes
isUppercase(n) := n >= 'A' /\ n <= 'Z'
isLowercase(n) := n >= 'a' /\ n <= 'z'
isDigit(n) := n >= '0' /\ n <= '9'
isQuote(n) := n = '"' \/ n = '\''
isWhitespace(n) := n = ' ' \/ n >= '\t' /\ n <= '\r'
isBlank(n) := n = ' ' \/ n = '\t'
isControl(n) := n >= 0 /\ n < 32 \/ n = 127
isAlphabetic(n) := isUppercase(n) \/ isLowercase(n)
isAlphanumeric(n) := isAlphabetic(n) \/ isDigit(n)
isPrintable(n) := n < 127 /\ ! isControl(n)
isGraphical(n) := isPrintable(n) /\ ! isBlank(n)
isPunctuation(n) := isGraphical(n) /\ ! isAlphanumeric(n)

-- serialization
showBoolean(b) := b ? "true" || "false"
showNatural(n) := (
    showReversedNatural(m) := m = 0 ? [] ||
        ('0' + m.mod(10)) :: showReversedNatural(m // 10)
    n = 0 ? "0" || reverse(showReversedNatural(n))
)

showString(ns) := "\"" ++ ns ++ "\""     -- todo: escape
showPair(xsxs) := "(" ++ xsxs.first ++ ", " ++ xsxs.second ++ ")"
showList(xs) := "[" ++ xs.joinWith(", ") ++ "]"
showInteger(n) := (n < 0 ? "-" || "") ++ showNatural(abs(n))

showStringPair(nsns) := showPair(nsns.mapPair(showString))
showIntegerPair(nn) := showPair(nn.mapPair(showInteger))
showStringIntegerPair(nsn) := showPair(
    (showString(nsn.first), showInteger(nsn.second)))

showStringList(nss) := showList(nss.map(showString))
showIntegerList(ns) := showList(ns.map(showInteger))
showIntegerPairList(nns) := showList(nns.map(showIntegerPair))
showIntegerListPair(nsns) := showPair(nsns.mapPair(showIntegerList))
showIntegerListList(nss) := showList(nss.map(showIntegerList))
showStringIntegerPairList(nsns) := showList(nsns.map(showStringIntegerPair))

-- parsing
parseDigit(digit, base) :=
    isDigit(digit) /\ digit - '0' < base ? digit - '0' ||
    error("Invalid digit in base " ++ showInteger(base) ++ ": " ++ [digit])
parseNatural(string, base) :=
    string.cascade(x -> d -> base * x + parseDigit(d, base), 0)
parseInteger(string, base) := string.head = '-' ?
    - parseNatural(tail(string), base) || parseNatural(string, base)

-- trees
Tree(a) ::= {node(_ : a, _ : List(Tree(a)))}

-- repl
repl(in, prompt, f) := prompt ++ in.lines.map(f).joinWith("\n" ++ prompt)

--*
