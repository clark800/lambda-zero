#* prelude.zero

id(x) â‰” x
const(x) â‰” _ â†¦ x
f of x â‰” f(x)
match x to f â‰” f(x)
f âˆ˜ g â‰” x â†¦ f(g(x))
`f(x, y) â‰” f(y, x)
``f(x, y, z) â‰” f(y, z, x)
on(f, g) â‰” x â†¦ y â†¦ g(f(x), f(y))
fix(f) â‰” ğ›š(f âˆ˜ ğ›š) where ğ›š(x) â‰” x(x)

# bottom
âŠ¥ â©´ {}

# unit
ğ•Œ â©´ {()}

# pair
a âŠ“ b â©´ {(_ âˆˆ a, _ âˆˆ b)}
first((a, b)) â‰” a
second((a, b)) â‰” b
pair(a, b) â‰” (a, b)
swap((x, y)) â‰” (y, x)
mapFirst(f, xy) â‰” (f(first(xy)), second(xy))
mapSecond(f, xy) â‰” (first(xy), f(second(xy)))
mapPair(f, xx) â‰” (f(first(xx)), f(second(xx)))
curry(f) â‰” x â†¦ y â†¦ f((x, y))
uncurry(f) â‰” xx â†¦ f(first(xx), second(xx))

# more tuples
Triple(a, b, c) â©´ {(_ âˆˆ a, _ âˆˆ b, _ âˆˆ c)}
Quadruple(a, b, c, d) â©´ {(_ âˆˆ a, _ âˆˆ b, _ âˆˆ c, _ âˆˆ d)}

# boolean
ğ”¹ â©´ {False, True}
if b then x else y â‰” b â¦Š False â†¦ y; True â†¦ x
not b â‰” if b then False else True
b and c â‰” if b then c else False
b or c â‰” if b then True else c
b xor c â‰” if b then not c else c
until(p, f, z) â‰” if p(z) then z else until(p, f, f(z))
while(p, f, z) â‰” until((not) âˆ˜ p, f, z)

# maybe
(a)? â©´ {Void, Just(_ âˆˆ a)}
isVoid â‰” Void â†¦ True; Just(_) â†¦ False
onJust(f, mx) â‰” mx â¦Š Void â†¦ Void; Just(x) â†¦ f(x)
mapJust(f, mx) â‰” mx.onJust(Just âˆ˜ f)
mx â‡ x â‰” mx â¦Š Void â†¦ x; Just(xâ€²) â†¦ xâ€²

# either
a âŠ” b â©´ {Left(_ âˆˆ a), Right(_ âˆˆ b)}
isLeft â‰” Left(_) â†¦ True; Right(_) â†¦ False
isRight â‰” Left(_) â†¦ False; Right(_) â†¦ True
try exy catch f â‰” exy â¦Š Left(x) â†¦ f(x); Right(y) â†¦ y
onLeft(f, exy) â‰” exy â¦Š Left(x) â†¦ f(x); Right(y) â†¦ Right(y)
onRight(f, exy) â‰” exy â¦Š Left(x) â†¦ Left(x); Right(y) â†¦ f(y)
mapLeft(f, exy) â‰” exy.onLeft(Left âˆ˜ f)
mapRight(f, exy) â‰” exy.onRight(Right âˆ˜ f)
toMaybe â‰” Left(_) â†¦ Void; Right(y) â†¦ Just(y)

# numbers
â„• â©´ {0, â†‘(n âˆˆ â„•)}
â„¤ â©´ {+(n âˆˆ â„•), -(n âˆˆ â„•)}
â„š â©´ {(numerator âˆˆ â„¤) / (denominator âˆˆ â„¤)}
â†“ n â‰” n â¦Š 0 â†¦ 0; â†‘ nâ€² â†¦ nâ€²
positive(n) â‰” + n
negative(n) â‰” - n
negate â‰” + n â†¦ - n; - n â†¦ + n
abs â‰” + n â†¦ + n; - n â†¦ + n
min(n, m) â‰” if n â‰¤ m then n else m
max(n, m) â‰” if n â‰¥ m then n else m
mod(d, n) â‰” n % d
isEven(n) â‰” n.mod(2) = 0
isOdd(n) â‰” n.mod(2) â‰  0
divides(n, d) â‰” n.mod(d) = 0
n ! â‰” n â¦Š 0 â†¦ 1; â†‘ nâ€² â†¦ n â‹… nâ€² !
gcd(n, m) â‰” if m = 0 then n else gcd(m, n.mod(m))
f Â° n â‰” n â¦Š 0 â†¦ id; â†‘ nâ€² â†¦ f âˆ˜ f Â° nâ€²
(n)Â² â‰” n â‹… n
n ^ m â‰” m â¦Š 0 â†¦ 1; â†‘ mâ€² â†¦ if isEven(m) then (n ^ (m â«½ 2))Â² else n â‹… n ^ mâ€²

# (=) â‰” 0 â†¦ (0 â†¦ True; â†‘ _ â†¦ False); â†‘ n â†¦ (0 â†¦ False; â†‘ m â†¦ n = m)
# (â‰ ) â‰” 0 â†¦ (0 â†¦ False; â†‘ _ â†¦ True); â†‘ n â†¦ (0 â†¦ True; â†‘ m â†¦ n â‰  m)
# (<) â‰” 0 â†¦ (0 â†¦ False; â†‘ _ â†¦ True); â†‘ n â†¦ (0 â†¦ False; â†‘ m â†¦ n < m)
# (>) â‰” 0 â†¦ (0 â†¦ False; â†‘ _ â†¦ False); â†‘ n â†¦ (0 â†¦ True; â†‘ m â†¦ n > m)
# (â‰¤) â‰” 0 â†¦ (0 â†¦ True; â†‘ _ â†¦ True); â†‘ n â†¦ (0 â†¦ False; â†‘ m â†¦ n â‰¤ m)
# (â‰¥) â‰” 0 â†¦ (0 â†¦ True; â†‘ _ â†¦ False); â†‘ n â†¦ (0 â†¦ True; â†‘ m â†¦ n â‰¥ m)
# (+) â‰” 0 â†¦ m â†¦ m; â†‘ n â†¦ m â†¦ â†‘(n + m)
# (âˆ¸) â‰” 0 â†¦ (0 â†¦ 0; â†‘ _ â†¦ 0); â†‘ n â†¦ (0 â†¦ â†‘ n; â†‘ m â†¦ n âˆ¸ m)
# (â‹…) â‰” 0 â†¦ _ â†¦ 0; â†‘ n â†¦ m â†¦ m + n â‹… m
# n â«½ m â‰” if m = 0 or n < m then 0 else â†‘((n - m) â«½ m)
# n % m â‰” if m = 0 then n else (if n < m then n else (n - m) % m)

# list
List(a) â©´ {[], (head âˆˆ a) âˆ· (tail âˆˆ List(a))}
prepend â‰” (âˆ·)
isNil â‰” [] â†¦ True; _ âˆ· _ â†¦ False
fold(f, z, xs) â‰” xs â¦Š [] â†¦ z; x âˆ· xsâ€² â†¦ f(x, fold(f, z, xsâ€²))
cascade(f, z, xs) â‰” xs â¦Š [] â†¦ z; x âˆ· xsâ€² â†¦ cascade(f, f(z, x), xsâ€²)
xs â§º ys â‰” xs.fold((âˆ·), ys)
join(xss) â‰” xss.fold((â§º), [])
length(xs) â‰” xs.fold(const(â†‘), 0)
reverse(xs) â‰” xs.cascade(`(âˆ·), [])
drop(n, xs) â‰” n â¦Š 0 â†¦ xs; â†‘ nâ€² â†¦ (xs â¦Š [] â†¦ []; _ âˆ· xsâ€² â†¦ xsâ€².drop(nâ€²))
take(n, xs) â‰” n â¦Š 0 â†¦ []; â†‘ nâ€² â†¦ (xs â¦Š [] â†¦ []; x âˆ· xsâ€² â†¦ x âˆ· xsâ€².take(nâ€²))
xs[n, nâ€²] â‰” xs.drop(n).take(nâ€² âˆ¸ n)
slice(n, nâ€², xs) â‰” xs[n, nâ€²]
dropLast(xs) â‰” xs â¦Š [] â†¦ [];
    x âˆ· xsâ€² â†¦ if isNil(xsâ€²) then [] else x âˆ· dropLast(xsâ€²)
safeHead(xs) â‰” xs â¦Š [] â†¦ Void; x âˆ· _ â†¦ Just(x)
safeTail(xs) â‰” xs â¦Š [] â†¦ Void; _ âˆ· xs â†¦ Just(xs)
safeLast(xs) â‰” xs â¦Š [] â†¦ Void;
    x âˆ· xsâ€² â†¦ (xsâ€² â¦Š [] â†¦ Just(x); _ âˆ· _ â†¦ safeLast(xsâ€²))
at(n, xs) â‰” n â¦Š 0 â†¦ safeHead(xs);
    â†‘ nâ€² â†¦ (xsâ€².at(nâ€²) where maybe xsâ€² â‰” safeTail(xs))
dropIf(p, ns) â‰” ns â¦Š [] â†¦ []; n âˆ· nsâ€² â†¦ if p(n) then nsâ€² else ns
takeWhile(p, xs) â‰” xs â¦Š [] â†¦ [];
    x âˆ· xsâ€² â†¦ if p(x) then x âˆ· takeWhile(p, xsâ€²) else []
dropWhile(p, xs) â‰” xs â¦Š [] â†¦ [];
    x âˆ· xsâ€² â†¦ if p(x) then dropWhile(p, xsâ€²) else xs
filter(p, xs) â‰” xs.fold(x â†¦ xsâ€² â†¦ if p(x) then x âˆ· xsâ€² else xsâ€², [])
xs Â¦ p â‰” filter(p, xs)
map(f, xs) â‰” xs.fold((âˆ·) âˆ˜ f, [])
(â¬«) â‰” map
filterMap(f, xs) â‰” xs â¦Š [] â†¦ []; x âˆ· xsâ€² â†¦
    (f(x) â¦Š Void â†¦ xsâ€³; Just(xâ€²) â†¦ xâ€² âˆ· xsâ€³ where xsâ€³ â‰” filterMap(f, xsâ€²))
prune(mxs) â‰” filterMap(id, mxs)
sequence(mxs) â‰” mxs â¦Š [] â†¦ Just([]); mx âˆ· mxsâ€² â†¦
    (mx â¦Š Void â†¦ Void; Just(x) â†¦
        (sequence(mxsâ€²) â¦Š Void â†¦ Void; Just(xs) â†¦ Just(x âˆ· xs)))
zipWith(f, xs, ys) â‰” xs â¦Š
    [] â†¦ []; x âˆ· xsâ€² â†¦ (ys â¦Š [] â†¦ []; y âˆ· ysâ€² â†¦ f(x, y) âˆ· zipWith(f, xsâ€², ysâ€²))
zip(xs, ys) â‰” zipWith(pair, xs, ys)
unzip(xs) â‰” (xs.map(first), xs.map(second))
pairs(xs) â‰” xs â¦Š [] â†¦ []; _ âˆ· xsâ€² â†¦ zip(xs, xsâ€²)
interleave(y, xs) â‰” xs â¦Š [] â†¦ []; x âˆ· xsâ€² â†¦ x âˆ· interleaveâ€²(xsâ€²) where
    interleaveâ€² â‰” [] â†¦ []; x âˆ· xsâ€² â†¦ y âˆ· x âˆ· interleaveâ€²(xsâ€²)
joinWith(ys, xss) â‰” join(interleave(ys, xss))
bisect(p, xs) â‰” (xs Â¦ p, xs Â¦ (not) âˆ˜ p)
any(p, xs) â‰” xs.map(p).fold((or), False)
all(p, xs) â‰” xs.map(p).fold((and), True)
count(p, xs) â‰” length(xs Â¦ p)

iterate(f, x) â‰” x âˆ· iterate(f, f(x))
repeat(x) â‰” x âˆ· repeat(x)
replicate(n, x) â‰” ((x âˆ·) Â° n)([])
cycle(xs) â‰” xs â§º cycle(xs)
n â€¥ m â‰” if n > m then [] else n âˆ· (â†‘ n â€¥ m)
(â€¦) â‰” iterate(â†‘)
find(p, xs) â‰” safeHead(xs Â¦ p)
contains(p, xs) â‰” not isVoid(xs.find(p))
findIndices(p, xs) â‰” (zip(0 â€¦, xs) Â¦ p âˆ˜ second).map(first)
findIndex(p, xs) â‰” safeHead(findIndices(p, xs))

cascadeMaybe(f, z, xs) â‰” xs â¦Š [] â†¦ Just(z); x âˆ· xsâ€² â†¦
    f(z, x).onJust(y â†¦ cascadeMaybe(f, y, xsâ€²))

# cascadeMap : (a => s => (b && s)) => s => List(a) => (List(b) && s)
cascadeMap(f, z, xs) â‰” xs.cascade((ys, s) â†¦ x â†¦
    f(x, s).mapFirst(âˆ· ys), ([], z)).mapFirst(reverse)

sort â‰” [] â†¦ []; n âˆ· ns â†¦ sort(ns Â¦ (â‰¤ n)) â§º [n] â§º sort(ns Â¦ (> n))

sortBy(â‰¾) â‰” [] â†¦ [];
    n âˆ· ns â†¦ sortBy((â‰¾), ns Â¦ (â‰¾ n)) â§º [n] â§º sortBy((â‰¾), ns Â¦ (not) âˆ˜ (â‰¾ n))

deduplicateBy((â‰Ÿ), xs) â‰” xs â¦Š [] â†¦ [];
    x âˆ· xsâ€² â†¦ x âˆ· deduplicateBy((â‰Ÿ), xsâ€² Â¦ (not) âˆ˜ (â‰Ÿ x))
deduplicate(xs) â‰” deduplicateBy((=), xs)

âˆ‘(ns) â‰” ns.cascade((+), 0)
âˆ(ns) â‰” ns.cascade((â‹…), 1)
sum â‰” âˆ‘
product â‰” âˆ

fibonaccis â‰” f(0, 1) where f(m, n) â‰” m âˆ· f(n, m + n)
primes â‰” p(2 â€¦) where p â‰” [] â†¦ []; n âˆ· ns â†¦ n âˆ· p(ns Â¦ (% n â‰  0))

# string
define xs â‰› ys
    match xs
        [] â†¦ isNil(ys)
        x âˆ· xsâ€² â†¦ (ys â¦Š [] â†¦ False; y âˆ· ysâ€² â†¦ x = y and xsâ€² â‰› ysâ€²)

define ns â©¿ ms
    match ns
        [] â†¦ True
        n âˆ· nsâ€² â†¦ (ms â¦Š [] â†¦ False; m âˆ· msâ€² â†¦ n < m or n = m and nsâ€² â©¿ msâ€²)


define startsWith(ks, ns)
    match ks
        [] â†¦ True
        k âˆ· ksâ€² â†¦ (ns â¦Š [] â†¦ False; n âˆ· nsâ€² â†¦ n = k and startsWith(ksâ€², nsâ€²))

define split(p, xs)
    match xs
        [] â†¦ ([], [])
        x âˆ· xsâ€² â†¦ (if p(xs) then ([], xs) else (x âˆ· before, after) where
                  (before, after) â‰” xsâ€².split(p))

define splitWhen(p, xs)
    match xs
        [] â†¦ ([], [])
        x âˆ· xsâ€² â†¦ (if p(x) then ([], xs) else (x âˆ· before, after) where
                  (before, after) â‰” xsâ€².splitWhen(p))

splitAt(n, xs) â‰” (xs.take(n), xs.drop(n))
splitEvery(n, xs) â‰” if isNil(xs) then [] else
    ys âˆ· splitEvery(n, xsâ€²) where (ys, xsâ€²) â‰” xs.splitAt(n)
splitOn(delimiter, ns) â‰” ns.split(startsWith(delimiter))

define splitWith(splitter, ns)
    (before, after) â‰” splitter(ns)
    if before.isNil
        ([], ns)
    (beforeâ€², afterâ€²) â‰” after.splitWith(splitter)
    (before â§º beforeâ€², afterâ€²)

define partition(splitter, ns)
    if ns.isNil
        []
    (before, after) â‰” splitter(ns)
    before âˆ· after.partition(splitter)

dropPrefix(prefix, ns) â‰”
    if ns.startsWith(prefix) then ns.drop(length(prefix)) else ns

partitionBy(p, ns) â‰” ns.partition(splitWhen(p) âˆ˜ dropIf(p))
partitionOn(delimiter, ns) â‰”
    ns.partition(splitOn(delimiter) âˆ˜ dropPrefix(delimiter))

words(ns) â‰” (ns.partitionOn(" ") Â¦ (not) âˆ˜ isNil)
lines(ns) â‰” ns.partitionOn("\n")

# ASCII character classes
isUppercase(n) â‰” n â‰¥ 'A' and n â‰¤ 'Z'
isLowercase(n) â‰” n â‰¥ 'a' and n â‰¤ 'z'
isDigit(n) â‰” n â‰¥ '0' and n â‰¤ '9'
isQuote(n) â‰” n = '"' or n = '\''
isWhitespace(n) â‰” n = ' ' or n â‰¥ '\t' and n â‰¤ '\r'
isBlank(n) â‰” n = ' ' or n = '\t'
isControl(n) â‰” n â‰¥ 0 and n < 32 or n = 127
isAlphabetic(n) â‰” isUppercase(n) or isLowercase(n)
isAlphanumeric(n) â‰” isAlphabetic(n) or isDigit(n)
isPrintable(n) â‰” n < 127 and not isControl(n)
isGraphical(n) â‰” isPrintable(n) and not isBlank(n)
isPunctuation(n) â‰” isGraphical(n) and not isAlphanumeric(n)

# serialization
showBoolean(b) â‰” if b then "True" else "False"

define showNatural(n)
    define showReversedNatural(m)
        if m = 0 then [] else ('0' + m.mod(10)) âˆ· showReversedNatural(m â«½ 10)
    if n = 0 then "0" else reverse(showReversedNatural(n))

showSign â‰” + _ â†¦ "+"; - _ â†¦ "-"
showInteger(z) â‰” showSign(z) â§º showNatural(z â¦Š + n â†¦ n; - n â†¦ n)
showString(ns) â‰” "\"" â§º ns â§º "\""     # todo: escape
define showPair(showFirst, showSecond, xsxs)
    "(" â§º showFirst(xsxs.first) â§º ", " â§º showSecond(xsxs.second) â§º ")"
showList(showElement, xs) â‰” "[" â§º xs.map(showElement).joinWith(", ") â§º "]"

# parsing
parseDigit(digit) â‰” if isDigit(digit) then Just(digit âˆ¸ '0') else Void
parseNatural(ns) â‰” if isNil(ns) then Void else
    ns.cascadeMaybe(x â†¦ d â†¦
        (Just(10 â‹… x + n) where maybe n â‰” parseDigit(d)), 0)
repl(prompt, f, input) â‰” prompt â§º input.lines.map(f).joinWith("\n" â§º prompt)

# tree
Tree(a) â©´ {Node(datum âˆˆ a, children âˆˆ List(Tree(a)))}

# binary tree
BinaryTree(a) â©´ {
    Tip,
    Fork(datum âˆˆ a, left âˆˆ BinaryTree(a), right âˆˆ BinaryTree(a))
}

define search((â‰¾), hash, key, tree)
    match tree
        case Tip; Void
        case Fork(datum, left, right)
            keyâ€² â‰” hash(datum)
            if key â‰¾ keyâ€²
                if keyâ€² â‰¾ key
                    Just(datum)
                search((â‰¾), hash, key, left)
            search((â‰¾), hash, key, right)

define flatten(tree)
    match tree
        Tip â†¦ []
        Fork(value, left, right) â†¦ flatten(left) â§º [value] â§º flatten(right)

# full binary tree
FullBinaryTree(a) â©´ {
    Leaf(datum âˆˆ a),
    Branch(datum âˆˆ a, left âˆˆ FullBinaryTree(a), right âˆˆ FullBinaryTree(a))
}


define showFullBinaryTree(showElement, tree)
    define showElementLine(indent, x)
        replicate(2 â‹… indent, ' ') â§º showElement(x) â§º "\n"

    define showFullBinaryTreeNode(indent, node)
        match node
            case Leaf(x); showElementLine(indent, x)
            case Branch(x, left, right)
                showElementLine(indent, x) â§º
                    showFullBinaryTreeNode(â†‘ indent, left) â§º
                    showFullBinaryTreeNode(â†‘ indent, right)

    showFullBinaryTreeNode(0, tree)

#*
