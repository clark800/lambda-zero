#* prelude.zero

id(x) ≔ x
constant(x) ≔ _ ↦ x
f of x ≔ f(x)
match x to f ≔ f(x)
f ∘ g ≔ x ↦ f(g(x))
`f(x, y) ≔ f(y, x)
``f(x, y, z) ≔ f(y, z, x)
on(f, g) ≔ x ↦ y ↦ f(g(x), g(y))
fix(f) ≔ 𝛚(f ∘ 𝛚) where 𝛚(x) ≔ x(x)

# bottom
⊥ ⩴ {}

# unit
𝕌 ⩴ {()}

# pair
a ⊓ b ⩴ {(first ∈ a, second ∈ b)}
pair(a, b) ≔ (a, b)
swap((x, y)) ≔ (y, x)
mapFirst(xy, f) ≔ (f(first(xy)), second(xy))
mapSecond(xy, f) ≔ (first(xy), f(second(xy)))
mapPair(xx, f) ≔ (f(first(xx)), f(second(xx)))
curry(f) ≔ x ↦ y ↦ f((x, y))
uncurry(f) ≔ xx ↦ f(first(xx), second(xx))

# more tuples
Triple(a, b, c) ⩴ {(first_3 ∈ a, second_3 ∈ b, third_3 ∈ c)}
Quadruple(a, b, c, d) ⩴ {(first_4 ∈ a, second_4 ∈ b, third_4 ∈ c, fourth_4 ∈ d)}

# boolean
𝔹 ⩴ {false, true}
if b then x else y ≔ b ⦊ false ↦ y; true ↦ x
not b ≔ if b then false else true
b and c ≔ if b then c else false
b or c ≔ if b then true else c
until(f, p, z) ≔ if p(z) then z else f.until(p, f(z))
while(f, p, z) ≔ f.until((not) ∘ p, z)

# maybe
a ? ⩴ {void, just(_ : a)}
isVoid ≔ void ↦ true; just(_) ↦ false
onJust(mx, f) ≔ mx ⦊ void ↦ void; just(x) ↦ f(x)
mapJust(mx, f) ≔ onJust(mx, just ∘ f)
mx ⁇ x ≔ mx ⦊ void ↦ x; just(x′) ↦ x′

# either
a ⊔ b ⩴ {Left(_ : a), Right(_ : b)}
isLeft ≔ Left(_) ↦ true; Right(_) ↦ false
isRight ≔ Left(_) ↦ false; Right(_) ↦ true
try exy catch f ≔ exy ⦊ Left(x) ↦ f(x); Right(y) ↦ y
onLeft(exy, f) ≔ exy ⦊ Left(x) -> f(x); Right(y) -> Right(y)
onRight(exy, f) ≔ exy ⦊ Left(x) ↦ Left(x); Right(y) ↦ f(y)
mapLeft(exy, f) ≔ onLeft(exy, Left ∘ f)
mapRight(exy, f) ≔ onRight(exy, Right ∘ f)
exy ⁈ y ≔ try exy catch constant(y)
toMaybe ≔ Left(_) ↦ void; Right(y) ↦ just(y)

# numbers
ℕ ⩴ {0, ↑((↓) ∈ ℕ)}
ℤ ⩴ {+(_ ∈ ℕ), -(_ ∈ ℕ)}
ℚ ⩴ {(numerator ∈ ℤ) / (denominator ∈ ℤ)}
positive(n) ≔ + n
negative(n) ≔ - n
negate ≔ + n ↦ - n; - n ↦ + n
abs ≔ + n ↦ + n; - n ↦ + n
abs′ ≔ + n ↦ n; - n ↦ n
min(n, m) ≔ if n ≤ m then n else m
max(n, m) ≔ if n ≥ m then n else m
mod(n, m) ≔ n % m
isEven(n) ≔ n.mod(2) = 0
isOdd(n) ≔ n.mod(2) ≠ 0
divides(n, m) ≔ m.mod(n) = 0
n ! ≔ n ⦊ 0 ↦ 1; ↑ n′ ↦ n ⋅ n′ !
gcd(n, m) ≔ if m = 0 then n else gcd(m, n.mod(m))
f ° n ≔ n ⦊ 0 ↦ id; ↑ n′ ↦ f ∘ f ° n′
(n)² ≔ n ⋅ n
n ^ m ≔ m ⦊ 0 ↦ 1; ↑ m′ ↦ if isEven(m) then (n ^ (m ⫽ 2))² else n ⋅ n ^ m′

# (=) ≔ 0 ↦ (0 ↦ true; ↑ _ ↦ false); ↑ n ↦ (0 ↦ false; ↑ m ↦ n = m)
# (≠) ≔ 0 ↦ (0 ↦ false; ↑ _ ↦ true); ↑ _ ↦ (0 ↦ true; ↑ m ↦ n ≠ m)
# (<) ≔ 0 ↦ (0 ↦ false; ↑ _↦ true); ↑ n ↦ (0 ↦ false; ↑ m ↦ n < m)
# (>) ≔ 0 ↦ (0 ↦ false; ↑ _ ↦ false); ↑ n ↦ (0 ↦ true; ↑ m ↦ n > m)
# (≤) ≔ 0 ↦ (0 ↦ true; ↑ _ ↦ true); ↑ n ↦ (0 ↦ false; ↑ m ↦ n ≤ m)
# (≥) ≔ 0 ↦ (0 ↦ true; ↑ _ ↦ false); ↑ n ↦ (0 ↦ true; ↑ m ↦ n ≥ m)
# (+) ≔ 0 ↦ m ↦ m; ↑ n ↦ m ↦ ↑(n + m)
# (-) ≔ 0 ↦ (0 ↦ 0; ↑ m ↦ undefined); ↑ n ↦ (0 ↦ ↑ n; ↑ m ↦ n - m)
# (⋅) ≔ 0 ↦ _ ↦ 0; ↑ n ↦ m ↦ m + n ⋅ m
# n ⫽ m ≔ if m = 0 then undefined else (if n < m then 0 else ↑((n - m) ⫽ m))
# n % m ≔ if m = 0 then n else (if n < m then n else (n - m) % m)

# list
List(a) ⩴ {[], (head ∈ a) ∷ (tail ∈ List(a))}
prepend ≔ `(∷)
isNil ≔ [] ↦ true; _ ∷ _ ↦ false
fold(xs, f, z) ≔ xs ⦊ [] ↦ z; x ∷ xs′ ↦ f(x, fold(xs′, f, z))
cascade(xs, f, z) ≔ xs ⦊ [] ↦ z; x ∷ xs′ ↦ cascade(xs′, f, f(z, x))
xs ⧺ ys ≔ xs.fold((∷), ys)
join(xss) ≔ xss.fold((⧺), [])
length(xs) ≔ xs.fold(constant(↑), 0)
reverse(xs) ≔ xs.cascade(`(∷), [])
drop(xs, n) ≔ n ⦊ 0 ↦ xs; ↑ n′ ↦ (xs ⦊ [] ↦ []; _ ∷ xs′ ↦ xs′.drop(n′))
take(xs, n) ≔ n ⦊ 0 ↦ []; ↑ n′ ↦ (xs ⦊ [] ↦ []; x ∷ xs′ ↦ x ∷ xs′.take(n′))
xs[n] ≔ head(xs.drop(n))
at(xs, n) ≔ xs[n]
xs[n, n′] ≔ if n ≥ n′ then [] else xs.drop(n).take(n′ - n)
slice(xs, n, n′) := xs[n, n′]
last(xs) ≔ tail.until(isNil ∘ tail, xs).head
dropLast(xs) ≔ if isNil(xs) or isNil(tail(xs)) then [] else
    head(xs) ∷ dropLast(tail(xs))
reduce(xs, f) ≔ tail(xs).cascade(f, xs[0])
safeHead(xs) ≔ if isNil(xs) then void else just(head(xs))
safeTail(xs) ≔ if isNil(xs) then void else just(tail(xs))
safeIndex(xs) ≔ 0 ↦ safeHead(xs);
    ↑ n′ ↦ (safeIndex(xs′, n′) where maybe xs′ ≔ safeTail(xs))
dropIf(ns, p) ≔ ns ⦊ [] ↦ []; n ∷ ns′ ↦ if p(n) then ns′ else ns
takeWhile(xs, p) ≔ xs ⦊ [] ↦ [];
    x ∷ xs′ ↦ if p(x) then x ∷ takeWhile(xs′, p) else []
dropWhile(xs, p) ≔ xs ⦊ [] ↦ [];
    x ∷ xs′ ↦ if p(x) then dropWhile(xs′, p) else xs
xs ¦ p ≔ fold(xs, x ↦ xs′ ↦ if p(x) then x ∷ xs′ else xs′, [])
filter ≔ (¦)
map(xs, f) ≔ fold(xs, (∷) ∘ f, [])
(<:>) ≔ `map
filterMap(xs, f) := xs |> [] ↦ []; x ∷ xs′ ->
    (f(x) |> void ↦ xs''; just(x') ↦ x' ∷ xs'' where xs'' ≔ filterMap(xs′, f))
zipWith(xs, f, ys) ≔ xs ⦊
    [] ↦ []; x ∷ xs′ ↦ (ys ⦊ [] ↦ []; y ∷ ys′ ↦ f(x, y) ∷ zipWith(xs′, f, ys′))
zip(xs, ys) ≔ zipWith(xs, pair, ys)
unzip(xs) ≔ (xs.map(first), xs.map(second))
pairs(xs) ≔ zip(xs, tail(xs))
interleave(xs, y) ≔ xs ⦊ [] ↦ []; x ∷ xs′ ↦ x ∷ interleave′(xs′) where
    interleave′ ≔ [] ↦ []; x ∷ xs′ ↦ y ∷ x ∷ interleave′(xs′)
joinWith(xss, ys) ≔ join(interleave(xss, ys))
bisect(xs, p) ≔ (xs ¦ p, xs ¦ (not) ∘ p)
any(xs, p) ≔ xs.map(p).fold((or), false)
all(xs, p) ≔ xs.map(p).fold((and), true)
count(xs, p) ≔ length(xs ¦ p)

iterate(f, x) ≔ x ∷ iterate(f, f(x))
repeat(x) ≔ x ∷ repeat(x)
replicate(x, n) ≔ ((x ∷) ° n)([])
cycle(xs) ≔ xs ⧺ cycle(xs)
n ‥ m ≔ if n > m then [] else n ∷ (↑ n ‥ m)
(…) ≔ iterate(↑)
find(xs, p) ≔ safeHead(xs ¦ p)
contains(xs, p) ≔ not isVoid(xs.find(p))
findIndices(xs, p) ≔ (zip(0 …, xs) ¦ p ∘ second).map(first)
findIndex(xs, p) ≔ safeHead(findIndices(xs, p))

# cascadeMap : List(a) => (a => s => (b && s)) => s => (List(b) && s)
cascadeMap(xs, f, z) ≔ xs.cascade((ys, s) ↦ x ↦
    f(x, s).mapFirst(∷ ys), ([], z)).mapFirst(reverse)

sort ≔ [] ↦ []; n ∷ ns ↦ sort(ns ¦ (≤ n)) ⧺ [n] ⧺ sort(ns ¦ (> n))

deduplicateBy(xs, (≟)) ≔ xs ⦊ [] ↦ [];
    x ∷ xs′ ↦ x ∷ deduplicateBy(xs′ ¦ (not) ∘ (≟ x), (≟))
deduplicate(xs) ≔ deduplicateBy(xs, (=))

∑(ns) ≔ ns.cascade((+), 0)
∏(ns) ≔ ns.cascade((⋅), 1)
sum ≔ ∑
product ≔ ∏

minimum(ns) ≔ ns.reduce(min)
maximum(ns) ≔ ns.reduce(max)

fibonaccis ≔ f(0, 1) where f(m, n) ≔ m ∷ f(n, m + n)
primes ≔ p(2 …) where p ≔ [] ↦ []; n ∷ ns ↦ n ∷ p(ns ¦ (% n ≠ 0))

# string
define xs ≛ ys
    match xs
        [] ↦ isNil(ys)
        x ∷ xs′ ↦ (ys ⦊ [] ↦ false; y ∷ ys′ ↦ x = y and xs′ ≛ ys′)

define ns ⩿ ms
    match ns
        [] ↦ true
        n ∷ ns′ ↦ (ms ⦊ [] ↦ false; m ∷ ms′ ↦ n < m or n = m and ns′ ⩿ ms′)


define startsWith(ns, ks)
    match ks
        [] ↦ true
        k ∷ ks′ ↦ (ns ⦊ [] ↦ false; n ∷ ns′ ↦ n = k and startsWith(ns′, ks′))

define split(ns, p)
    match ns
        [] ↦ ([], [])
        n ∷ ns′ ↦ (if p(ns) then ([], ns) else (n ∷ before, after) where
                  (before, after) ≔ ns′.split(p))

splitAt(xs, n) ≔ (xs.take(n), xs.drop(n))
splitWhen(ns, p) ≔ ns.split(p ∘ head)
splitOn(ns, delimiter) ≔ ns.split(`startsWith(delimiter))

define splitWith(ns, splitter)
    (before, after) ≔ splitter(ns)
    if before.isNil
        ([], ns)
    (before′, after′) ≔ after.splitWith(splitter)
    (before ⧺ before′, after′)

define partition(ns, splitter)
    if ns.isNil
        []
    (before, after) ≔ splitter(ns)
    before ∷ partition(after, splitter)

dropPrefix(ns, prefix) ≔ if ns.startsWith(prefix) then
    ns.drop(length(prefix)) else ns

partitionBy(ns, p) ≔ ns.partition(`splitWhen(p) ∘ `dropIf(p))
partitionOn(ns, delimiter) ≔ ns.partition(
    `splitOn(delimiter) ∘ `dropPrefix(delimiter))

words(ns) ≔ (ns.partitionOn(" ") ¦ (not) ∘ isNil)
lines(ns) ≔ ns.partitionOn("\n")

# ASCII character classes
isUppercase(n) ≔ n ≥ 'A' and n ≤ 'Z'
isLowercase(n) ≔ n ≥ 'a' and n ≤ 'z'
isDigit(n) ≔ n ≥ '0' and n ≤ '9'
isQuote(n) ≔ n = '"' or n = '\''
isWhitespace(n) ≔ n = ' ' or n ≥ '\t' and n ≤ '\r'
isBlank(n) ≔ n = ' ' or n = '\t'
isControl(n) ≔ n ≥ 0 and n < 32 or n = 127
isAlphabetic(n) ≔ isUppercase(n) or isLowercase(n)
isAlphanumeric(n) ≔ isAlphabetic(n) or isDigit(n)
isPrintable(n) ≔ n < 127 and not isControl(n)
isGraphical(n) ≔ isPrintable(n) and not isBlank(n)
isPunctuation(n) ≔ isGraphical(n) and not isAlphanumeric(n)

# serialization
showBoolean(b) ≔ if b then "true" else "false"

define showNatural(n)
    define showReversedNatural(m)
        if m = 0 then [] else ('0' + m.mod(10)) ∷ showReversedNatural(m ⫽ 10)
    if n = 0 then "0" else reverse(showReversedNatural(n))

showSign ≔ + _ ↦ "+"; - _ ↦ "-"
showInteger(z) ≔ showSign(z) ⧺ showNatural(abs′(z))
showString(ns) ≔ "\"" ⧺ ns ⧺ "\""     # todo: escape
define showPair(xsxs, showFirst, showSecond)
    "(" ⧺ showFirst(xsxs.first) ⧺ ", " ⧺ showSecond(xsxs.second) ⧺ ")"
showList(xs, showElement) ≔ "[" ⧺ xs.map(showElement).joinWith(", ") ⧺ "]"

# parsing
parseDigit(digit, base) ≔
    if isDigit(digit) and digit - '0' < base then digit - '0' else
    abort "Invalid digit in base " ⧺ showNatural(base) ⧺ ": " ⧺ [digit]
parseNatural(string, base) ≔
    string.cascade(x ↦ d ↦ base ⋅ x + parseDigit(d, base), 0)
parseInteger(string, base) ≔ if string.head = '-' then
    - parseNatural(tail(string), base) else + parseNatural(string, base)
repl(input, prompt, f) ≔ prompt ⧺ input.lines.map(f).joinWith("\n" ⧺ prompt)

# tree
Tree(a) ⩴ {Node(_datum ∈ a, _children ∈ List(Tree(a)))}

# binary tree
BinaryTree(a) ::= {
    Leaf,
    Branch(_datum : a, _left : BinaryTree(a), _right : BinaryTree(a))
}

define flattenBinaryTree
    Leaf -> []
    Branch(value, left, right) ->
        flattenBinaryTree(left) ++ [value] ++ flattenBinaryTree(right)

# undefined
undefined ≔ abort "undefined"

#*
