#* prelude.zero

id(x) â‰” x                        # identity function
constant(x) â‰” _ â†¦ x              # constant function
f of x â‰” f(x)                    # function application
match x; f â‰” f(x)                # pattern matching
f âˆ˜ g â‰” x â†¦ f(g(x))              # function composition
`f(x, y) â‰” f(y, x)               # flip order of first two arguments of function
``f(x, y, z) â‰” f(y, z, x)        # rotate order of first three arguments
on(f, g) â‰” x â†¦ y â†¦ f(g(x), g(y)) # apply binary f with unary g applied first
fix(f) â‰” ğ›š(f âˆ˜ ğ›š) | ğ›š(x) â‰” x(x)  # fixpoint combinator (Y combinator)

# bottom
âŠ¥ â©´ {}

# unit
ğ•Œ â©´ {()}

# pair
Pair(a, b) â©´ {(first âˆˆ a, second âˆˆ b)}
pair(a, b) â‰” (a, b)
swap((x, y)) â‰” (y, x)
mapFirst(xy, f) â‰” (f(first(xy)), second(xy))
mapSecond(xy, f) â‰” (first(xy), f(second(xy)))
mapPair(xx, f) â‰” (f(first(xx)), f(second(xx)))
curry(f) â‰” x â†¦ y â†¦ f((x, y))
uncurry(f) â‰” xx â†¦ f(first(xx), second(xx))

# more tuples
Triple(a, b, c) â©´ {(first_3 âˆˆ a, second_3 âˆˆ b, third_3 âˆˆ c)}
Quadruple(a, b, c, d) â©´ {(first_4 âˆˆ a, second_4 âˆˆ b, third_4 âˆˆ c, fourth_4 âˆˆ d)}

# boolean
ğ”¹ â©´ {false, true}
(if b)(x, y) â‰” b | false â†¦ y; true â†¦ x
(then) â‰” (of)
(else) â‰” (of)
not b â‰” if b then false else true
b and c â‰” if b then c else false
b or c â‰” if b then true else c
until(f, p, z) â‰” if p(z) then z else f.until(p, f(z))
while(f, p, z) â‰” f.until((not) âˆ˜ p, z)

# maybe
a ? â©´ {void, just(_ : a)}
isVoid â‰” void â†¦ true; just(_) â†¦ false
onJust(mx, f) â‰” mx | void â†¦ void; just(x) â†¦ f(x)
mapJust(mx, f) â‰” onJust(mx, just âˆ˜ f)
mx â‡ x â‰” mx | void â†¦ x; just(xâ€²) â†¦ xâ€²

# either
Either(a, b) â©´ {Left(_ : a), Right(_ : b)}
isLeft â‰” Left(_) â†¦ true; Right(_) â†¦ false
isRight â‰” Left(_) â†¦ false; Right(_) â†¦ true
onLeft(exy, f) â‰” exy | Left(x) â†¦ f(x); Right(y) â†¦ y
onRight(exy, f) â‰” exy | Left(x) â†¦ Left(x); Right(y) â†¦ f(y)
mapLeft(exy, f) â‰” onLeft(exy, Left âˆ˜ f)
mapRight(exy, f) â‰” onRight(exy, Right âˆ˜ f)
(try) â‰” onLeft
(catch) â‰” (of)
exy âˆ y â‰” try exy catch constant(y)
toMaybe â‰” Left(_) â†¦ void; Right(y) â†¦ just(y)

# numbers
â„• â©´ {0, â†‘((â†“) âˆˆ â„•)}
â„¤ â©´ {+(_ âˆˆ â„•), -(_ âˆˆ â„•)}
â„š â©´ {(numerator âˆˆ â„¤) / (denominator âˆˆ â„¤)}
positive(n) â‰” + n
negative(n) â‰” - n
negate â‰” + n â†¦ - n; - n â†¦ + n
abs â‰” + n â†¦ + n; - n â†¦ + n
absâ€² â‰” + n â†¦ n; - n â†¦ n
min(n, m) â‰” if n â‰¤ m then n else m
max(n, m) â‰” if n â‰¥ m then n else m
mod(n, m) â‰” n % m
isEven(n) â‰” n.mod(2) = 0
isOdd(n) â‰” n.mod(2) â‰  0
divides(n, m) â‰” m.mod(n) = 0
n ! â‰” n | 0 â†¦ 1; â†‘ nâ€² â†¦ n â‹… nâ€² !
gcd(n, m) â‰” if m = 0 then n else gcd(m, n.mod(m))
f Â° n â‰” n | 0 â†¦ id; â†‘ nâ€² â†¦ f âˆ˜ f Â° nâ€²
(n)Â² â‰” n â‹… n
n ^ m â‰” m | 0 â†¦ 1; â†‘ mâ€² â†¦ if isEven(m) then (n ^ (m â«½ 2))Â² else n â‹… n ^ mâ€²

# (=) â‰” 0 â†¦ (0 â†¦ true; â†‘ _ â†¦ false); â†‘ n â†¦ (0 â†¦ false; â†‘ m â†¦ n = m)
# (â‰ ) â‰” 0 â†¦ (0 â†¦ false; â†‘ _ â†¦ true); â†‘ _ â†¦ (0 â†¦ true; â†‘ m â†¦ n â‰  m)
# (<) â‰” 0 â†¦ (0 â†¦ false; â†‘ _â†¦ true); â†‘ n â†¦ (0 â†¦ false; â†‘ m â†¦ n < m)
# (>) â‰” 0 â†¦ (0 â†¦ false; â†‘ _ â†¦ false); â†‘ n â†¦ (0 â†¦ true; â†‘ m â†¦ n > m)
# (â‰¤) â‰” 0 â†¦ (0 â†¦ true; â†‘ _ â†¦ true); â†‘ n â†¦ (0 â†¦ false; â†‘ m â†¦ n â‰¤ m)
# (â‰¥) â‰” 0 â†¦ (0 â†¦ true; â†‘ _ â†¦ false); â†‘ n â†¦ (0 â†¦ true; â†‘ m â†¦ n â‰¥ m)
# (+) â‰” 0 â†¦ m â†¦ m; â†‘ n â†¦ m â†¦ â†‘(n + m)
# (-) â‰” 0 â†¦ (0 â†¦ 0; â†‘ m â†¦ undefined); â†‘ n â†¦ (0 â†¦ â†‘ n; â†‘ m â†¦ n - m)
# (â‹…) â‰” 0 â†¦ _ â†¦ 0; â†‘ n â†¦ m â†¦ m + n â‹… m
# n â«½ m â‰” if m = 0 then undefined else (if n < m then 0 else â†‘((n - m) â«½ m))
# n % m â‰” if m = 0 then n else (if n < m then n else (n - m) % m)

# list
List(a) â©´ {[], (head âˆˆ a) âˆ· (tail âˆˆ List(a))}
prepend â‰” `(âˆ·)
isNil â‰” [] â†¦ true; _ âˆ· _ â†¦ false    # note: isEmpty is for sets
fold(xs, f, z) â‰” xs | [] â†¦ z; x âˆ· xsâ€² â†¦ f(x, fold(xsâ€², f, z))
cascade(xs, f, z) â‰” xs | [] â†¦ z; x âˆ· xsâ€² â†¦ cascade(xsâ€², f, f(z, x))
xs â§º ys â‰” xs.fold((âˆ·), ys)                   # concatenate two lists
join(xss) â‰” xss.fold((â§º), [])            # concatenate list of lists
length(xs) â‰” xs.fold(constant(â†‘), 0)         # get length of list
reverse(xs) â‰” xs.cascade(`(âˆ·), [])
drop(xs, n) â‰” n | 0 â†¦ xs; â†‘ nâ€² â†¦ if isNil(xs) then xs else tail(xs).drop(nâ€²)
take(xs, n) â‰” n | 0 â†¦ []; â†‘ nâ€² â†¦
    if isNil(xs) then xs else head(xs) âˆ· tail(xs).take(nâ€²)
xs[n] â‰” head(xs.drop(n))          # get element of list at index
xs[start, end] â‰” xs.drop(start).take(end - start)
last(xs) â‰” tail.until(isNil âˆ˜ tail, xs).head    # get last element of list
dropLast(xs) â‰” if isNil(xs) or isNil(tail(xs)) then [] else
    head(xs) âˆ· dropLast(tail(xs))
reduce(xs, f) â‰” tail(xs).cascade(f, xs[0])
safeHead(xs) â‰” if isNil(xs) then void else just(head(xs))
safeTail(xs) â‰” if isNil(xs) then void else just(tail(xs))
safeIndex(xs) â‰” 0 â†¦ safeHead(xs);
    â†‘ nâ€² â†¦ (safeIndex(xsâ€², nâ€²) | maybe xsâ€² â‰” safeTail(xs))
dropIf(ns, p) â‰” ns | [] â†¦ []; n âˆ· nsâ€² â†¦ if p(n) then nsâ€² else ns
takeWhile(xs, p) â‰” xs | [] â†¦ [];
    x âˆ· xsâ€² â†¦ if p(x) then x âˆ· takeWhile(xsâ€², p) else []
dropWhile(xs, p) â‰” xs | [] â†¦ [];
    x âˆ· xsâ€² â†¦ if p(x) then dropWhile(xsâ€², p) else xs
xs Â¦ p â‰” fold(xs, x â†¦ xsâ€² â†¦ if p(x) then x âˆ· xsâ€² else xsâ€², [])
filter â‰” (Â¦)
map(xs, f) â‰” fold(xs, (âˆ·) âˆ˜ f, [])          # map function over list
(<:>) â‰” `map

define filterMap(xs, f)
    match xs
        [] â†¦ []
        case x âˆ· xsâ€²
            ys â‰” filterMap(xsâ€², f)
            match f(x)
                Left(_) â†¦ ys
                Right(y) â†¦ y âˆ· ys

zipWith(xs, f, ys) â‰” xs |
    [] â†¦ []; x âˆ· xsâ€² â†¦ (ys | [] â†¦ []; y âˆ· ysâ€² â†¦ f(x, y) âˆ· zipWith(xsâ€², f, ysâ€²))

zip(xs, ys) â‰” zipWith(xs, pair, ys)
unzip(xs) â‰” (xs.map(first), xs.map(second))
pairs(xs) â‰” zip(xs, tail(xs))
interleave(xs, y) â‰” xs | [] â†¦ []; x âˆ· xsâ€² â†¦ x âˆ· interleaveâ€²(xsâ€²) |
    interleaveâ€² â‰” [] â†¦ []; x âˆ· xsâ€² â†¦ y âˆ· x âˆ· interleaveâ€²(xsâ€²)
joinWith(xss, ys) â‰” join(interleave(xss, ys))
bisect(xs, p) â‰” (xs Â¦ p, xs Â¦ (not) âˆ˜ p)
any(xs, p) â‰” xs.map(p).fold((or), false)     # test if any element satisfies p
all(xs, p) â‰” xs.map(p).fold((and), true)      # test if all elements satisfy p
count(xs, p) â‰” length(xs Â¦ p)

# generic list constructors
iterate(f, x) â‰” x âˆ· iterate(f, f(x))       # iteratively apply f
repeat(x) â‰” x âˆ· repeat(x)                  # infinitely repeat one element
replicate(x, n) â‰” ((x âˆ·) Â° n)([])         # replicate one element n times
cycle(xs) â‰” xs â§º cycle(xs)                 # infinitely cycle list
n â€¥ m â‰” if n > m then [] else n âˆ· (â†‘ n â€¥ m)
(â€¦) â‰” iterate(â†‘)
find(xs, p) â‰” safeHead(xs Â¦ p)
contains(xs, p) â‰” not isVoid(xs.find(p))
findIndices(xs, p) â‰” (zip(0 â€¦, xs) Â¦ p âˆ˜ second).map(first)
findIndex(xs, p) â‰” safeHead(findIndices(xs, p))

# cascadeMap : a[] => (a => s => b ** s) => s => (b[], s)
cascadeMap(xs, f, z) â‰” xs.cascade((ys, s) â†¦ x â†¦
    f(x, s).mapFirst(âˆ· ys), ([], z)).mapFirst(reverse)

sort â‰” [] â†¦ []; n âˆ· ns â†¦ sort(ns Â¦ (â‰¤ n)) â§º [n] â§º sort(ns Â¦ (> n))

deduplicateBy(xs, (â‰Ÿ)) â‰” xs | [] â†¦ [];
    x âˆ· xsâ€² â†¦ x âˆ· deduplicateBy(xsâ€² Â¦ (not) âˆ˜ (â‰Ÿ x), (â‰Ÿ))
deduplicate(xs) â‰” deduplicateBy(xs, (=))

âˆ‘(ns) â‰” ns.cascade((+), 0)
âˆ(ns) â‰” ns.cascade((â‹…), 1)
sum â‰” âˆ‘
product â‰” âˆ

minimum(ns) â‰” ns.reduce(min)
maximum(ns) â‰” ns.reduce(max)

fibonaccis â‰” f(0, 1) | f(m, n) â‰” m âˆ· f(n, m + n)
primes â‰” p(2 â€¦) | p â‰” [] â†¦ []; n âˆ· ns â†¦ n âˆ· p(ns Â¦ (% n â‰  0))

# string
define xs â‰› ys              # string equality
    match xs
        [] â†¦ isNil(ys)
        x âˆ· xsâ€² â†¦ (ys | [] â†¦ false; y âˆ· ysâ€² â†¦ x = y and xsâ€² â‰› ysâ€²)

define ns â©¿ ms      # string comparison
    match ns
        [] â†¦ true
        n âˆ· nsâ€² â†¦ (ms | [] â†¦ false; m âˆ· msâ€² â†¦ n < m or n = m and nsâ€² â©¿ msâ€²)


define startsWith(ns, ks)
    match ks
        [] â†¦ true
        k âˆ· ksâ€² â†¦ (ns | [] â†¦ false; n âˆ· nsâ€² â†¦ n = k and startsWith(nsâ€², ksâ€²))

define split(ns, p)
    match ns
        [] â†¦ ([], [])
        n âˆ· nsâ€² â†¦ (if p(ns) then ([], ns) else (n âˆ· before, after) |
                  (before, after) â‰” nsâ€².split(p))

splitAt(xs, n) â‰” (xs.take(n), xs.drop(n))
splitWhen(ns, p) â‰” ns.split(p âˆ˜ head)
splitOn(ns, delimiter) â‰” ns.split(`startsWith(delimiter))

define splitWith(ns, splitter)
    (before, after) â‰” splitter(ns)
    if before.isNil
        ([], ns)
    (beforeâ€², afterâ€²) â‰” after.splitWith(splitter)
    (before â§º beforeâ€², afterâ€²)

define partition(ns, splitter)
    if ns.isNil
        []
    (before, after) â‰” splitter(ns)
    before âˆ· partition(after, splitter)

dropPrefix(ns, prefix) â‰” if ns.startsWith(prefix) then
    ns.drop(length(prefix)) else ns

partitionBy(ns, p) â‰” ns.partition(`splitWhen(p) âˆ˜ `dropIf(p))
partitionOn(ns, delimiter) â‰” ns.partition(
    `splitOn(delimiter) âˆ˜ `dropPrefix(delimiter))

words(ns) â‰” (ns.partitionOn(" ") Â¦ (not) âˆ˜ isNil)
lines(ns) â‰” ns.partitionOn("\n")

# ASCII character classes
isUppercase(n) â‰” n â‰¥ 'A' and n â‰¤ 'Z'
isLowercase(n) â‰” n â‰¥ 'a' and n â‰¤ 'z'
isDigit(n) â‰” n â‰¥ '0' and n â‰¤ '9'
isQuote(n) â‰” n = '"' or n = '\''
isWhitespace(n) â‰” n = ' ' or n â‰¥ '\t' and n â‰¤ '\r'
isBlank(n) â‰” n = ' ' or n = '\t'
isControl(n) â‰” n â‰¥ 0 and n < 32 or n = 127
isAlphabetic(n) â‰” isUppercase(n) or isLowercase(n)
isAlphanumeric(n) â‰” isAlphabetic(n) or isDigit(n)
isPrintable(n) â‰” n < 127 and not isControl(n)
isGraphical(n) â‰” isPrintable(n) and not isBlank(n)
isPunctuation(n) â‰” isGraphical(n) and not isAlphanumeric(n)

# serialization
showBoolean(b) â‰” if b then "true" else "false"

define showNatural(n)
    define showReversedNatural(m)
        if m = 0 then [] else ('0' + m.mod(10)) âˆ· showReversedNatural(m â«½ 10)
    if n = 0 then "0" else reverse(showReversedNatural(n))

showSign â‰” + _ â†¦ "+"; - _ â†¦ "-"
showInteger(z) â‰” showSign(z) â§º showNatural(absâ€²(z))
showString(ns) â‰” "\"" â§º ns â§º "\""     # todo: escape
define showPair(xsxs, showFirst, showSecond)
    "(" â§º showFirst(xsxs.first) â§º ", " â§º showSecond(xsxs.second) â§º ")"
showList(xs, showElement) â‰” "[" â§º xs.map(showElement).joinWith(", ") â§º "]"

# parsing
parseDigit(digit, base) â‰”
    if isDigit(digit) and digit - '0' < base then digit - '0' else
    abort "Invalid digit in base " â§º showNatural(base) â§º ": " â§º [digit]
parseNatural(string, base) â‰”
    string.cascade(x â†¦ d â†¦ base â‹… x + parseDigit(d, base), 0)
parseInteger(string, base) â‰” if string.head = '-' then
    - parseNatural(tail(string), base) else + parseNatural(string, base)

# trees
Tree(a) â©´ {Node(getData âˆˆ a, getChildren âˆˆ List(Tree(a)))}

# repl
repl(input, prompt, f) â‰” prompt â§º input.lines.map(f).joinWith("\n" â§º prompt)

undefined â‰” abort "undefined"

#*
