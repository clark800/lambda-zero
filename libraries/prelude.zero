#* prelude.zero

id(x) â‰” x                        # identity function
constant(x) â‰” _ â†¦ x              # constant function
f of x â‰” f(x)                    # function application
(match x)(f) â‰” f(x)              # pattern matching
f âˆ˜ g â‰” x â†¦ f(g(x))              # function composition
`f(x, y) â‰” f(y, x)               # flip order of first two arguments of function
``f(x, y, z) â‰” f(y, z, x)        # rotate order of first three arguments
on(f, g) â‰” x â†¦ y â†¦ f(g(x), g(y)) # apply binary f with unary g applied first
fix(f) â‰” ğ›š(f âˆ˜ ğ›š) | ğ›š(x) â‰” x(x)  # fixpoint combinator (Y combinator)

# bottom
âŠ¥ â©´ {}

# unit
ğ•Œ â©´ {()}

# pair
Pair(a, b) â©´ {(first âˆˆ a, second âˆˆ b)}
pair(a, b) â‰” (a, b)
swap((x, y)) â‰” (y, x)
mapFirst(xy, f) â‰” (f(first(xy)), second(xy))
mapSecond(xy, f) â‰” (first(xy), f(second(xy)))
mapPair(xx, f) â‰” (f(first(xx)), f(second(xx)))
curry(f) â‰” x â†¦ y â†¦ f((x, y))
uncurry(f) â‰” xx â†¦ f(first(xx), second(xx))

# more tuples
Triple(a, b, c) â©´ {(first_3 âˆˆ a, second_3 âˆˆ b, third_3 âˆˆ c)}
Quadruple(a, b, c, d) â©´ {(first_4 âˆˆ a, second_4 âˆˆ b, third_4 âˆˆ c, fourth_4 âˆˆ d)}

# boolean
ğ”¹ â©´ {false, true}
(if b)(x, y) â‰” b | case false â†¦ y; case true â†¦ x
(then) â‰” (of)
(else) â‰” (of)
not b â‰” if b then false else true
b and c â‰” if b then c else false
b or c â‰” if b then true else c
until(f, p, z) â‰” if p(z) then z else f.until(p, f(z))
while(f, p, z) â‰” f.until((not) âˆ˜ p, z)

# maybe
a ? â©´ {void, just(_ : a)}
isVoid â‰” case void -> true; case just(_) -> false
onJust(mx, f) â‰” mx | case void -> void; case just(x) -> f(x)
mapJust(mx, f) â‰” onJust(mx, just <> f)
mx ?? x â‰” mx | case void -> x; case just(x') -> x'

# either
Either(a, b) â©´ {Left(_ : a), Right(_ : b)}
isLeft â‰” case Left(_) â†¦ true; case Right(_) â†¦ false
isRight â‰” case Left(_) â†¦ false; case Right(_) â†¦ true
onLeft(exy, f) â‰” exy | case Left(x) â†¦ f(x); case Right(y) â†¦ y
onRight(exy, f) â‰” exy | case Left(x) â†¦ Left(x); case Right(y) â†¦ f(y)
mapLeft(exy, f) â‰” onLeft(exy, Left <> f)
mapRight(exy, f) â‰” onRight(exy, Right âˆ˜ f)
(try) â‰” onLeft
(catch) â‰” (of)
exy ?! y â‰” try exy catch constant(y)
toMaybe â‰” case Left(_) -> void; case Right(y) -> just(y)

# numbers
â„• â©´ {0, â†‘((â†“) âˆˆ â„•)}
â„¤ â©´ {+(_ âˆˆ â„•), -(_ âˆˆ â„•)}
â„š â©´ {(numerator âˆˆ â„¤) / (denominator âˆˆ â„¤)}
positive(n) â‰” + n
negative(n) â‰” - n
negate â‰” case + n â†¦ - n; case - n â†¦ + n
abs â‰” case + n â†¦ + n; case - n â†¦ + n
absâ€² â‰” case + n â†¦ n; case - n â†¦ n
min(n, m) â‰” if n â‰¤ m then n else m
max(n, m) â‰” if n â‰¥ m then n else m
mod(n, m) â‰” n % m
isEven(n) â‰” n.mod(2) = 0
isOdd(n) â‰” n.mod(2) â‰  0
divides(n, m) â‰” m.mod(n) = 0
n ! â‰” n | case 0 â†¦ 1; case â†‘ nâ€² â†¦ n â‹… nâ€² !
gcd(n, m) â‰” if m = 0 then n else gcd(m, n.mod(m))
f Â° n â‰” n | case 0 â†¦ id; case â†‘ nâ€² â†¦ f âˆ˜ f Â° nâ€²
(n)^2 â‰” n * n

define n ^ m
    match m
        case 0 â†¦ 1
        case â†‘ mâ€² -> if isEven(m) then (n ^ (m â«½ 2))^2 else n â‹… n ^ mâ€²

# (=) â‰” case 0 â†¦ (case 0 â†¦ true; case â†‘ _ â†¦ false);
#       case â†‘ n â†¦ (case 0 â†¦ false; case â†‘ m â†¦ n = m)
# (â‰ ) â‰” case 0 â†¦ (case 0 â†¦ false; case â†‘ _ â†¦ true);
#       case â†‘ _ â†¦ (case 0 â†¦ true; case â†‘ m â†¦ n â‰  m)
# (<) â‰” case 0 â†¦ (case 0 â†¦ false; case â†‘ _â†¦ true);
#       case â†‘ n â†¦ (case 0 â†¦ false; case â†‘ m â†¦ n < m)
# (>) â‰” case 0 â†¦ (case 0 â†¦ false; case â†‘ _ â†¦ false);
#       case â†‘ n â†¦ (case 0 â†¦ true; case â†‘ m â†¦ n > m)
# (â‰¤) â‰” case 0 â†¦ (case 0 â†¦ true; case â†‘ _ â†¦ true);
#       case â†‘ n â†¦ (case 0 â†¦ false; case â†‘ m â†¦ n â‰¤ m)
# (â‰¥) â‰” case 0 â†¦ (case 0 â†¦ true; case â†‘ _ â†¦ false);
#       case â†‘ n â†¦ (case 0 â†¦ true; case â†‘ m â†¦ n â‰¥ m)
# (+) â‰” case 0 â†¦ m â†¦ m; case â†‘ n â†¦ m â†¦ â†‘(n + m)
# (-) â‰” case 0 â†¦ (case 0 â†¦ 0; case â†‘ m â†¦ undefined);
#       case â†‘ n â†¦ (case 0 â†¦ â†‘ n; case â†‘ m â†¦ n - m)
# (â‹…) â‰” case 0 â†¦ _ â†¦ 0; case â†‘ n â†¦ m â†¦ m + n â‹… m
# n â«½ m â‰” if m = 0 then undefined else (if n < m then 0 else â†‘((n - m) â«½ m))
# n % m â‰” if m = 0 then n else (if n < m then n else (n - m) % m)

# list
List(a) â©´ {[], (head âˆˆ a) âˆ· (tail âˆˆ List(a))}
prepend â‰” `(âˆ·)
isNil â‰” case [] â†¦ true; case _ âˆ· _ â†¦ false    # note: isEmpty is for sets
fold(xs, f, z) â‰” xs | case [] â†¦ z; case x âˆ· xsâ€² â†¦ f(x, fold(xsâ€², f, z))
cascade(xs, f, z) â‰” xs | case [] â†¦ z; case x âˆ· xsâ€² â†¦ cascade(xsâ€², f, f(z, x))
xs â§º ys â‰” xs.fold((âˆ·), ys)                   # concatenate two lists
join(xss) â‰” xss.fold((â§º), [])            # concatenate list of lists
length(xs) â‰” xs.fold(constant(â†‘), 0)         # get length of list
reverse(xs) â‰” xs.cascade(`(âˆ·), [])
drop(xs, n) â‰” n |
    case 0 â†¦ xs; case â†‘ n' â†¦ if isNil(xs) then xs else tail(xs).drop(n')
take(xs, n) â‰” n | case 0 â†¦ []; case â†‘ nâ€² â†¦
    if isNil(xs) then xs else head(xs) âˆ· tail(xs).take(nâ€²)
xs[n] â‰” head(xs.drop(n))          # get element of list at index
xs[start, end] â‰” xs.drop(start).take(end - start)
last(xs) â‰” tail.until(isNil âˆ˜ tail, xs).head    # get last element of list
dropLast(xs) â‰” if isNil(xs) or isNil(tail(xs)) then [] else
    head(xs) âˆ· dropLast(tail(xs))
reduce(xs, f) â‰” tail(xs).cascade(f, xs[0])
safeHead(xs) â‰” if isNil(xs) then void else just(head(xs))
safeTail(xs) â‰” if isNil(xs) then void else just(tail(xs))

define safeIndex(xs)
    case 0 â†¦ safeHead(xs)
    case up n' -> safeIndex(xs', n') | maybe xs' â‰” safeTail(xs)

define dropIf(ns, p)
    match ns
        case [] â†¦ []
        case n âˆ· nsâ€² â†¦ if p(n) then nsâ€² else ns

define takeWhile(xs, p)
    match xs
        case [] â†¦ []
        case x âˆ· xsâ€² â†¦ if p(x) then x âˆ· takeWhile(xsâ€², p) else []

define dropWhile(xs, p)
    match xs
        case [] â†¦ []
        case x âˆ· xsâ€² â†¦ if p(x) then dropWhile(xsâ€², p) else xs

xs Â¦ p â‰” fold(xs, x â†¦ xsâ€² â†¦ if p(x) then x âˆ· xsâ€² else xsâ€², [])
filter â‰” (Â¦)

map(xs, f) â‰” fold(xs, (âˆ·) âˆ˜ f, [])          # map function over list
(<:>) â‰” `map

define filterMap(xs, f)
    match xs
        case [] â†¦ []
        case x âˆ· xs'
            ys â‰” filterMap(xs', f)
            match f(x)
                case Left(_) â†¦  ys
                case Right(y) â†¦ y âˆ· ys

define zipWith(xs, f, ys)
    match xs
        case [] â†¦ []
        case x âˆ· xsâ€²
            match ys
                case [] â†¦ []
                case y âˆ· ysâ€² â†¦ f(x, y) âˆ· zipWith(xsâ€², f, ysâ€²)

zip(xs, ys) â‰” zipWith(xs, pair, ys)
unzip(xs) â‰” (xs.map(first), xs.map(second))
pairs(xs) â‰” zip(xs, tail(xs))

define interleave(xs, y)
    define interleaveâ€²
        case [] â†¦ []
        case x âˆ· xsâ€² â†¦ y âˆ· x âˆ· interleaveâ€²(xsâ€²)
    match xs
        case [] â†¦ []
        case x âˆ· xsâ€² â†¦ x âˆ· interleaveâ€²(xsâ€²)

joinWith(xss, ys) â‰” join(interleave(xss, ys))
bisect(xs, p) â‰” (xs Â¦ p, xs Â¦ (not) âˆ˜ p)
any(xs, p) â‰” xs.map(p).fold((or), false)     # test if any element satisfies p
all(xs, p) â‰” xs.map(p).fold((and), true)      # test if all elements satisfy p
count(xs, p) â‰” length(xs Â¦ p)

# generic list constructors
iterate(f, x) â‰” x âˆ· iterate(f, f(x))       # iteratively apply f
repeat(x) â‰” x âˆ· repeat(x)                  # infinitely repeat one element
replicate(x, n) â‰” ((x âˆ·) Â° n)([])         # replicate one element n times
cycle(xs) â‰” xs â§º cycle(xs)                 # infinitely cycle list

n â€¥ m â‰” if n > m then [] else n âˆ· (â†‘ n â€¥ m)
(â€¦) â‰” iterate(â†‘)

find(xs, p) â‰” safeHead(xs Â¦ p)
contains(xs, p) â‰” not isVoid(xs.find(p))
findIndices(xs, p) â‰” (zip(0 â€¦, xs) Â¦ p âˆ˜ second).map(first)
findIndex(xs, p) â‰” safeHead(findIndices(xs, p))

# cascadeMap : a[] => (a => s => b ** s) => s => (b[], s)
cascadeMap(xs, f, z) â‰” xs.cascade((ys, s) â†¦ x â†¦
    f(x, s).mapFirst(âˆ· ys), ([], z)).mapFirst(reverse)

sort â‰” case [] â†¦ []; case n âˆ· ns â†¦ sort(ns Â¦ (â‰¤ n)) â§º [n] â§º sort(ns Â¦ (> n))

define deduplicateBy(xs, (â‰Ÿ))
    match xs
        case [] â†¦ []
        case x âˆ· xsâ€² â†¦ x âˆ· deduplicateBy(xsâ€² Â¦ (not) âˆ˜ (â‰Ÿ x), (â‰Ÿ))

deduplicate(xs) â‰” deduplicateBy(xs, (=))

âˆ‘(ns) â‰” ns.cascade((+), 0)
âˆ(ns) â‰” ns.cascade((â‹…), 1)
sum â‰” âˆ‘
product â‰” âˆ

minimum(ns) â‰” ns.reduce(min)
maximum(ns) â‰” ns.reduce(max)

primes â‰” p(2 â€¦) | p â‰” case [] â†¦ []; case n âˆ· ns â†¦ n âˆ· p(ns Â¦ (% n â‰  0))

fibonaccis â‰” f(0, 1) | f(m, n) â‰” m âˆ· f(n, m + n)

# string
define xs â‰› ys              # string equality
    match xs
        case [] â†¦ isNil(ys)
        case x âˆ· xsâ€²
            match ys
                case [] â†¦ false
                case y âˆ· ysâ€² â†¦ x = y and xsâ€² â‰› ysâ€²

define ns â©¿ ms      # string comparison
    match ns
        case [] â†¦ true
        case n âˆ· nsâ€²
            match ms
                case [] â†¦ false
                case m âˆ· msâ€² â†¦ n < m or n = m and nsâ€² â©¿ msâ€²


define startsWith(ns, ks)
    match ks
        case [] â†¦ true
        case k âˆ· ksâ€²
            match ns
                case [] â†¦ false
                case n âˆ· nsâ€² â†¦ n = k and startsWith(nsâ€², ksâ€²)

define split(ns, p)
    match ns
        case [] â†¦ ([], [])
        case n âˆ· nsâ€²
            if p(ns)
                ([], ns)
            (n âˆ· before, after) | (before, after) â‰” nsâ€².split(p)

splitAt(xs, n) â‰” (xs.take(n), xs.drop(n))
splitWhen(ns, p) â‰” ns.split(p âˆ˜ head)
splitOn(ns, delimiter) â‰” ns.split(`startsWith(delimiter))

define splitWith(ns, splitter)
    (before, after) â‰” splitter(ns)
    if before.isNil
        ([], ns)
    (beforeâ€², afterâ€²) â‰” after.splitWith(splitter)
    (before â§º beforeâ€², afterâ€²)

define partition(ns, splitter)
    if ns.isNil
        []
    (before, after) â‰” splitter(ns)
    before âˆ· partition(after, splitter)

dropPrefix(ns, prefix) â‰” if ns.startsWith(prefix) then
    ns.drop(length(prefix)) else ns

partitionBy(ns, p) â‰” ns.partition(`splitWhen(p) âˆ˜ `dropIf(p))
partitionOn(ns, delimiter) â‰” ns.partition(
    `splitOn(delimiter) âˆ˜ `dropPrefix(delimiter))

words(ns) â‰” (ns.partitionOn(" ") Â¦ (not) âˆ˜ isNil)
lines(ns) â‰” ns.partitionOn("\n")

# ASCII character classes
isUppercase(n) â‰” n â‰¥ 'A' and n â‰¤ 'Z'
isLowercase(n) â‰” n â‰¥ 'a' and n â‰¤ 'z'
isDigit(n) â‰” n â‰¥ '0' and n â‰¤ '9'
isQuote(n) â‰” n = '"' or n = '\''
isWhitespace(n) â‰” n = ' ' or n â‰¥ '\t' and n â‰¤ '\r'
isBlank(n) â‰” n = ' ' or n = '\t'
isControl(n) â‰” n â‰¥ 0 and n < 32 or n = 127
isAlphabetic(n) â‰” isUppercase(n) or isLowercase(n)
isAlphanumeric(n) â‰” isAlphabetic(n) or isDigit(n)
isPrintable(n) â‰” n < 127 and not isControl(n)
isGraphical(n) â‰” isPrintable(n) and not isBlank(n)
isPunctuation(n) â‰” isGraphical(n) and not isAlphanumeric(n)

# serialization
showBoolean(b) â‰” if b then "true" else "false"

define showNatural(n)
    define showReversedNatural(m)
        if m = 0 then [] else ('0' + m.mod(10)) âˆ· showReversedNatural(m â«½ 10)
    if n = 0 then "0" else reverse(showReversedNatural(n))

showSign â‰” case + _ â†¦ "+"; case - _ â†¦ "-"
showInteger(z) â‰” showSign(z) â§º showNatural(absâ€²(z))
showString(ns) â‰” "\"" â§º ns â§º "\""     # todo: escape
define showPair(xsxs, showFirst, showSecond)
    "(" â§º showFirst(xsxs.first) â§º ", " â§º showSecond(xsxs.second) â§º ")"
showList(xs, showElement) â‰” "[" â§º xs.map(showElement).joinWith(", ") â§º "]"

# parsing
parseDigit(digit, base) â‰”
    if isDigit(digit) and digit - '0' < base then digit - '0' else
    abort "Invalid digit in base " â§º showInteger(base) â§º ": " â§º [digit]
parseNatural(string, base) â‰”
    string.cascade(x â†¦ d â†¦ base â‹… x + parseDigit(d, base), 0)
parseInteger(string, base) â‰” if string.head = '-' then
    - parseNatural(tail(string), base) else + parseNatural(string, base)

# trees
Tree(a) â©´ {Node(getData âˆˆ a, getChildren âˆˆ List(Tree(a)))}

# repl
repl(input, prompt, f) â‰” prompt â§º input.lines.map(f).joinWith("\n" â§º prompt)

undefined â‰” abort "undefined"

#*
