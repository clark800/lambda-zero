#* prelude.zero

id(x) ≔ x                        # identity function
constant(x) ≔ _ ↦ x              # constant function
f of x ≔ f(x)                    # function application
(match x)(f) ≔ f(x)              # pattern matching
f ∘ g ≔ x ↦ f(g(x))              # function composition
`f(x, y) ≔ f(y, x)               # flip order of first two arguments of function
``f(x, y, z) ≔ f(y, z, x)        # rotate order of first three arguments
on(f, g) ≔ x ↦ y ↦ f(g(x), g(y)) # apply binary f with unary g applied first
fix(f) ≔ 𝛚(f ∘ 𝛚) | 𝛚(x) ≔ x(x)  # fixpoint combinator (Y combinator)

# bottom
⊥ ⩴ {}

# unit
𝕌 ⩴ {()}

# pair
Pair(a, b) ⩴ {(first ∈ a, second ∈ b)}
pair(a, b) ≔ (a, b)
swap((x, y)) ≔ (y, x)
mapFirst(xy, f) ≔ (f(first(xy)), second(xy))
mapSecond(xy, f) ≔ (first(xy), f(second(xy)))
mapPair(xx, f) ≔ (f(first(xx)), f(second(xx)))
curry(f) ≔ x ↦ y ↦ f((x, y))
uncurry(f) ≔ xx ↦ f(first(xx), second(xx))

# more tuples
Triple(a, b, c) ⩴ {(first_3 ∈ a, second_3 ∈ b, third_3 ∈ c)}
Quadruple(a, b, c, d) ⩴ {(first_4 ∈ a, second_4 ∈ b, third_4 ∈ c, fourth_4 ∈ d)}

# boolean
𝔹 ⩴ {false, true}
(if b)(x, y) ≔ b | case false ↦ y; case true ↦ x
(then) ≔ (of)
(else) ≔ (of)
not b ≔ if b then false else true
b and c ≔ if b then c else false
b or c ≔ if b then true else c
until(f, p, z) ≔ if p(z) then z else f.until(p, f(z))
while(f, p, z) ≔ f.until((not) ∘ p, z)

# maybe
a ? ⩴ {void, just(_ : a)}
isVoid ≔ case void -> true; case just(_) -> false
onJust(mx, f) ≔ mx | case void -> void; case just(x) -> f(x)
mapJust(mx, f) ≔ onJust(mx, just <> f)
mx ?? x ≔ mx | case void -> x; case just(x') -> x'

# either
Either(a, b) ⩴ {Left(_ : a), Right(_ : b)}
isLeft ≔ case Left(_) ↦ true; case Right(_) ↦ false
isRight ≔ case Left(_) ↦ false; case Right(_) ↦ true
onLeft(exy, f) ≔ exy | case Left(x) ↦ f(x); case Right(y) ↦ y
onRight(exy, f) ≔ exy | case Left(x) ↦ Left(x); case Right(y) ↦ f(y)
mapLeft(exy, f) ≔ onLeft(exy, Left <> f)
mapRight(exy, f) ≔ onRight(exy, Right ∘ f)
(try) ≔ onLeft
(catch) ≔ (of)
exy ?! y ≔ try exy catch constant(y)
toMaybe ≔ case Left(_) -> void; case Right(y) -> just(y)

# numbers
ℕ ⩴ {0, ↑((↓) ∈ ℕ)}
ℤ ⩴ {+(_ ∈ ℕ), -(_ ∈ ℕ)}
ℚ ⩴ {(numerator ∈ ℤ) / (denominator ∈ ℤ)}
positive(n) ≔ + n
negative(n) ≔ - n
negate ≔ case + n ↦ - n; case - n ↦ + n
abs ≔ case + n ↦ + n; case - n ↦ + n
abs′ ≔ case + n ↦ n; case - n ↦ n
min(n, m) ≔ if n ≤ m then n else m
max(n, m) ≔ if n ≥ m then n else m
mod(n, m) ≔ n % m
isEven(n) ≔ n.mod(2) = 0
isOdd(n) ≔ n.mod(2) ≠ 0
divides(n, m) ≔ m.mod(n) = 0
n ! ≔ n | case 0 ↦ 1; case ↑ n′ ↦ n ⋅ n′ !
gcd(n, m) ≔ if m = 0 then n else gcd(m, n.mod(m))
f ° n ≔ n | case 0 ↦ id; case ↑ n′ ↦ f ∘ f ° n′
(n)^2 ≔ n * n

define n ^ m
    match m
        case 0 ↦ 1
        case ↑ m′ -> if isEven(m) then (n ^ (m ⫽ 2))^2 else n ⋅ n ^ m′

# (=) ≔ case 0 ↦ (case 0 ↦ true; case ↑ _ ↦ false);
#       case ↑ n ↦ (case 0 ↦ false; case ↑ m ↦ n = m)
# (≠) ≔ case 0 ↦ (case 0 ↦ false; case ↑ _ ↦ true);
#       case ↑ _ ↦ (case 0 ↦ true; case ↑ m ↦ n ≠ m)
# (<) ≔ case 0 ↦ (case 0 ↦ false; case ↑ _↦ true);
#       case ↑ n ↦ (case 0 ↦ false; case ↑ m ↦ n < m)
# (>) ≔ case 0 ↦ (case 0 ↦ false; case ↑ _ ↦ false);
#       case ↑ n ↦ (case 0 ↦ true; case ↑ m ↦ n > m)
# (≤) ≔ case 0 ↦ (case 0 ↦ true; case ↑ _ ↦ true);
#       case ↑ n ↦ (case 0 ↦ false; case ↑ m ↦ n ≤ m)
# (≥) ≔ case 0 ↦ (case 0 ↦ true; case ↑ _ ↦ false);
#       case ↑ n ↦ (case 0 ↦ true; case ↑ m ↦ n ≥ m)
# (+) ≔ case 0 ↦ m ↦ m; case ↑ n ↦ m ↦ ↑(n + m)
# (-) ≔ case 0 ↦ (case 0 ↦ 0; case ↑ m ↦ undefined);
#       case ↑ n ↦ (case 0 ↦ ↑ n; case ↑ m ↦ n - m)
# (⋅) ≔ case 0 ↦ _ ↦ 0; case ↑ n ↦ m ↦ m + n ⋅ m
# n ⫽ m ≔ if m = 0 then undefined else (if n < m then 0 else ↑((n - m) ⫽ m))
# n % m ≔ if m = 0 then n else (if n < m then n else (n - m) % m)

# list
List(a) ⩴ {[], (head ∈ a) ∷ (tail ∈ List(a))}
prepend ≔ `(∷)
isNil ≔ case [] ↦ true; case _ ∷ _ ↦ false    # note: isEmpty is for sets
fold(xs, f, z) ≔ xs | case [] ↦ z; case x ∷ xs′ ↦ f(x, fold(xs′, f, z))
cascade(xs, f, z) ≔ xs | case [] ↦ z; case x ∷ xs′ ↦ cascade(xs′, f, f(z, x))
xs ⧺ ys ≔ xs.fold((∷), ys)                   # concatenate two lists
join(xss) ≔ xss.fold((⧺), [])            # concatenate list of lists
length(xs) ≔ xs.fold(constant(↑), 0)         # get length of list
reverse(xs) ≔ xs.cascade(`(∷), [])
drop(xs, n) ≔ n |
    case 0 ↦ xs; case ↑ n' ↦ if isNil(xs) then xs else tail(xs).drop(n')
take(xs, n) ≔ n | case 0 ↦ []; case ↑ n′ ↦
    if isNil(xs) then xs else head(xs) ∷ tail(xs).take(n′)
xs[n] ≔ head(xs.drop(n))          # get element of list at index
xs[start, end] ≔ xs.drop(start).take(end - start)
last(xs) ≔ tail.until(isNil ∘ tail, xs).head    # get last element of list
dropLast(xs) ≔ if isNil(xs) or isNil(tail(xs)) then [] else
    head(xs) ∷ dropLast(tail(xs))
reduce(xs, f) ≔ tail(xs).cascade(f, xs[0])
safeHead(xs) ≔ if isNil(xs) then void else just(head(xs))
safeTail(xs) ≔ if isNil(xs) then void else just(tail(xs))

define safeIndex(xs)
    case 0 ↦ safeHead(xs)
    case up n' -> safeIndex(xs', n') | maybe xs' ≔ safeTail(xs)

define dropIf(ns, p)
    match ns
        case [] ↦ []
        case n ∷ ns′ ↦ if p(n) then ns′ else ns

define takeWhile(xs, p)
    match xs
        case [] ↦ []
        case x ∷ xs′ ↦ if p(x) then x ∷ takeWhile(xs′, p) else []

define dropWhile(xs, p)
    match xs
        case [] ↦ []
        case x ∷ xs′ ↦ if p(x) then dropWhile(xs′, p) else xs

xs ¦ p ≔ fold(xs, x ↦ xs′ ↦ if p(x) then x ∷ xs′ else xs′, [])
filter ≔ (¦)

map(xs, f) ≔ fold(xs, (∷) ∘ f, [])          # map function over list
(<:>) ≔ `map

define filterMap(xs, f)
    match xs
        case [] ↦ []
        case x ∷ xs'
            ys ≔ filterMap(xs', f)
            match f(x)
                case Left(_) ↦  ys
                case Right(y) ↦ y ∷ ys

define zipWith(xs, f, ys)
    match xs
        case [] ↦ []
        case x ∷ xs′
            match ys
                case [] ↦ []
                case y ∷ ys′ ↦ f(x, y) ∷ zipWith(xs′, f, ys′)

zip(xs, ys) ≔ zipWith(xs, pair, ys)
unzip(xs) ≔ (xs.map(first), xs.map(second))
pairs(xs) ≔ zip(xs, tail(xs))

define interleave(xs, y)
    define interleave′
        case [] ↦ []
        case x ∷ xs′ ↦ y ∷ x ∷ interleave′(xs′)
    match xs
        case [] ↦ []
        case x ∷ xs′ ↦ x ∷ interleave′(xs′)

joinWith(xss, ys) ≔ join(interleave(xss, ys))
bisect(xs, p) ≔ (xs ¦ p, xs ¦ (not) ∘ p)
any(xs, p) ≔ xs.map(p).fold((or), false)     # test if any element satisfies p
all(xs, p) ≔ xs.map(p).fold((and), true)      # test if all elements satisfy p
count(xs, p) ≔ length(xs ¦ p)

# generic list constructors
iterate(f, x) ≔ x ∷ iterate(f, f(x))       # iteratively apply f
repeat(x) ≔ x ∷ repeat(x)                  # infinitely repeat one element
replicate(x, n) ≔ ((x ∷) ° n)([])         # replicate one element n times
cycle(xs) ≔ xs ⧺ cycle(xs)                 # infinitely cycle list

n ‥ m ≔ if n > m then [] else n ∷ (↑ n ‥ m)
(…) ≔ iterate(↑)

find(xs, p) ≔ safeHead(xs ¦ p)
contains(xs, p) ≔ not isVoid(xs.find(p))
findIndices(xs, p) ≔ (zip(0 …, xs) ¦ p ∘ second).map(first)
findIndex(xs, p) ≔ safeHead(findIndices(xs, p))

# cascadeMap : a[] => (a => s => b ** s) => s => (b[], s)
cascadeMap(xs, f, z) ≔ xs.cascade((ys, s) ↦ x ↦
    f(x, s).mapFirst(∷ ys), ([], z)).mapFirst(reverse)

sort ≔ case [] ↦ []; case n ∷ ns ↦ sort(ns ¦ (≤ n)) ⧺ [n] ⧺ sort(ns ¦ (> n))

define deduplicateBy(xs, (≟))
    match xs
        case [] ↦ []
        case x ∷ xs′ ↦ x ∷ deduplicateBy(xs′ ¦ (not) ∘ (≟ x), (≟))

deduplicate(xs) ≔ deduplicateBy(xs, (=))

∑(ns) ≔ ns.cascade((+), 0)
∏(ns) ≔ ns.cascade((⋅), 1)
sum ≔ ∑
product ≔ ∏

minimum(ns) ≔ ns.reduce(min)
maximum(ns) ≔ ns.reduce(max)

primes ≔ p(2 …) | p ≔ case [] ↦ []; case n ∷ ns ↦ n ∷ p(ns ¦ (% n ≠ 0))

fibonaccis ≔ f(0, 1) | f(m, n) ≔ m ∷ f(n, m + n)

# string
define xs ≛ ys              # string equality
    match xs
        case [] ↦ isNil(ys)
        case x ∷ xs′
            match ys
                case [] ↦ false
                case y ∷ ys′ ↦ x = y and xs′ ≛ ys′

define ns ⩿ ms      # string comparison
    match ns
        case [] ↦ true
        case n ∷ ns′
            match ms
                case [] ↦ false
                case m ∷ ms′ ↦ n < m or n = m and ns′ ⩿ ms′


define startsWith(ns, ks)
    match ks
        case [] ↦ true
        case k ∷ ks′
            match ns
                case [] ↦ false
                case n ∷ ns′ ↦ n = k and startsWith(ns′, ks′)

define split(ns, p)
    match ns
        case [] ↦ ([], [])
        case n ∷ ns′
            if p(ns)
                ([], ns)
            (n ∷ before, after) | (before, after) ≔ ns′.split(p)

splitAt(xs, n) ≔ (xs.take(n), xs.drop(n))
splitWhen(ns, p) ≔ ns.split(p ∘ head)
splitOn(ns, delimiter) ≔ ns.split(`startsWith(delimiter))

define splitWith(ns, splitter)
    (before, after) ≔ splitter(ns)
    if before.isNil
        ([], ns)
    (before′, after′) ≔ after.splitWith(splitter)
    (before ⧺ before′, after′)

define partition(ns, splitter)
    if ns.isNil
        []
    (before, after) ≔ splitter(ns)
    before ∷ partition(after, splitter)

dropPrefix(ns, prefix) ≔ if ns.startsWith(prefix) then
    ns.drop(length(prefix)) else ns

partitionBy(ns, p) ≔ ns.partition(`splitWhen(p) ∘ `dropIf(p))
partitionOn(ns, delimiter) ≔ ns.partition(
    `splitOn(delimiter) ∘ `dropPrefix(delimiter))

words(ns) ≔ (ns.partitionOn(" ") ¦ (not) ∘ isNil)
lines(ns) ≔ ns.partitionOn("\n")

# ASCII character classes
isUppercase(n) ≔ n ≥ 'A' and n ≤ 'Z'
isLowercase(n) ≔ n ≥ 'a' and n ≤ 'z'
isDigit(n) ≔ n ≥ '0' and n ≤ '9'
isQuote(n) ≔ n = '"' or n = '\''
isWhitespace(n) ≔ n = ' ' or n ≥ '\t' and n ≤ '\r'
isBlank(n) ≔ n = ' ' or n = '\t'
isControl(n) ≔ n ≥ 0 and n < 32 or n = 127
isAlphabetic(n) ≔ isUppercase(n) or isLowercase(n)
isAlphanumeric(n) ≔ isAlphabetic(n) or isDigit(n)
isPrintable(n) ≔ n < 127 and not isControl(n)
isGraphical(n) ≔ isPrintable(n) and not isBlank(n)
isPunctuation(n) ≔ isGraphical(n) and not isAlphanumeric(n)

# serialization
showBoolean(b) ≔ if b then "true" else "false"

define showNatural(n)
    define showReversedNatural(m)
        if m = 0 then [] else ('0' + m.mod(10)) ∷ showReversedNatural(m ⫽ 10)
    if n = 0 then "0" else reverse(showReversedNatural(n))

showSign ≔ case + _ ↦ "+"; case - _ ↦ "-"
showInteger(z) ≔ showSign(z) ⧺ showNatural(abs′(z))
showString(ns) ≔ "\"" ⧺ ns ⧺ "\""     # todo: escape
define showPair(xsxs, showFirst, showSecond)
    "(" ⧺ showFirst(xsxs.first) ⧺ ", " ⧺ showSecond(xsxs.second) ⧺ ")"
showList(xs, showElement) ≔ "[" ⧺ xs.map(showElement).joinWith(", ") ⧺ "]"

# parsing
parseDigit(digit, base) ≔
    if isDigit(digit) and digit - '0' < base then digit - '0' else
    abort "Invalid digit in base " ⧺ showInteger(base) ⧺ ": " ⧺ [digit]
parseNatural(string, base) ≔
    string.cascade(x ↦ d ↦ base ⋅ x + parseDigit(d, base), 0)
parseInteger(string, base) ≔ if string.head = '-' then
    - parseNatural(tail(string), base) else + parseNatural(string, base)

# trees
Tree(a) ⩴ {Node(getData ∈ a, getChildren ∈ List(Tree(a)))}

# repl
repl(input, prompt, f) ≔ prompt ⧺ input.lines.map(f).joinWith("\n" ⧺ prompt)

undefined ≔ abort "undefined"

#*
