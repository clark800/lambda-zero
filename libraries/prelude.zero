#* prelude.zero

id(x) ≔ x                        # identity function
constant(x) ≔ _ ↦ x              # constant function
f of x ≔ f(x)                    # function application
match x; f ≔ f(x)                # pattern matching
f ∘ g ≔ x ↦ f(g(x))              # function composition
`f(x, y) ≔ f(y, x)               # flip order of first two arguments of function
``f(x, y, z) ≔ f(y, z, x)        # rotate order of first three arguments
on(f, g) ≔ x ↦ y ↦ f(g(x), g(y)) # apply binary f with unary g applied first
fix(f) ≔ 𝛚(f ∘ 𝛚) | 𝛚(x) ≔ x(x)  # fixpoint combinator (Y combinator)

# bottom
⊥ ⩴ {}

# unit
𝕌 ⩴ {()}

# pair
Pair(a, b) ⩴ {(first ∈ a, second ∈ b)}
pair(a, b) ≔ (a, b)
swap((x, y)) ≔ (y, x)
mapFirst(xy, f) ≔ (f(first(xy)), second(xy))
mapSecond(xy, f) ≔ (first(xy), f(second(xy)))
mapPair(xx, f) ≔ (f(first(xx)), f(second(xx)))
curry(f) ≔ x ↦ y ↦ f((x, y))
uncurry(f) ≔ xx ↦ f(first(xx), second(xx))

# more tuples
Triple(a, b, c) ⩴ {(first_3 ∈ a, second_3 ∈ b, third_3 ∈ c)}
Quadruple(a, b, c, d) ⩴ {(first_4 ∈ a, second_4 ∈ b, third_4 ∈ c, fourth_4 ∈ d)}

# boolean
𝔹 ⩴ {false, true}
(if b)(x, y) ≔ b | false ↦ y; true ↦ x
(then) ≔ (of)
(else) ≔ (of)
not b ≔ if b then false else true
b and c ≔ if b then c else false
b or c ≔ if b then true else c
until(f, p, z) ≔ if p(z) then z else f.until(p, f(z))
while(f, p, z) ≔ f.until((not) ∘ p, z)

# maybe
a ? ⩴ {void, just(_ : a)}
isVoid ≔ void ↦ true; just(_) ↦ false
onJust(mx, f) ≔ mx | void ↦ void; just(x) ↦ f(x)
mapJust(mx, f) ≔ onJust(mx, just ∘ f)
mx ⁇ x ≔ mx | void ↦ x; just(x′) ↦ x′

# either
Either(a, b) ⩴ {Left(_ : a), Right(_ : b)}
isLeft ≔ Left(_) ↦ true; Right(_) ↦ false
isRight ≔ Left(_) ↦ false; Right(_) ↦ true
onLeft(exy, f) ≔ exy | Left(x) ↦ f(x); Right(y) ↦ y
onRight(exy, f) ≔ exy | Left(x) ↦ Left(x); Right(y) ↦ f(y)
mapLeft(exy, f) ≔ onLeft(exy, Left ∘ f)
mapRight(exy, f) ≔ onRight(exy, Right ∘ f)
(try) ≔ onLeft
(catch) ≔ (of)
exy ⁈ y ≔ try exy catch constant(y)
toMaybe ≔ Left(_) ↦ void; Right(y) ↦ just(y)

# numbers
ℕ ⩴ {0, ↑((↓) ∈ ℕ)}
ℤ ⩴ {+(_ ∈ ℕ), -(_ ∈ ℕ)}
ℚ ⩴ {(numerator ∈ ℤ) / (denominator ∈ ℤ)}
positive(n) ≔ + n
negative(n) ≔ - n
negate ≔ + n ↦ - n; - n ↦ + n
abs ≔ + n ↦ + n; - n ↦ + n
abs′ ≔ + n ↦ n; - n ↦ n
min(n, m) ≔ if n ≤ m then n else m
max(n, m) ≔ if n ≥ m then n else m
mod(n, m) ≔ n % m
isEven(n) ≔ n.mod(2) = 0
isOdd(n) ≔ n.mod(2) ≠ 0
divides(n, m) ≔ m.mod(n) = 0
n ! ≔ n | 0 ↦ 1; ↑ n′ ↦ n ⋅ n′ !
gcd(n, m) ≔ if m = 0 then n else gcd(m, n.mod(m))
f ° n ≔ n | 0 ↦ id; ↑ n′ ↦ f ∘ f ° n′
(n)² ≔ n ⋅ n
n ^ m ≔ m | 0 ↦ 1; ↑ m′ ↦ if isEven(m) then (n ^ (m ⫽ 2))² else n ⋅ n ^ m′

# (=) ≔ 0 ↦ (0 ↦ true; ↑ _ ↦ false); ↑ n ↦ (0 ↦ false; ↑ m ↦ n = m)
# (≠) ≔ 0 ↦ (0 ↦ false; ↑ _ ↦ true); ↑ _ ↦ (0 ↦ true; ↑ m ↦ n ≠ m)
# (<) ≔ 0 ↦ (0 ↦ false; ↑ _↦ true); ↑ n ↦ (0 ↦ false; ↑ m ↦ n < m)
# (>) ≔ 0 ↦ (0 ↦ false; ↑ _ ↦ false); ↑ n ↦ (0 ↦ true; ↑ m ↦ n > m)
# (≤) ≔ 0 ↦ (0 ↦ true; ↑ _ ↦ true); ↑ n ↦ (0 ↦ false; ↑ m ↦ n ≤ m)
# (≥) ≔ 0 ↦ (0 ↦ true; ↑ _ ↦ false); ↑ n ↦ (0 ↦ true; ↑ m ↦ n ≥ m)
# (+) ≔ 0 ↦ m ↦ m; ↑ n ↦ m ↦ ↑(n + m)
# (-) ≔ 0 ↦ (0 ↦ 0; ↑ m ↦ undefined); ↑ n ↦ (0 ↦ ↑ n; ↑ m ↦ n - m)
# (⋅) ≔ 0 ↦ _ ↦ 0; ↑ n ↦ m ↦ m + n ⋅ m
# n ⫽ m ≔ if m = 0 then undefined else (if n < m then 0 else ↑((n - m) ⫽ m))
# n % m ≔ if m = 0 then n else (if n < m then n else (n - m) % m)

# list
List(a) ⩴ {[], (head ∈ a) ∷ (tail ∈ List(a))}
prepend ≔ `(∷)
isNil ≔ [] ↦ true; _ ∷ _ ↦ false    # note: isEmpty is for sets
fold(xs, f, z) ≔ xs | [] ↦ z; x ∷ xs′ ↦ f(x, fold(xs′, f, z))
cascade(xs, f, z) ≔ xs | [] ↦ z; x ∷ xs′ ↦ cascade(xs′, f, f(z, x))
xs ⧺ ys ≔ xs.fold((∷), ys)                   # concatenate two lists
join(xss) ≔ xss.fold((⧺), [])            # concatenate list of lists
length(xs) ≔ xs.fold(constant(↑), 0)         # get length of list
reverse(xs) ≔ xs.cascade(`(∷), [])
drop(xs, n) ≔ n | 0 ↦ xs; ↑ n′ ↦ if isNil(xs) then xs else tail(xs).drop(n′)
take(xs, n) ≔ n | 0 ↦ []; ↑ n′ ↦
    if isNil(xs) then xs else head(xs) ∷ tail(xs).take(n′)
xs[n] ≔ head(xs.drop(n))          # get element of list at index
xs[start, end] ≔ xs.drop(start).take(end - start)
last(xs) ≔ tail.until(isNil ∘ tail, xs).head    # get last element of list
dropLast(xs) ≔ if isNil(xs) or isNil(tail(xs)) then [] else
    head(xs) ∷ dropLast(tail(xs))
reduce(xs, f) ≔ tail(xs).cascade(f, xs[0])
safeHead(xs) ≔ if isNil(xs) then void else just(head(xs))
safeTail(xs) ≔ if isNil(xs) then void else just(tail(xs))
safeIndex(xs) ≔ 0 ↦ safeHead(xs);
    ↑ n′ ↦ (safeIndex(xs′, n′) | maybe xs′ ≔ safeTail(xs))
dropIf(ns, p) ≔ ns | [] ↦ []; n ∷ ns′ ↦ if p(n) then ns′ else ns
takeWhile(xs, p) ≔ xs | [] ↦ [];
    x ∷ xs′ ↦ if p(x) then x ∷ takeWhile(xs′, p) else []
dropWhile(xs, p) ≔ xs | [] ↦ [];
    x ∷ xs′ ↦ if p(x) then dropWhile(xs′, p) else xs
xs ¦ p ≔ fold(xs, x ↦ xs′ ↦ if p(x) then x ∷ xs′ else xs′, [])
filter ≔ (¦)
map(xs, f) ≔ fold(xs, (∷) ∘ f, [])          # map function over list
(<:>) ≔ `map

define filterMap(xs, f)
    match xs
        [] ↦ []
        case x ∷ xs′
            ys ≔ filterMap(xs′, f)
            match f(x)
                Left(_) ↦ ys
                Right(y) ↦ y ∷ ys

zipWith(xs, f, ys) ≔ xs |
    [] ↦ []; x ∷ xs′ ↦ (ys | [] ↦ []; y ∷ ys′ ↦ f(x, y) ∷ zipWith(xs′, f, ys′))

zip(xs, ys) ≔ zipWith(xs, pair, ys)
unzip(xs) ≔ (xs.map(first), xs.map(second))
pairs(xs) ≔ zip(xs, tail(xs))
interleave(xs, y) ≔ xs | [] ↦ []; x ∷ xs′ ↦ x ∷ interleave′(xs′) |
    interleave′ ≔ [] ↦ []; x ∷ xs′ ↦ y ∷ x ∷ interleave′(xs′)
joinWith(xss, ys) ≔ join(interleave(xss, ys))
bisect(xs, p) ≔ (xs ¦ p, xs ¦ (not) ∘ p)
any(xs, p) ≔ xs.map(p).fold((or), false)     # test if any element satisfies p
all(xs, p) ≔ xs.map(p).fold((and), true)      # test if all elements satisfy p
count(xs, p) ≔ length(xs ¦ p)

# generic list constructors
iterate(f, x) ≔ x ∷ iterate(f, f(x))       # iteratively apply f
repeat(x) ≔ x ∷ repeat(x)                  # infinitely repeat one element
replicate(x, n) ≔ ((x ∷) ° n)([])         # replicate one element n times
cycle(xs) ≔ xs ⧺ cycle(xs)                 # infinitely cycle list
n ‥ m ≔ if n > m then [] else n ∷ (↑ n ‥ m)
(…) ≔ iterate(↑)
find(xs, p) ≔ safeHead(xs ¦ p)
contains(xs, p) ≔ not isVoid(xs.find(p))
findIndices(xs, p) ≔ (zip(0 …, xs) ¦ p ∘ second).map(first)
findIndex(xs, p) ≔ safeHead(findIndices(xs, p))

# cascadeMap : a[] => (a => s => b ** s) => s => (b[], s)
cascadeMap(xs, f, z) ≔ xs.cascade((ys, s) ↦ x ↦
    f(x, s).mapFirst(∷ ys), ([], z)).mapFirst(reverse)

sort ≔ [] ↦ []; n ∷ ns ↦ sort(ns ¦ (≤ n)) ⧺ [n] ⧺ sort(ns ¦ (> n))

deduplicateBy(xs, (≟)) ≔ xs | [] ↦ [];
    x ∷ xs′ ↦ x ∷ deduplicateBy(xs′ ¦ (not) ∘ (≟ x), (≟))
deduplicate(xs) ≔ deduplicateBy(xs, (=))

∑(ns) ≔ ns.cascade((+), 0)
∏(ns) ≔ ns.cascade((⋅), 1)
sum ≔ ∑
product ≔ ∏

minimum(ns) ≔ ns.reduce(min)
maximum(ns) ≔ ns.reduce(max)

fibonaccis ≔ f(0, 1) | f(m, n) ≔ m ∷ f(n, m + n)
primes ≔ p(2 …) | p ≔ [] ↦ []; n ∷ ns ↦ n ∷ p(ns ¦ (% n ≠ 0))

# string
define xs ≛ ys              # string equality
    match xs
        [] ↦ isNil(ys)
        x ∷ xs′ ↦ (ys | [] ↦ false; y ∷ ys′ ↦ x = y and xs′ ≛ ys′)

define ns ⩿ ms      # string comparison
    match ns
        [] ↦ true
        n ∷ ns′ ↦ (ms | [] ↦ false; m ∷ ms′ ↦ n < m or n = m and ns′ ⩿ ms′)


define startsWith(ns, ks)
    match ks
        [] ↦ true
        k ∷ ks′ ↦ (ns | [] ↦ false; n ∷ ns′ ↦ n = k and startsWith(ns′, ks′))

define split(ns, p)
    match ns
        [] ↦ ([], [])
        n ∷ ns′ ↦ (if p(ns) then ([], ns) else (n ∷ before, after) |
                  (before, after) ≔ ns′.split(p))

splitAt(xs, n) ≔ (xs.take(n), xs.drop(n))
splitWhen(ns, p) ≔ ns.split(p ∘ head)
splitOn(ns, delimiter) ≔ ns.split(`startsWith(delimiter))

define splitWith(ns, splitter)
    (before, after) ≔ splitter(ns)
    if before.isNil
        ([], ns)
    (before′, after′) ≔ after.splitWith(splitter)
    (before ⧺ before′, after′)

define partition(ns, splitter)
    if ns.isNil
        []
    (before, after) ≔ splitter(ns)
    before ∷ partition(after, splitter)

dropPrefix(ns, prefix) ≔ if ns.startsWith(prefix) then
    ns.drop(length(prefix)) else ns

partitionBy(ns, p) ≔ ns.partition(`splitWhen(p) ∘ `dropIf(p))
partitionOn(ns, delimiter) ≔ ns.partition(
    `splitOn(delimiter) ∘ `dropPrefix(delimiter))

words(ns) ≔ (ns.partitionOn(" ") ¦ (not) ∘ isNil)
lines(ns) ≔ ns.partitionOn("\n")

# ASCII character classes
isUppercase(n) ≔ n ≥ 'A' and n ≤ 'Z'
isLowercase(n) ≔ n ≥ 'a' and n ≤ 'z'
isDigit(n) ≔ n ≥ '0' and n ≤ '9'
isQuote(n) ≔ n = '"' or n = '\''
isWhitespace(n) ≔ n = ' ' or n ≥ '\t' and n ≤ '\r'
isBlank(n) ≔ n = ' ' or n = '\t'
isControl(n) ≔ n ≥ 0 and n < 32 or n = 127
isAlphabetic(n) ≔ isUppercase(n) or isLowercase(n)
isAlphanumeric(n) ≔ isAlphabetic(n) or isDigit(n)
isPrintable(n) ≔ n < 127 and not isControl(n)
isGraphical(n) ≔ isPrintable(n) and not isBlank(n)
isPunctuation(n) ≔ isGraphical(n) and not isAlphanumeric(n)

# serialization
showBoolean(b) ≔ if b then "true" else "false"

define showNatural(n)
    define showReversedNatural(m)
        if m = 0 then [] else ('0' + m.mod(10)) ∷ showReversedNatural(m ⫽ 10)
    if n = 0 then "0" else reverse(showReversedNatural(n))

showSign ≔ + _ ↦ "+"; - _ ↦ "-"
showInteger(z) ≔ showSign(z) ⧺ showNatural(abs′(z))
showString(ns) ≔ "\"" ⧺ ns ⧺ "\""     # todo: escape
define showPair(xsxs, showFirst, showSecond)
    "(" ⧺ showFirst(xsxs.first) ⧺ ", " ⧺ showSecond(xsxs.second) ⧺ ")"
showList(xs, showElement) ≔ "[" ⧺ xs.map(showElement).joinWith(", ") ⧺ "]"

# parsing
parseDigit(digit, base) ≔
    if isDigit(digit) and digit - '0' < base then digit - '0' else
    abort "Invalid digit in base " ⧺ showNatural(base) ⧺ ": " ⧺ [digit]
parseNatural(string, base) ≔
    string.cascade(x ↦ d ↦ base ⋅ x + parseDigit(d, base), 0)
parseInteger(string, base) ≔ if string.head = '-' then
    - parseNatural(tail(string), base) else + parseNatural(string, base)

# trees
Tree(a) ⩴ {Node(getData ∈ a, getChildren ∈ List(Tree(a)))}

# repl
repl(input, prompt, f) ≔ prompt ⧺ input.lines.map(f).joinWith("\n" ⧺ prompt)

undefined ≔ abort "undefined"

#*
