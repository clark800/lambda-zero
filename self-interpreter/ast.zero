#* ast.zero

DefinitionType ::=
    {PlainDefinition, TryDefinition, SyntaxDefinition, ADTDefinition}

SectionSide ::= {LeftSection, RightSection, LeftRightSection}

AST ::= {
    Name(_ : Tag),
    Arrow(_ : Tag, getArrowLeft : AST, getArrowRight : AST),
    Juxtaposition(_ : Tag, getLeft : AST, getRight : AST),
    Number(_ : Tag, getNumericValue : Natural),
    Reference(_ : Tag, _ : Natural),
    Operator(_ : Tag, getRank : Natural, getOperatorSyntax : _),
    Definition(_ : Tag, getDefinitionType : DefinitionType,
        getDefinee : AST, getDefinedValue : AST),
    AsPattern(_ : Tag, getName : AST, getPattern : AST),
    CommaPair(_ : Tag, getCommaLeft : AST, getCommaRight : AST),
    Case(_ : Tag, getConstructors : List(Tag), getCaseBody : AST),
    Section(_ :  Tag, getSide : SectionSide, getSectionBody : AST),
    ADT(_ : Tag, getContents : List(AST))
}

define getTag
    case Name(tag) -> tag
    case Arrow(tag, _, _) -> tag
    case Juxtaposition(tag, _, _) -> tag
    case Number(tag, _) -> tag
    case Reference(tag, _) -> tag
    case Operator(tag, _, _) -> tag
    case Definition(tag, _, _, _) -> tag
    case AsPattern(tag, _, _) -> tag
    case CommaPair(tag, _, _) -> tag
    case Case(tag, _, _) -> tag
    case Section(tag, _, _) -> tag
    case ADT(tag, _) -> tag

define containsName(name)
    case Name(tag) -> getTagLexeme(tag) =*= getTagLexeme(getTag(name))
    case Arrow(_, _, body) -> containsName(name, body)
    case Juxtaposition(_, left, right) ->
        containsName(name, left) or containsName(name, right)
    case Number(_, _) -> false
    case Reference(_, _) -> false
    case Operator(_, _, _) -> false
    case Definition(_, _, _, _) -> false
    case AsPattern(_, _, _) -> false
    case CommaPair(_, _, _) -> false
    case Case(_, _, body) -> containsName(name, body)
    case Section(_, _, _) -> false
    case ADT(_, _) -> false

define showAST
    case Name(tag) -> showTag(tag)
    case Arrow(tag, parameter, body) ->
        "(" ++ showTag(getTag(parameter)) ++ " -> " ++ showAST(body) ++ ")"
    case Juxtaposition(tag, left, right) ->
        "(" ++ showAST(left) ++ " " ++ showAST(right) ++ ")"
    case Number(tag, value) -> showNatural(value)
    case Reference(tag, debruijn) -> showTag(tag)
    case Operator(tag, rank, rules) -> showTag(tag)
    case Definition(tag, _, left, right) ->
        "(" ++ showAST(left) ++ " := " ++ showAST(right) ++ ")"
    case AsPattern(tag, name, pattern) ->
        "(" ++ showAST(name) ++ ")@(" ++ showAST(pattern) ++ ")"
    case CommaPair(tag, left, right) ->
        "(" ++ showAST(left) ++ ", " ++ showAST(right) ++ ")"
    case Case(tag, _, body) -> "(case -> " ++ showAST(body) ++ ")"
    case Section(_, _, body) -> showAST(body)
    case ADT(_, contents) -> "{" ++ contents.map(showAST).joinWith(", ") ++ "}"

define indexAST
    case Name(_) -> 0
    case Arrow(_, _, _) -> 1
    case Juxtaposition(_, _, _) -> 2
    case Number(_, _) -> 3
    case Reference(_, _) -> 4
    case Operator(_, _, _) -> 5
    case Definition(_, _, _, _) -> 6
    case AsPattern(_, _, _) -> 7
    case CommaPair(_, _, _) -> 8
    case Case(_, _, _) -> 9
    case Section(_, _, _) -> 10
    case ADT(_, _) -> 11

isName(node) := indexAST(node) = 0
isArrow(node) := indexAST(node) = 1
isJuxtaposition(node) := indexAST(node) = 2
isNumber(node) := indexAST(node) = 3
isReference(node) := indexAST(node) = 4
isOperator(node) := indexAST(node) = 5
isDefinition(node) := indexAST(node) = 6
isAsPattern(node) := indexAST(node) = 7
isCommaPair(node) := indexAST(node) = 8
isCase(node) := indexAST(node) = 9
isSection(node) := indexAST(node) = 10
isADT(node) := indexAST(node) = 11

define indexDefinitionType
    case PlainDefinition -> 0
    case TryDefinition -> 1
    case SyntaxDefinition -> 2
    case ADTDefinition -> 3

isSyntaxDefinition(node) :=
    isDefinition(node) and indexDefinitionType(getDefinitionType(node)) = 2

getLexeme(node) := getTagLexeme(getTag(node))
showLexeme(node) := showTag(getTag(node))

NULL := Name(Tag("\0\0", Location("", 0, 0)))
isThisName(node, lexeme) := isName(node) and getLexeme(node) =*= lexeme
isThisOperator(node, lexeme) := isOperator(node) and getLexeme(node) =*= lexeme
isNull(node) := isThisName(node, "\0\0")
isEOF(node) := isThisOperator(node, "\0")
isUnderscore(tag) := getTagLexeme(tag) =*= "_"
isUnused(tag) := getTagLexeme(tag).startsWith("_")
isKeyphrase(node, lexeme) :=
    isJuxtaposition(node) and isThisName(getLeft(node), lexeme)

define newUnderscore(tag, debruijn)
    Reference(Tag("_", getTagLocation(tag)), debruijn)

define newNil(tag)
    Name(Tag("[]", getTagLocation(tag)))

define prependList(tag, item, list)
    name := Name(Tag("::", getTagLocation(tag)))
    Juxtaposition(tag, Juxtaposition(tag, name, item), list)

define renameTag(tag, lexeme)
    Tag(lexeme, getTagLocation(tag))

define renameNode(node, lexeme)
    Name(renameTag(getTag(node), lexeme))

define newLeftPlaceholder(tag)
    Section(tag, RightSection, Name(renameTag(tag, ".*")))

define newRightPlaceholder(tag)
    Section(tag, LeftSection, Name(renameTag(tag, "*.")))

define isLeftPlaceholder(node)
    isSection(node) and isThisName(getSectionBody(node), ".*")

define wrapLeftSection(tag, body)
    Arrow(tag, Name(renameTag(tag, "*.")), body)

define wrapRightSection(tag, body)
    Arrow(tag, Name(renameTag(tag, ".*")), body)

define wrapSection(tag, section)
    body := getSectionBody(section)
    match getSide(section)
        case LeftSection
            wrapLeftSection(tag, body)
        case RightSection
            if isName(getLeft(body))
                getLeft(body)       # parenthesized postfix operator
            wrapRightSection(tag, body)
        case LeftRightSection
            wrapLeftSection(tag, wrapRightSection(tag, body))

#*
