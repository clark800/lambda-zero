#* ast.zero

NOFIX := 0
PREFIX := 1
INFIX := 2
POSTFIX := 3
OPENFIX := 4
CLOSEFIX := 5

CoupleType ::= {JuxtapositionCouple, LetCouple}
DefinitionType ::= {PlainDefinition, MaybeDefinition, TryDefinition,
    SyntaxDefinition, ADTDefinition}
ArrowType ::= {Simple, Strict, Locked}
SectionSide ::= {LeftSection, RightSection, LeftRightSection}

State(ast, syntax) ::= {State(
    getStack : List(ast),
    getOperators : List(Protoset(List(ℕ) && syntax))
)}

Syntax(ast) ::= {Syntax(
    getAlias : List(ℕ),
    getLeftPrecedence : ℕ,
    getRightPrecedence : ℕ,
    getFixity : ℕ,
    getAssociativity : ℕ,
    getSpecial : 𝔹,
    getShift : (State(ast, Syntax(ast)) => ast => State(ast, Syntax(ast))),
    getReduce : (ast => ast => ast => ast),
    getPrior : List(ℕ)
)}

AST ::= {
    Reference(_ : Tag, getReferenceIndex : ℕ,
        getReferenceDepth : ℕ, getReferenceFixity : ℕ),
    Arrow(_ : Tag, getArrowType : ArrowType, getConstructors : List(AST),
        getArrowLeft : AST, getArrowRight : AST),
    Couple(_ : Tag, getCoupleType : CoupleType,
        getLeft : AST, getRight : AST),
    Number(_ : Tag, getNumericValue : ℕ),
    Operator(_ : Tag, getRank : ℕ, getSyntax : Syntax(AST)),
    Definition(_ : Tag, getDefinitionType : DefinitionType,
        getDefiniendum : AST, getDefiniens : AST),
    AsPattern(_ : Tag, getLabel : AST, getPattern : AST),
    CommaPair(_ : Tag, getCommaLeft : AST, getCommaRight : AST),
    Section(_ :  Tag, getSide : SectionSide, getSectionBody : AST),
    SetBuilder(_ : Tag, getForms : List(AST)),
    Constructor(_ : Tag, _parameterTypes : List(AST), _dataType : AST,
        _function : AST, _count : ℕ, _index : ℕ),
    Deconstructor(_ : Tag, _parameterTypes : List(AST), _dataType : AST,
        _function : AST, _count : ℕ, _index : ℕ),
    Accessor(_ : Tag, _dataType : AST, _returnType : AST,
        _function : AST, _count : ℕ, _index : ℕ),
    Null(_ : Tag)
}

define lockArrow(node)
    match node
        Arrow(tag, _, constructors, left, right) ->
            Arrow(tag, Locked, constructors, left, right)
        _ -> node

define getTag
    Reference(tag, _, _, _) -> tag
    Arrow(tag, _, _, _, _) -> tag
    Couple(tag, _, _, _) -> tag
    Number(tag, _) -> tag
    Operator(tag, _, _) -> tag
    Definition(tag, _, _, _) -> tag
    AsPattern(tag, _, _) -> tag
    CommaPair(tag, _, _) -> tag
    Section(tag, _, _) -> tag
    SetBuilder(tag, _) -> tag
    Constructor(tag, _, _, _, _, _) -> tag
    Deconstructor(tag, _, _, _, _, _) -> tag
    Accessor(tag, _, _, _, _, _) -> tag
    Null(tag) -> tag

define containsName(name)
    Reference(tag, _, _, _) -> getTagLexeme(tag) =*= getTagLexeme(getTag(name))
    Arrow(_, _, _, _, body) -> containsName(name, body)
    Couple(_, _, left, right) ->
        containsName(name, left) or containsName(name, right)
    Number(_, _) -> False
    Operator(_, _, _) -> False
    Definition(_, _, _, _) -> False
    AsPattern(_, _, _) -> False
    CommaPair(_, _, _) -> False
    Section(_, _, _) -> False
    SetBuilder(_, _) -> False
    Constructor(_, _, _, _, _, _) -> False
    Deconstructor(_, _, _, _, _, _) -> False
    Accessor(_, _, _, _, _, _) -> False
    Null(_) -> False

define showAST
    Reference(tag, _, _, _) -> showTag(tag)
    Arrow(tag, _, _, parameter, body) ->
        "(" ++ showTag(getTag(parameter)) ++ " -> " ++ showAST(body) ++ ")"
    Couple(tag, _, left, right) ->
        "(" ++ showAST(left) ++ " " ++ showAST(right) ++ ")"
    Number(tag, value) -> showNatural(value)
    Operator(tag, rank, rules) -> showTag(tag)
    Definition(tag, _, left, right) ->
        "(" ++ showAST(left) ++ " := " ++ showAST(right) ++ ")"
    AsPattern(tag, name, pattern) ->
        "(" ++ showAST(name) ++ ")@(" ++ showAST(pattern) ++ ")"
    CommaPair(tag, left, right) ->
        "(" ++ showAST(left) ++ ", " ++ showAST(right) ++ ")"
    Section(_, _, body) -> showAST(body)
    SetBuilder(_, forms) -> "{" ++ forms.map(showAST).joinWith(", ") ++ "}"
    Constructor(_, _, _, body, _, _) -> showAST(body)
    Deconstructor(_, _, _, body, _, _) -> showAST(body)
    Accessor(_, _, _, body, _, _) -> showAST(body)
    Null(_) -> "#NULL#"

isReference := Reference(_, _, _, _) -> True; _ -> False
isArrow := Arrow(_, _, _, _, _) -> True; _ -> False
isCouple := Couple(_, _, _, _) -> True; _ -> False
isNumber := Number(_, _) -> True; _ -> False
isOperator := Operator(_, _, _) -> True; _ -> False
isDefinition := Definition(_, _, _, _) -> True; _ -> False
isAsPattern := AsPattern(_, _, _) -> True; _ -> False
isCommaPair := CommaPair(_, _, _) -> True; _ -> False
isSection := Section(_, _, _) -> True; _ -> False
isSetBuilder := SetBuilder(_, _) -> True; _ -> False
isConstructor := Constructor(_, _, _, _, _, _) -> True; _ -> False
isDeconstructor := Deconstructor(_, _, _, _, _, _) -> True; _ -> False
isAccessor := Accessor(_, _, _, _, _, _) -> True; _ -> False
isNull := Null(_) -> True; _ -> False

isJuxtaposition(node) := isCouple(node) and
    (getCoupleType(node) |> JuxtapositionCouple -> True; _ -> False)
isLetCouple(node) := isCouple(node) and
    (getCoupleType(node) |> LetCouple -> True; _ -> False)

isSimpleArrow(node) := isArrow(node) and
    (getArrowType(node) |> Simple -> True; _ -> False)
isCase(node) := isArrow(node) and
    (getArrowType(node) |> Locked -> False; _ -> True)

Name(tag) := Reference(tag, 0, 0, NOFIX)
isName(node) := isReference(node) and getReferenceIndex(node) = 0
OperatorName(tag, fixity) := Reference(tag, 0, 0, fixity)
Juxtaposition(tag, left, right) := Couple(tag, JuxtapositionCouple, left, right)
Let(tag, left, right) := Couple(tag, LetCouple, left, right)
SimpleArrow(parameter, body) :=
    Arrow(getTag(parameter), Simple, [], parameter, body)
StrictArrow(tag, constructors, body) :=
    Arrow(tag, Strict, constructors, Name(renameTag(tag, "_")), body)
LockedArrow(parameter, body) :=
    Arrow(getTag(parameter), Locked, [], parameter, body)

isSyntaxDefinition(node) := isDefinition(node) and
    (getDefinitionType(node) |> SyntaxDefinition -> True; _ -> False)
getLexeme(node) := getTagLexeme(getTag(node))
showLexeme(node) := showTag(getTag(node))
isThisName(node, lexeme) := isName(node) and getLexeme(node) =*= lexeme
isThisOperator(node, lexeme) := isOperator(node) and getLexeme(node) =*= lexeme
isEOF(node) := isThisOperator(node, "\0")
isUnderscore(tag) := getTagLexeme(tag) =*= "_"
isUnused(tag) := getTagLexeme(tag).startsWith("_")
isKeyphrase(node, lexeme) :=
    isJuxtaposition(node) and isThisName(getLeft(node), lexeme)
UnderscoreArrow(tag, body) :=
    LockedArrow(Name(renameTag(tag, "_")), body)
Underscore(tag, debruijn) := Reference(renameTag(tag, "_"), debruijn, 0, NOFIX)
newNil(tag) := Name(renameTag(tag, "[]"))
prependList(tag, item, list) := Juxtaposition(tag,
    Juxtaposition(tag, OperatorName(renameTag(tag, "::"), INFIX), item), list)
newLeftPlaceholder(tag) :=
    Section(tag, RightSection, Name(renameTag(tag, ".*")))
newRightPlaceholder(tag) :=
    Section(tag, LeftSection, Name(renameTag(tag, "*.")))
isLeftPlaceholder(node) :=
    isSection(node) and isThisName(getSectionBody(node), ".*")
wrapLeftSection(tag, body) :=
    LockedArrow(Name(renameTag(tag, "*.")), body)
wrapRightSection(tag, body) :=
    LockedArrow(Name(renameTag(tag, ".*")), body)

define wrapSection(tag, section)
    body := getSectionBody(section)
    match getSide(section)
        case LeftSection
            wrapLeftSection(tag, body)
        case RightSection
            if isName(getLeft(body))
                getLeft(body)       # parenthesized postfix operator
            wrapRightSection(tag, body)
        case LeftRightSection
            wrapLeftSection(tag, wrapRightSection(tag, body))

#*
