#* ast.zero

CoupleType ::= {JuxtapositionCouple, LetCouple}
DefinitionType ::=
    {PlainDefinition, TryDefinition, SyntaxDefinition, ADTDefinition}
SectionSide ::= {LeftSection, RightSection, LeftRightSection}

AST ::= {
    Name(_ : Tag, _depth : Natural),
    Arrow(_ : Tag, getArrowLeft : AST, getArrowRight : AST),
    Couple(_ : Tag, getCoupleType : CoupleType, getLeft : AST, getRight : AST),
    Number(_ : Tag, getNumericValue : Natural),
    Reference(_ : Tag, _ : Natural),
    Operator(_ : Tag, getRank : Natural, getOperatorSyntax : _),
    Definition(_ : Tag, getDefinitionType : DefinitionType,
        getDefinee : AST, getDefinedValue : AST),
    AsPattern(_ : Tag, getName : AST, getPattern : AST),
    CommaPair(_ : Tag, getCommaLeft : AST, getCommaRight : AST),
    Case(_ : Tag, getConstructors : List(Tag), getCaseBody : AST),
    Section(_ :  Tag, getSide : SectionSide, getSectionBody : AST),
    ADT(_ : Tag, getContents : List(AST)),
    Constructor(_ : Tag, _parameterTypes : List(AST), _dataType : AST, _ : AST),
    Accessor(_ : Tag, _dataType : AST, _returnType : AST, _ : AST),
    Null(_ : tag)
}

define getTag
    case Name(tag, _) -> tag
    case Arrow(tag, _, _) -> tag
    case Couple(tag, _, _, _) -> tag
    case Number(tag, _) -> tag
    case Reference(tag, _) -> tag
    case Operator(tag, _, _) -> tag
    case Definition(tag, _, _, _) -> tag
    case AsPattern(tag, _, _) -> tag
    case CommaPair(tag, _, _) -> tag
    case Case(tag, _, _) -> tag
    case Section(tag, _, _) -> tag
    case ADT(tag, _) -> tag
    case Constructor(tag, _, _, _) -> tag
    case Accessor(tag, _, _, _) -> tag
    case Null(tag) -> tag

define containsName(name)
    case Name(tag, _) -> getTagLexeme(tag) =*= getTagLexeme(getTag(name))
    case Arrow(_, _, body) -> containsName(name, body)
    case Couple(_, _, left, right) ->
        containsName(name, left) or containsName(name, right)
    case Number(_, _) -> false
    case Reference(_, _) -> false
    case Operator(_, _, _) -> false
    case Definition(_, _, _, _) -> false
    case AsPattern(_, _, _) -> false
    case CommaPair(_, _, _) -> false
    case Case(_, _, body) -> containsName(name, body)
    case Section(_, _, _) -> false
    case ADT(_, _) -> false
    case Constructor(_, _, _, _) -> false
    case Accessor(_, _, _, _) -> false
    case Null(_) -> false

define showAST
    case Name(tag, _) -> showTag(tag)
    case Arrow(tag, parameter, body) ->
        "(" ++ showTag(getTag(parameter)) ++ " -> " ++ showAST(body) ++ ")"
    case Couple(tag, _, left, right) ->
        "(" ++ showAST(left) ++ " " ++ showAST(right) ++ ")"
    case Number(tag, value) -> showNatural(value)
    case Reference(tag, debruijn) -> showTag(tag)
    case Operator(tag, rank, rules) -> showTag(tag)
    case Definition(tag, _, left, right) ->
        "(" ++ showAST(left) ++ " := " ++ showAST(right) ++ ")"
    case AsPattern(tag, name, pattern) ->
        "(" ++ showAST(name) ++ ")@(" ++ showAST(pattern) ++ ")"
    case CommaPair(tag, left, right) ->
        "(" ++ showAST(left) ++ ", " ++ showAST(right) ++ ")"
    case Case(tag, _, body) -> "(case -> " ++ showAST(body) ++ ")"
    case Section(_, _, body) -> showAST(body)
    case ADT(_, contents) -> "{" ++ contents.map(showAST).joinWith(", ") ++ "}"
    case Constructor(_, _, _, body) -> showAST(body)
    case Accessor(_, _, _, body) -> showAST(body)
    case Null(_) -> "#NULL#"

define indexAST
    case Name(_, _) -> 0
    case Arrow(_, _, _) -> 1
    case Couple(_, _, _, _) -> 2
    case Number(_, _) -> 3
    case Reference(_, _) -> 4
    case Operator(_, _, _) -> 5
    case Definition(_, _, _, _) -> 6
    case AsPattern(_, _, _) -> 7
    case CommaPair(_, _, _) -> 8
    case Case(_, _, _) -> 9
    case Section(_, _, _) -> 10
    case ADT(_, _) -> 11
    case Constructor(_, _, _, _) -> 12
    case Accessor(_, _, _, _) -> 13
    case Null(_) -> 14

isName(node) := indexAST(node) = 0
isArrow(node) := indexAST(node) = 1
isCouple(node) := indexAST(node) = 2
isNumber(node) := indexAST(node) = 3
isReference(node) := indexAST(node) = 4
isOperator(node) := indexAST(node) = 5
isDefinition(node) := indexAST(node) = 6
isAsPattern(node) := indexAST(node) = 7
isCommaPair(node) := indexAST(node) = 8
isCase(node) := indexAST(node) = 9
isSection(node) := indexAST(node) = 10
isADT(node) := indexAST(node) = 11
isConstructor(node) := indexAST(node) = 12
isAccessor(node) := indexAST(node) = 13
isNull(node) := indexAST(node) = 14

define indexCoupleType
    case JuxtapositionCouple -> 0
    case LetCouple -> 1

isJuxtaposition(node) := indexAST(node) = 2 and
    indexCoupleType(getCoupleType(node)) = 0
isLet(node) := indexAST(node) = 2 and indexCoupleType(getCoupleType(node)) = 1
Juxtaposition(tag, left, right) := Couple(tag, JuxtapositionCouple, left, right)
Let(tag, left, right) := Couple(tag, LetCouple, left, right)

define indexDefinitionType
    case PlainDefinition -> 0
    case TryDefinition -> 1
    case SyntaxDefinition -> 2
    case ADTDefinition -> 3

isSyntaxDefinition(node) :=
    isDefinition(node) and indexDefinitionType(getDefinitionType(node)) = 2
getLexeme(node) := getTagLexeme(getTag(node))
showLexeme(node) := showTag(getTag(node))
isThisName(node, lexeme) := isName(node) and getLexeme(node) =*= lexeme
isThisOperator(node, lexeme) := isOperator(node) and getLexeme(node) =*= lexeme
isEOF(node) := isThisOperator(node, "\0")
isUnderscore(tag) := getTagLexeme(tag) =*= "_"
isUnused(tag) := getTagLexeme(tag).startsWith("_")
isKeyphrase(node, lexeme) :=
    isJuxtaposition(node) and isThisName(getLeft(node), lexeme)
UnderscoreArrow(tag, body) := Arrow(tag, Name(renameTag(tag, "_"), 0), body)
newUnderscore(tag, debruijn) := Reference(renameTag(tag, "_"), debruijn)
newNil(tag) := Name(renameTag(tag, "[]"), 0)
prependList(tag, item, list) := Juxtaposition(tag,
    Juxtaposition(tag, Name(renameTag(tag, "::"), 0), item), list)
newLeftPlaceholder(tag) :=
    Section(tag, RightSection, Name(renameTag(tag, ".*"), 0))
newRightPlaceholder(tag) :=
    Section(tag, LeftSection, Name(renameTag(tag, "*."), 0))
isLeftPlaceholder(node) :=
    isSection(node) and isThisName(getSectionBody(node), ".*")
wrapLeftSection(tag, body) := Arrow(tag, Name(renameTag(tag, "*."), 0), body)
wrapRightSection(tag, body) := Arrow(tag, Name(renameTag(tag, ".*"), 0), body)

define wrapSection(tag, section)
    body := getSectionBody(section)
    match getSide(section)
        case LeftSection
            wrapLeftSection(tag, body)
        case RightSection
            if isName(getLeft(body))
                getLeft(body)       # parenthesized postfix operator
            wrapRightSection(tag, body)
        case LeftRightSection
            wrapLeftSection(tag, wrapRightSection(tag, body))

#*
