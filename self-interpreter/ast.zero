#* ast.zero

NOFIX := 0
PREFIX := 1
INFIX := 2
POSTFIX := 3
OPENFIX := 4
CLOSEFIX := 5

CoupleType ::= {JuxtapositionCouple, LetCouple}
DefinitionType ::= {PlainDefinition, MaybeDefinition, TryDefinition,
    SyntaxDefinition, ADTDefinition}
ArrowType ::= {Simple, Strict, Locked}
SectionSide ::= {LeftSection, RightSection, LeftRightSection}

AST ::= {
    Reference(_ : Tag, getReferenceIndex : Natural,
        getReferenceDepth : Natural, getReferenceFixity : Natural),
    Arrow(_ : Tag, getArrowType : ArrowType, getConstructors : List(AST),
        getArrowLeft : AST, getArrowRight : AST),
    Couple(_ : Tag, getCoupleType : CoupleType, getLeft : AST, getRight : AST),
    Number(_ : Tag, getNumericValue : Natural),
    Operator(_ : Tag, getRank : Natural, getSyntax : _),
    Definition(_ : Tag, getDefinitionType : DefinitionType,
        getDefinee : AST, getDefinedValue : AST),
    AsPattern(_ : Tag, getLabel : AST, getPattern : AST),
    CommaPair(_ : Tag, getCommaLeft : AST, getCommaRight : AST),
    Section(_ :  Tag, getSide : SectionSide, getSectionBody : AST),
    SetBuilder(_ : Tag, getForms : List(AST)),
    Constructor(_ : Tag, _parameterTypes : List(AST), _dataType : AST,
        _function : AST, _count : Natural, _index : Natural),
    Accessor(_ : Tag, _dataType : AST, _returnType : AST,
        _function : AST, _count : Natural, _index : Natural),
    Null(_ : tag)
}

define lockArrow
    Reference(_, _, _, _) -> undefined
    Arrow(tag, _, constructors, left, right) ->
        Arrow(tag, Locked, constructors, left, right)
    Couple(_, _, _, _) -> undefined
    Number(_, _) -> undefined
    Operator(_, _, _) -> undefined
    Definition(_, _, _, _) -> undefined
    AsPattern(_, _, _) -> undefined
    CommaPair(_, _, _) -> undefined
    Section(_, _, _) -> undefined
    SetBuilder(_, _) -> undefined
    Constructor(_, _, _, _, _, _) -> undefined
    Accessor(_, _, _, _, _, _) -> undefined
    Null(_) -> undefined

define getTag
    Reference(tag, _, _, _) -> tag
    Arrow(tag, _, _, _, _) -> tag
    Couple(tag, _, _, _) -> tag
    Number(tag, _) -> tag
    Operator(tag, _, _) -> tag
    Definition(tag, _, _, _) -> tag
    AsPattern(tag, _, _) -> tag
    CommaPair(tag, _, _) -> tag
    Section(tag, _, _) -> tag
    SetBuilder(tag, _) -> tag
    Constructor(tag, _, _, _, _, _) -> tag
    Accessor(tag, _, _, _, _, _) -> tag
    Null(tag) -> tag

define containsName(name)
    Reference(tag, _, _, _) -> getTagLexeme(tag) =*= getTagLexeme(getTag(name))
    Arrow(_, _, _, _, body) -> containsName(name, body)
    Couple(_, _, left, right) ->
        containsName(name, left) or containsName(name, right)
    Number(_, _) -> false
    Operator(_, _, _) -> false
    Definition(_, _, _, _) -> false
    AsPattern(_, _, _) -> false
    CommaPair(_, _, _) -> false
    Section(_, _, _) -> false
    SetBuilder(_, _) -> false
    Constructor(_, _, _, _, _, _) -> false
    Accessor(_, _, _, _, _, _) -> false
    Null(_) -> false

define showAST
    Reference(tag, _, _, _) -> showTag(tag)
    Arrow(tag, _, _, parameter, body) ->
        "(" ++ showTag(getTag(parameter)) ++ " -> " ++ showAST(body) ++ ")"
    Couple(tag, _, left, right) ->
        "(" ++ showAST(left) ++ " " ++ showAST(right) ++ ")"
    Number(tag, value) -> showNatural(value)
    Operator(tag, rank, rules) -> showTag(tag)
    Definition(tag, _, left, right) ->
        "(" ++ showAST(left) ++ " := " ++ showAST(right) ++ ")"
    AsPattern(tag, name, pattern) ->
        "(" ++ showAST(name) ++ ")@(" ++ showAST(pattern) ++ ")"
    CommaPair(tag, left, right) ->
        "(" ++ showAST(left) ++ ", " ++ showAST(right) ++ ")"
    Section(_, _, body) -> showAST(body)
    SetBuilder(_, forms) -> "{" ++ forms.map(showAST).joinWith(", ") ++ "}"
    Constructor(_, _, _, body, _, _) -> showAST(body)
    Accessor(_, _, _, body, _, _) -> showAST(body)
    Null(_) -> "#NULL#"

define indexAST
    Reference(_, _, _, _) -> 0
    Arrow(_, _, _, _, _) -> 1
    Couple(_, _, _, _) -> 2
    Number(_, _) -> 3
    Operator(_, _, _) -> 4
    Definition(_, _, _, _) -> 5
    AsPattern(_, _, _) -> 6
    CommaPair(_, _, _) -> 7
    Section(_, _, _) -> 8
    SetBuilder(_, _) -> 9
    Constructor(_, _, _, _, _, _) -> 10
    Accessor(_, _, _, _, _, _) -> 11
    Null(_) -> 12

isReference(node) := indexAST(node) = 0
isArrow(node) := indexAST(node) = 1
isCouple(node) := indexAST(node) = 2
isNumber(node) := indexAST(node) = 3
isOperator(node) := indexAST(node) = 4
isDefinition(node) := indexAST(node) = 5
isAsPattern(node) := indexAST(node) = 6
isCommaPair(node) := indexAST(node) = 7
isSection(node) := indexAST(node) = 8
isSetBuilder(node) := indexAST(node) = 9
isConstructor(node) := indexAST(node) = 10
isAccessor(node) := indexAST(node) = 11
isNull(node) := indexAST(node) = 12

define indexCoupleType
    JuxtapositionCouple -> 0
    LetCouple -> 1

isJuxtaposition(node) := isCouple(node) and
    indexCoupleType(getCoupleType(node)) = 0
isLetCouple(node) := isCouple(node) and
    indexCoupleType(getCoupleType(node)) = 1

define indexArrowType
    Simple -> 0
    Strict -> 1
    Locked -> 2

isSimpleArrow(node) := isArrow(node) and indexArrowType(getArrowType(node)) = 0
isCase(node) := isArrow(node) and indexArrowType(getArrowType(node)) =/= 2

Name(tag) := Reference(tag, 0, 0, NOFIX)
isName(node) := isReference(node) and getReferenceIndex(node) = 0
OperatorName(tag, fixity) := Reference(tag, 0, 0, fixity)
Juxtaposition(tag, left, right) := Couple(tag, JuxtapositionCouple, left, right)
Let(tag, left, right) := Couple(tag, LetCouple, left, right)
SimpleArrow(tag) := Arrow(tag, Simple, [])
StrictArrow(tag) := Arrow(tag, Strict)
LockedArrow(tag) := Arrow(tag, Locked, [])

define indexDefinitionType
    PlainDefinition -> 0
    MaybeDefinition -> 1
    TryDefinition -> 2
    SyntaxDefinition -> 3
    ADTDefinition -> 4

isSyntaxDefinition(node) :=
    isDefinition(node) and indexDefinitionType(getDefinitionType(node)) = 3
getLexeme(node) := getTagLexeme(getTag(node))
showLexeme(node) := showTag(getTag(node))
isThisName(node, lexeme) := isName(node) and getLexeme(node) =*= lexeme
isThisOperator(node, lexeme) := isOperator(node) and getLexeme(node) =*= lexeme
isEOF(node) := isThisOperator(node, "\0")
isUnderscore(tag) := getTagLexeme(tag) =*= "_"
isUnused(tag) := getTagLexeme(tag).startsWith("_")
isKeyphrase(node, lexeme) :=
    isJuxtaposition(node) and isThisName(getLeft(node), lexeme)
UnderscoreArrow(tag, body) :=
    LockedArrow(tag, Name(renameTag(tag, "_")), body)
newUnderscore(tag, debruijn) :=
    Reference(renameTag(tag, "_"), debruijn, 0, NOFIX)
newNil(tag) := Name(renameTag(tag, "[]"))
prependList(tag, item, list) := Juxtaposition(tag,
    Juxtaposition(tag, OperatorName(renameTag(tag, "::"), INFIX), item), list)
newLeftPlaceholder(tag) :=
    Section(tag, RightSection, Name(renameTag(tag, ".*")))
newRightPlaceholder(tag) :=
    Section(tag, LeftSection, Name(renameTag(tag, "*.")))
isLeftPlaceholder(node) :=
    isSection(node) and isThisName(getSectionBody(node), ".*")
wrapLeftSection(tag, body) :=
    LockedArrow(tag, Name(renameTag(tag, "*.")), body)
wrapRightSection(tag, body) :=
    LockedArrow(tag, Name(renameTag(tag, ".*")), body)

define wrapSection(tag, section)
    body := getSectionBody(section)
    match getSide(section)
        case LeftSection
            wrapLeftSection(tag, body)
        case RightSection
            if isName(getLeft(body))
                getLeft(body)       # parenthesized postfix operator
            wrapRightSection(tag, body)
        case LeftRightSection
            wrapLeftSection(tag, wrapRightSection(tag, body))

#*
