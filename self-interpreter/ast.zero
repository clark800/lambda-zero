#* ast.zero

DefinitionType ::= {PlainDefinition, MaybeDefinition, TryDefinition,
    SyntaxDefinition, ADTDefinition}
ArrowType ::= {Simple, Strict, Locked, DoubleArrow}
SectionSide ::= {LeftSection, RightSection, LeftRightSection}

StateT(ast, syntax) ::= {State(
    getStack : List(ast),
    getOperators : List(TableT(List(ℕ), syntax))
)}

SyntaxT(ast) ::= {Syntax(
    getAlias : List(ℕ),
    getLeftPrecedence : ℕ,
    getRightPrecedence : ℕ,
    getFixity : ℕ,
    getAssociativity : ℕ,
    getSpecial : 𝔹,
    getShift : (StateT(ast, SyntaxT(ast)) => ast => StateT(ast, SyntaxT(ast))),
    getReduce : (ast => ast => ast => ast),
    getPrior : List(ℕ)
)}

AST ::= {
    Reference(_ : Tag, _debruijn : ℕ),
    Arrow(_ : Tag, _type : ArrowType, _constructors : List(AST),
        _parameter : AST, _body : AST),
    Juxtaposition(_ : Tag, _left : AST, _right : AST),
    Let(_ : Tag, _name : AST, _value : AST, _scope : AST),
    Number(_ : Tag, _value : ℕ),
    Operator(_ : Tag, _rank : ℕ, _syntax : SyntaxT(AST)),
    Definition(_ : Tag, _type : DefinitionType,
        _definiendum : AST, _definiens : AST),
    AsPattern(_ : Tag, _left : AST, _pattern : AST),
    CommaPair(_ : Tag, _left : AST, _right : AST),
    Section(_ :  Tag, _side : SectionSide, _body : AST),
    SetBuilder(_ : Tag, _forms : List(AST)),
    ADT(_ : Tag, _forms : List(AST)),
    Constructor(_ : Tag, _parameterTypes : List(AST), _dataType : AST,
        _function : AST, _count : ℕ, _index : ℕ),
    Deconstructor(_ : Tag, _parameterTypes : List(AST), _dataType : AST,
        _function : AST, _count : ℕ, _index : ℕ),
    Accessor(_ : Tag, _dataType : AST, _returnType : AST,
        _function : AST, _count : ℕ, _index : ℕ),
    Null(_ : Tag)
}

define lockArrow(node)
    with node as Arrow(tag, arrowType, constructors, left, right)
        with arrowType as Simple
            Arrow(tag, Locked, constructors, left, right)
        with arrowType as Strict
            Arrow(tag, Locked, constructors, left, right)
        node
    node

define getTag
    Reference(tag, _) -> tag
    Arrow(tag, _, _, _, _) -> tag
    Juxtaposition(tag, _, _) -> tag
    Let(tag, _, _, _) -> tag
    Number(tag, _) -> tag
    Operator(tag, _, _) -> tag
    Definition(tag, _, _, _) -> tag
    AsPattern(tag, _, _) -> tag
    CommaPair(tag, _, _) -> tag
    Section(tag, _, _) -> tag
    SetBuilder(tag, _) -> tag
    ADT(tag, _) -> tag
    Constructor(tag, _, _, _, _, _) -> tag
    Deconstructor(tag, _, _, _, _, _) -> tag
    Accessor(tag, _, _, _, _, _) -> tag
    Null(tag) -> tag

define containsName(name)
    Reference(tag, _) -> getTagLexeme(tag) =*= getTagLexeme(getTag(name))
    Arrow(_, _, _, _, body) -> containsName(name, body)
    Juxtaposition(_, left, right) ->
        containsName(name, left) or containsName(name, right)
    Let(_, _, value, scope) ->
        containsName(name, value) or containsName(name, scope)
    Number(_, _) -> False
    Operator(_, _, _) -> False
    Definition(_, _, _, _) -> False
    AsPattern(_, _, _) -> False
    CommaPair(_, _, _) -> False
    Section(_, _, _) -> False
    SetBuilder(_, _) -> False
    ADT(_, _) -> False
    Constructor(_, _, _, _, _, _) -> False
    Deconstructor(_, _, _, _, _, _) -> False
    Accessor(_, _, _, _, _, _) -> False
    Null(_) -> False

define showAST
    Reference(tag, _) -> showTag(tag)
    Arrow(tag, _, _, parameter, body) ->
        "(" ++ showTag(getTag(parameter)) ++ " -> " ++ showAST(body) ++ ")"
    Juxtaposition(tag, left, right) ->
        "(" ++ showAST(left) ++ " " ++ showAST(right) ++ ")"
    Let(tag, name, value, scope) ->
        "(" ++ showAST(name) ++ " := " ++ showAST(value) ++
            ";;" ++ showAST(scope) ++ ")"
    Number(tag, value) -> showNatural(value)
    Operator(tag, rank, rules) -> showTag(tag)
    Definition(tag, _, left, right) ->
        "(" ++ showAST(left) ++ " := " ++ showAST(right) ++ ")"
    AsPattern(tag, name, pattern) ->
        "(" ++ showAST(name) ++ ")@(" ++ showAST(pattern) ++ ")"
    CommaPair(tag, left, right) ->
        "(" ++ showAST(left) ++ ", " ++ showAST(right) ++ ")"
    Section(_, _, body) -> showAST(body)
    SetBuilder(_, forms) -> "{" ++ forms.map(showAST).joinWith(", ") ++ "}"
    ADT(_, forms) -> "{" ++ forms.map(showAST).joinWith(", ") ++ "}"
    Constructor(_, _, _, body, _, _) -> showAST(body)
    Deconstructor(_, _, _, body, _, _) -> showAST(body)
    Accessor(_, _, _, body, _, _) -> showAST(body)
    Null(_) -> "#NULL#"

isReference := Reference(_, _) -> True; _ -> False
isArrow := Arrow(_, _, _, _, _) -> True; _ -> False
isJuxtaposition := Juxtaposition(_, _, _) -> True; _ -> False
isLet := Let(_, _, _, _) -> True; _ -> False
isNumber := Number(_, _) -> True; _ -> False
isOperator := Operator(_, _, _) -> True; _ -> False
isDefinition := Definition(_, _, _, _) -> True; _ -> False
isAsPattern := AsPattern(_, _, _) -> True; _ -> False
isCommaPair := CommaPair(_, _, _) -> True; _ -> False
isSection := Section(_, _, _) -> True; _ -> False
isSetBuilder := SetBuilder(_, _) -> True; _ -> False
isADT := ADT(_, _) -> True; _ -> False
isConstructor := Constructor(_, _, _, _, _, _) -> True; _ -> False
isDeconstructor := Deconstructor(_, _, _, _, _, _) -> True; _ -> False
isAccessor := Accessor(_, _, _, _, _, _) -> True; _ -> False
isNull := Null(_) -> True; _ -> False

isCase(node) := with node as Arrow(_, type, _, _, _);
    (type |> Locked -> False; _ -> True) <| False

Name(tag) := Reference(tag, 0)
isName(node) := with node as Reference(_, debruijn); debruijn = 0 <| False
SimpleArrow(parameter, body) :=
    Arrow(getTag(parameter), Simple, [], parameter, body)
StrictArrow(tag, constructors, body) :=
    Arrow(tag, Strict, constructors, Name(veil(tag)), body)
LockedArrow(parameter, body) :=
    Arrow(getTag(parameter), Locked, [], parameter, body)

isSyntaxDefinition(node) := with node as Definition(_, type, _, _);
    (with type as SyntaxDefinition; True <| False) <| False
getLexeme(node) := getTagLexeme(getTag(node))
showLexeme(node) := showTag(getTag(node))
isThisName(node, lexeme) := isName(node) and getLexeme(node) =*= lexeme
isThisOperator(node, lexeme) := isOperator(node) and getLexeme(node) =*= lexeme
isEOF(node) := isThisOperator(node, "\0")
isUnderscore(tag) := getTagLexeme(tag) =*= "_"
isUnused(tag) := getTagLexeme(tag).startsWith("_")
UnderscoreArrow(tag, body) := LockedArrow(Name(veil(tag)), body)
Underscore(tag, debruijn) := Reference(veil(tag), debruijn)
newNil(tag) := Name(renameTag(tag, "[]", NOFIX))
prependList(tag, item, list) := Juxtaposition(tag,
    Juxtaposition(tag, Name(renameTag(tag, "::", INFIX)), item), list)
newLeftPlaceholder(tag) :=
    Section(tag, RightSection, Name(renameTag(tag, ".*", NOFIX)))
newRightPlaceholder(tag) :=
    Section(tag, LeftSection, Name(renameTag(tag, "*.", NOFIX)))
isLeftPlaceholder(node) := with node as Section(_, _, body);
    isThisName(body, ".*") <| False
wrapLeftSection(tag, body) :=
    LockedArrow(Name(renameTag(tag, "*.", NOFIX)), body)
wrapRightSection(tag, body) :=
    LockedArrow(Name(renameTag(tag, ".*", NOFIX)), body)

define wrapSection(tag, section)
    with section as Section(_, side, body)
        match side
            case LeftSection
                wrapLeftSection(tag, body)
            case RightSection
                with body as Juxtaposition(_, left, _)
                    if isName(left)
                        left       # parenthesized postfix operator
                    wrapRightSection(tag, body)
                wrapRightSection(tag, body)
            case LeftRightSection
                wrapLeftSection(tag, wrapRightSection(tag, body))
    section

#*
