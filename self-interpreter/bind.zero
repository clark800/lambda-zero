#* bind.zero

define findParameter(level, stack, lexeme)
    with stack as table :: _
        table.lookup(lexeme).mapJust(mapFirst(level --))
    Void


define findDefiniens(stack, lexeme)
    with stack as table :: _
        table.lookup(lexeme).mapJust(second) ?? Void
    Void


define pushParameter(parameter, level, maybeNode, stack)
    lexeme := getLexeme(parameter)
    with stack as top :: stack'
        top.insert(lexeme, (level, maybeNode)) :: stack'
    [newDictionary([(lexeme, (level, maybeNode))])]


define maybeAscription(node)
    with node as Abstraction(_, constraint, _)
        with constraint as Ascription(type)
            Just(type)
        Void
    with node as Numeral(_, type, _)
        Just(type)
    with node as Operation(_, type, _, _)
        Just(type)
    Void


define findType(lexeme, context)
    with context.lookup(lexeme) as Just(((_, term), _))
        maybeAscription(term)
    Void


define getNaturalType(context)
    context.findType("0") ?? Variable(renameTag(noTag, "#NATURAL#", NOFIX), 0)


define getBooleanType(context)
    context.findType("False") ??
        Variable(renameTag(noTag, "#BOOLEAN#", NOFIX), 0)


define getStringType(context, tag)
    natural := getNaturalType(context)
    listType := context.findType("[]") ??
        parseError("List not defined", tag)
    with listType as Implicit(_, _, type)
        with type as Application(_, left, _)
            Application(noTag, left, natural)
        parseError("List type invalid", tag)
    parseError("List type invalid", tag)


define getOperationType(context, tag)
    tag' := veil(tag)
    lexeme := getTagLexeme(tag)
    syntax(>->) := syntax(++)
    (>->) := Implication(noTag)
    if ["+", "--", "*", "//", "%"].any(=*= lexeme)
        natural := getNaturalType(context)
        Just(natural >-> natural >-> natural)
    if ["=", "=/=", "<", ">", "<=", ">="].any(=*= lexeme)
        natural := getNaturalType(context)
        boolean := getBooleanType(context)
        Just(natural >-> natural >-> boolean)
    if lexeme =*= "(increment)"
        natural := getNaturalType(context)
        Just(natural >-> natural)
    if lexeme =*= "(undefined)"
        Just(Implicit(tag', Top(tag'), Variable(tag', 1)))
    if lexeme =*= "abort"
        string := getStringType(context, tag)
        Just(Implicit(tag', Top(tag'), string >-> Variable(tag', 2)))
    Void


define bindOperation(context, tag)
    maybe (arity, optimize) := getBuiltin(tag)
    maybe type := getOperationType(context, tag)
    Just(Operation(tag, type, arity, optimize))


define bindVariable(level, stack, tag)
    lexeme := getTagLexeme(tag)
    maybe (debruijn, maybeValue) := findParameter(level, stack, lexeme)
    Just(Variable(tag, debruijn))


define bindContextTerm(context, tag)
    context.lookup(getTagLexeme(tag)).mapJust(second)


define bindName(level, stack, context, tag)
    if isUnused(tag)
        parseError("cannot reference a symbol starting with underscore", tag)
    bindVariable(level, stack, tag) ??
        bindContextTerm(context, tag) ??
        bindOperation(context, tag) ??
        parseError("undefined symbol", tag)


define newReconstructorAST'(parameterTypeASTs, returnTypeAST)
    with parameterTypeASTs as parameterTypeAST :: parameterTypeASTs'
        bodyTypeAST := newReconstructorAST'(parameterTypeASTs', returnTypeAST)
        DoubleArrow(parameterTypeAST, bodyTypeAST)
    returnTypeAST


define newReconstructorAST(parameterTypeASTs, returnTypeAST)
    typeAST := newReconstructorAST'(parameterTypeASTs, returnTypeAST)
    parameters := getArguments(returnTypeAST)
    parameters.fold(ImplicitArrow, typeAST)


define newDeconstructorAST(tag, parameterTypeASTs, adtTypeAST)
    # todo: change name from "r" so it can't clash with user's names
    returnType := Name(renameTag(tag, "r", NOFIX))
    reconstructorType := newReconstructorAST'(parameterTypeASTs, returnType)
    syntax(>->) := syntax(++)
    (>->) := DoubleArrow
    fallbackType := adtTypeAST >-> returnType
    typeAST := reconstructorType >-> fallbackType >-> adtTypeAST >-> returnType
    parameters := getArguments(adtTypeAST)
    ImplicitArrow(returnType, parameters.fold(ImplicitArrow, typeAST))


define getADTName(constructor)
    with constructor as Constructor(_, _, adtType, _, _, _)
        getLexeme(getHead(adtType))
    syntaxError("invalid constructor", constructor)


define getConstructionTypeAST(constructor)
    with constructor as Constructor(_, parameterTypes, adtType, _, _, _)
        getArguments(adtType).fold(ImplicitArrow, adtType)
    syntaxError("invalid constructor", constructor)


define getParameterTypeASTs(constructor)
    with constructor as Constructor(_, parameterTypes, adtType, _, _, _)
        parameterTypes
    syntaxError("invalid constructor", constructor)


define getImplicitNames(constructor)
    with constructor as Constructor(_, parameterTypes, adtType, _, _, _)
        getArguments(adtType)
    syntaxError("invalid constructor", constructor)


define constructObjectTypeAST(tag, constructors)
    returnTypeAST := Name(renameTag(tag, "r", NOFIX))
    reconstructors := constructors.map(getParameterTypeASTs).map(
        `newReconstructorAST'(returnTypeAST))
    type := ImplicitArrow(returnTypeAST,
        reconstructors.fold(DoubleArrow, returnTypeAST))
    constructor := safeHead(constructors) ?? throwError("no constructors", tag)
    getImplicitNames(constructor).fold(ImplicitArrow, type)


define maybeCount(node)
    with node as Constructor(_, _, _, _, count, _)
        Just(count)
    Void


define maybeConstructorIndex(node)
    with node as Constructor(_, _, _, _, _, index)
        Just(index)
    Void


define constructCaseAnnotation(tag, constructors)
    if isNil(constructors)
        throwError("Type error: no cases:", tag)
    if not constructors.all(isConstructor)
        throwError("Type error: invalid cases:", tag)
    adtNames := deduplicateBy((=*=), constructors.map(getADTName))
    counts := deduplicate(constructors.map(maybeCount).prune)
    if length(adtNames) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? throwError("Type error: invalid cases", tag)
    indices := deduplicate(constructors.map(maybeConstructorIndex).prune)
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)

    constructor := safeHead(constructors) ??
        throwError("Type error: invalid cases", tag)
    constructionTypeAST := getConstructionTypeAST(constructor)
    objectTypeAST := constructObjectTypeAST(veil(tag), constructors)
    # note: the implicits in the two types must be instantiated together
    (constructionTypeAST, objectTypeAST)


define buildCaseAnnotation(tag, constructorNames, context)
    with constructorNames.map(getLexeme).map(`lookup(context)).sequence as
            Just(constructorPairs)
        constructors := constructorPairs.map(first).map(first)
        Just(constructCaseAnnotation(tag, constructors))
    Void


define bind(level, stack, context, node)
    match node
        case Reference(tag, debruijn)
            if debruijn = 0
                bindName(level, stack, context, tag)
            Variable(tag, debruijn)
        case Arrow(tag, arrowType, constructorNames, parameter, body)
            with arrowType as Double
                parameterTerm := parameter.bind(level, stack, context)
                # todo: add support for names on left side of double arrows
                stack' := stack.pushParameter(Name(veil(tag)), level, Void)
                bodyTerm := body.bind(up level, stack', context)
                Implication(tag, parameterTerm, bodyTerm)
            stack' := stack.pushParameter(parameter, level, Void)
            bodyTerm := body.bind(up level, stack', context)
            with arrowType as Squiggle
                Implicit(tag, Top(tag), bodyTerm)
            if isNil(constructorNames)
                Abstraction(getTag(parameter), NoConstraint, bodyTerm)
            with buildCaseAnnotation(tag, constructorNames, context) as
                    Just((outerTypeAST, innerTypeAST))
                outerType := outerTypeAST.bind(level, stack, context)
                innerType := innerTypeAST.bind(level, stack, context)
                annotation := PolarAnnotation(outerType, innerType)
                Abstraction(getTag(parameter), annotation, bodyTerm)
            syntaxError("invalid constructors", node)
        case Juxtaposition(tag, left, right)
            Application(tag, left.bind(level, stack, context),
                right.bind(level, stack, context))
        case Let(tag, name, value, scope)
            valueTerm := value.bind(level, stack, context)
            stack' := stack.pushParameter(name, level, Just((value, valueTerm)))
            scopeTerm := scope.bind(up level, stack', context)
            abstraction := Abstraction(getTag(name), NoConstraint, scopeTerm)
            Application(tag, abstraction, valueTerm)
        case Number(tag, value)
            Numeral(tag, getNaturalType(context), value)
        case Operator(_, _, _)
            abort "internal error: Operator reached bind"
        case Definition(_, _, _, _)
            syntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            syntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            syntaxError("comma not inside brackets", node)
        case Section(_, _, _)
            syntaxError("invalid section", node)
        case SetBuilder(_, _)
            syntaxError("must appear on the right side of '::='", node)
        case Constructor(tag, parameterTypes, adtType, function, count, index)
            typeAST := newReconstructorAST(parameterTypes, adtType)
            type := typeAST.bind(level, stack, context)
            with function as Number(_, value)
                Numeral(tag, type, value)
            function.bind(level, stack, context).setAscription(type)
        case Deconstructor(tag, parameterTypes, adtType, function, count, index)
            typeAST := newDeconstructorAST(tag, parameterTypes, adtType)
            type := typeAST.bind(level, stack, context)
            function.bind(level, stack, context).setAscription(type)
        case Accessor(tag, adtType, returnType, function, count, index)
            arrowAST := DoubleArrow(adtType, returnType)
            parameters := getArguments(adtType)
            typeAST := parameters.fold(ImplicitArrow, arrowAST)
            type := typeAST.bind(level, stack, context)
            function.bind(level, stack, context).setAscription(type)
        case Null(_)
            abort "internal error: Null reached bind"


define bindGlobal(context, node)
    stack := [newDictionary([])]
    bind(0, stack, context, node)


define bindDefinition(state, (tag, isTypeConstructor, node))
    (tags, context, environment) := state
    term := bindGlobal(context, node)
    (index, environment') := environment.append(Closure(term, environment))
    constant := Constant(tag, isTypeConstructor, index)
    context' := context.insert(getTagLexeme(tag), ((node, term), constant))
    (tag :: tags, context', environment')


define getDefinitions(node)
    with node as Let(tag, name, value, scope)
        # TODO: set isTypeConstructor
        (getTag(name), False, value) :: getDefinitions(scope)
    [(veil(getTag(node)), False, node)]


define bindAST(node)
    # TODO: make state a parameter so we can bind with an existing state
    state := ([], newDictionary([]), newArray([]))
    state' := getDefinitions(node).cascade(bindDefinition, state)
    (tags, context, environment) := state'
    (reverse(tags), context, environment)

#*
