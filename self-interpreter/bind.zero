#* bind.zero

define findParameter(level, stack, lexeme)
    with stack as table :: _
        table.lookup(lexeme).mapJust(mapFirst(level --))
    Void


define findDefiniens(stack, lexeme)
    with stack as table :: _
        table.lookup(lexeme).mapJust(second) ?? Void
    Void


define pushParameter(parameter, level, maybeNode, stack)
    lexeme := getLexeme(parameter)
    with stack as top :: stack'
        top.insert(lexeme, (level, maybeNode)) :: stack'
    [newDictionary([(lexeme, (level, maybeNode))])]


define findType(lexeme, context)
    with context.lookup(lexeme) as Just(((_, term), _))
        maybeAscription(term)
    Void


define getNaturalType(context)
    context.findType("0") ?? Variable(renameTag(noTag, "#NATURAL#", NOFIX), 0)


define getBooleanType(context)
    context.findType("False") ??
        Variable(renameTag(noTag, "#BOOLEAN#", NOFIX), 0)


define getStringType(context, tag)
    natural := getNaturalType(context)
    listType := context.findType("[]") ??
        parseError("List not defined", tag)
    with listType as Implicit(_, _, type)
        with type as Application(_, left, _)
            Application(noTag, left, natural)
        parseError("List type invalid", tag)
    parseError("List type invalid", tag)


define getOperationType(context, tag)
    tag' := veil(tag)
    lexeme := getTagLexeme(tag)
    syntax(>->) := syntax(++)
    (>->) := Implication(noTag)
    if ["+", "--", "*", "//", "%"].any(=*= lexeme)
        natural := getNaturalType(context)
        Just(natural >-> natural >-> natural)
    if ["=", "=/=", "<", ">", "<=", ">="].any(=*= lexeme)
        natural := getNaturalType(context)
        boolean := getBooleanType(context)
        Just(natural >-> natural >-> boolean)
    if lexeme =*= "(increment)"
        natural := getNaturalType(context)
        Just(natural >-> natural)
    if lexeme =*= "(undefined)"
        Just(Implicit(tag', Top(tag'), Variable(tag', 1)))
    if lexeme =*= "abort"
        string := getStringType(context, tag)
        Just(Implicit(tag', Top(tag'), string >-> Variable(tag', 2)))
    Void


define bindOperation(context, tag)
    maybe (arity, optimize) := getBuiltin(tag)
    maybe type := getOperationType(context, tag)
    Just(Operation(tag, type, arity, optimize))


define bindVariable(level, stack, tag)
    lexeme := getTagLexeme(tag)
    maybe (debruijn, maybeValue) := findParameter(level, stack, lexeme)
    Just(Variable(tag, debruijn))


define bindContextTerm(context, tag)
    context.lookup(getTagLexeme(tag)).mapJust(second)


define bindName(level, stack, context, tag)
    if isUnused(tag)
        parseError("cannot reference a symbol starting with underscore", tag)
    bindVariable(level, stack, tag) ??
        bindContextTerm(context, tag) ??
        bindOperation(context, tag) ??
        parseError("undefined symbol", tag)


define getADTName(constructor)
    with constructor as Constructor(_, _, adtType, _, _, _)
        getLexeme(getHead(adtType))
    syntaxError("invalid constructor", constructor)


define getConstructionTypeAST(constructor)
    with constructor as Constructor(_, parameterTypes, adtType, _, _, _)
        getArguments(adtType).fold(ImplicitArrow, adtType)
    syntaxError("invalid constructor", constructor)


define constructCaseAnnotation(tag, constructors)
    if isNil(constructors)
        throwError("Type error: no cases:", tag)
    if not constructors.all(isConstructor)
        throwError("Type error: invalid cases:", tag)
    adtNames := deduplicateBy((=*=), constructors.map(getADTName))
    counts := deduplicate(constructors.map(maybeCount).prune)
    if length(adtNames) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? throwError("Type error: invalid cases", tag)
    indices := deduplicate(constructors.map(maybeConstructorIndex).prune)
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)

    constructor := safeHead(constructors) ??
        throwError("Type error: invalid cases", tag)
    getConstructionTypeAST(constructor)


define buildCaseAnnotation(tag, constructorNames, context)
    with constructorNames.map(getLexeme).map(`lookup(context)).sequence as
            Just(constructorPairs)
        constructors := constructorPairs.map(first).map(first)
        Just(constructCaseAnnotation(tag, constructors))
    Void


define bind(level, stack, context, node)
    match node
        case Reference(tag, debruijn)
            if debruijn = 0
                bindName(level, stack, context, tag)
            Variable(tag, debruijn)
        case Arrow(tag, arrowType, constructorNames, parameter, body)
            with arrowType as Double
                parameterTerm := parameter.bind(level, stack, context)
                # todo: add support for names on left side of double arrows
                stack' := stack.pushParameter(Name(veil(tag)), level, Void)
                bodyTerm := body.bind(up level, stack', context)
                Implication(tag, parameterTerm, bodyTerm)
            stack' := stack.pushParameter(parameter, level, Void)
            bodyTerm := body.bind(up level, stack', context)
            with arrowType as Squiggle
                Implicit(tag, Top(tag), bodyTerm)
            if isNil(constructorNames)
                FreeAbstraction(getTag(parameter), bodyTerm)
            with buildCaseAnnotation(tag, constructorNames, context) as
                    Just(typeAST)
                type := typeAST.bind(level, stack, context)
                annotation := CaseAnnotation(type)
                Abstraction(getTag(parameter), annotation, bodyTerm)
            syntaxError("invalid constructors", node)
        case Juxtaposition(tag, left, right)
            Application(tag, left.bind(level, stack, context),
                right.bind(level, stack, context))
        case Let(tag, isTypeConstructor, name, value, scope)
            if isTypeConstructor
                syntaxError("type constructors must be at the top level", node)
            valueTerm := value.bind(level, stack, context)
            stack' := stack.pushParameter(name, level, Just((value, valueTerm)))
            scopeTerm := scope.bind(up level, stack', context)
            abstraction := FreeAbstraction(getTag(name), scopeTerm)
            Application(tag, abstraction, valueTerm)
        case Number(tag, value)
            Numeral(tag, getNaturalType(context), value)
        case Operator(_, _, _)
            abort "internal error: Operator reached bind"
        case Definition(_, _, _, _)
            syntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            syntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            syntaxError("comma not inside brackets", node)
        case Section(_, _, _)
            syntaxError("invalid section", node)
        case SetBuilder(_, _)
            syntaxError("must appear on the right side of '::='", node)
        case ADT(tag, parameters, objectType)
            Construction(tag, parameters.map(bind(level, stack, context)),
                objectType.bind(level, stack, context))
        case Constructor(tag, parameterTypes, adtType, function, count, index)
            typeAST := newReconstructorAST(parameterTypes, adtType)
            type := typeAST.bind(level, stack, context)
            with function as Number(_, value)
                Numeral(tag, type, value)
            function.bind(level, stack, context).setAscription(type)
        case TypedNode(tag, type, node)
            node.bind(level, stack, context).setAscription(
                type.bind(level, stack, context))
        case Null(_)
            abort "internal error: Null reached bind"


define bindGlobal(context, node)
    stack := [newDictionary([])]
    bind(0, stack, context, node)


define bindDefinition(state, (tag, node))
    (tags, context, environment) := state
    term := bindGlobal(context, node)
    (index, environment') := environment.append(Closure(term, environment))
    constant := Constant(tag, index)
    context' := context.insert(getTagLexeme(tag), ((node, term), constant))
    (tag :: tags, context', environment')


define getDefinitions(node)
    with node as Let(tag, isTypeConstructor, name, value, scope)
        (getTag(name), value) :: getDefinitions(scope)
    [(veil(getTag(node)), node)]


define bindAST(node)
    # TODO: make state a parameter so we can bind with an existing state
    state := ([], newDictionary([]), newArray([]))
    state' := getDefinitions(node).cascade(bindDefinition, state)
    (tags, context, environment) := state'
    (reverse(tags), context, environment)

#*
