#* bind.zero

define findDebruijnIndex(level, stack, lexeme)
    with stack as table :: _
        table.lookup(lexeme).mapJust(level --)
    Void


define pushParameter(lexeme, level, stack)
    with stack as top :: stack'
        top.set(lexeme, level) :: stack'
    [newDictionary([(lexeme, level)])]


define bindOperation(tag)
    maybe (arity, optimize) := getBuiltin(tag)
    Just(Operation(tag, arity, optimize))


define bindName(level, stack, tag)
    if isUnused(tag)
        parseError("cannot reference a symbol starting with underscore", tag)
    findDebruijnIndex(level, stack, getTagLexeme(tag)).mapJust(Variable(tag)) ??
        bindOperation(tag) ?? parseError("undefined symbol", tag)


define parseParameterType(node, context)
    if isName(node)
        tag := getTag(node)
        context.lookup(getLexeme(node)) ?? Construction(tag, [], 0, 0)
    root := getHead(node)
    name := getLexeme(root)
    if context.hasKey(name)
        syntaxError("type variable not allowed in applicand position", node)
    parameterTypes := getArguments(node).map(`parseParameterType(context))
    if name =*= "=>"
        if length(parameterTypes) =/= 2
            syntaxError("(=>) requires two arguments", node)
        with parameterTypes as left :: parameterTypes'
            with parameterTypes' as right :: _
                Implication(getTypeTag(left), left, right)
            syntaxError("(=>) requires two arguments", node)
        syntaxError("(=>) requires two arguments", node)
    Construction(getTag(root), parameterTypes, 0, 0)


define parseConstruction(node, count, index)
    # context maps type variable names to type variables
    # type variable with index 0 is reserved for deconstructors
    root := getHead(node)
    components := getArguments(node)
    if not components.all(isName)
        syntaxError("all components should be names", node)
    tag := veil(getTag(node))
    parameterTypes := (1 .. length(components)).map(MetaVariable(tag))
    context := newDictionary(zip(components.map(getLexeme), parameterTypes))
    type := Construction(getTag(root), parameterTypes, count, index)
    (type, context)


define newReconstructorType(context, parameterTypeASTs, returnType)
    with parameterTypeASTs as typeAST :: parameterTypeASTs'
        parameterType := parseParameterType(typeAST, context)
        bodyType := newReconstructorType(context,
            parameterTypeASTs', returnType)
        Implication(getTypeTag(parameterType), parameterType, bodyType)
    returnType


define newConstructorScheme(tag, parameterTypeASTs, adtTypeAST, count, index)
    # todo: check that universals are not already defined and that all other
    # names are already defined; also make sure universal name is not the
    # same as the dataType name
    (adtType, context) := parseConstruction(adtTypeAST, count, index)
    universals := getValues(context)
    type := newReconstructorType(context, parameterTypeASTs, adtType)
    Scheme(universals, type)


define newDeconstructorScheme(tag, parameterTypeASTs, adtTypeAST, count, index)
    returnType := MetaVariable(veil(tag), 0)
    (adtType, context) := parseConstruction(adtTypeAST, count, index)
    universals := returnType :: getValues(context)
    reconstructorType :=
        newReconstructorType(context, parameterTypeASTs, returnType)
    syntax(>->) := syntax(++)
    (>->) := Implication(veil(tag))
    fallbackType := adtType >-> returnType
    type := reconstructorType >-> fallbackType >-> adtType >-> returnType
    Scheme(universals, type)


define newAccessorScheme(tag, dataType, returnType, count, index)
    (adtType, context) := parseConstruction(dataType, count, index)
    type := Implication(tag, adtType, parseParameterType(returnType, context))
    universals := getValues(context)
    Scheme(universals, type)


define bind(level, stack, node)
    match node
        case Reference(tag, debruijn)
            if debruijn = 0
                bindName(level, stack, tag)
            Variable(tag, debruijn)
        case Arrow(tag, _, constructors, parameter, body)
            constructors' := constructors.map(bind(level, stack))
            indices := constructors'.map(maybeDebruijnIndex).prune
            metadata := Metadata(Void, Void, indices)
            stack' := stack.pushParameter(getLexeme(parameter), level)
            body' := bind(up level, stack', body)
            Abstraction(getTag(parameter), metadata, body')
        case Juxtaposition(tag, left, right)
            Application(tag, False,
                bind(level, stack, left), bind(level, stack, right))
        case Let(tag, left, right)
            Application(tag, True,
                bind(level, stack, left), bind(level, stack, right))
        case Number(tag, value)
            Numeral(veil(tag), value)
        case Operator(_, _, _)
            abort "internal error: Operator reached bind"
        case Definition(_, _, _, _)
            syntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            syntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            syntaxError("comma not inside brackets", node)
        case Section(_, _, _)
            syntaxError("invalid section", node)
        case SetBuilder(_, _)
            syntaxError("must appear on the right side of '::='", node)
        case Constructor(tag, parameterTypes, adtType, function, count, index)
            term := bind(level, stack, function)
            scheme := newConstructorScheme(tag, parameterTypes,
                adtType, count, index)
            term.setMetadata(Metadata(Void, Just(scheme), []))
        case Deconstructor(tag, parameterTypes, adtType, function, count, index)
            term := bind(level, stack, function)
            scheme := newDeconstructorScheme(tag, parameterTypes,
                adtType, count, index)
            term.setMetadata(Metadata(Void, Just(scheme), []))
        case Accessor(tag, adtType, returnType, function, count, index)
            term := bind(level, stack, function)
            scheme := newAccessorScheme(tag, adtType, returnType, count, index)
            term.setMetadata(Metadata(Void, Just(scheme), []))
        case Null(_)
            abort "internal error: Null reached bind"


define bindAST(node)
    stack := [newDictionary([])]
    bind(0, stack, node)

#*
