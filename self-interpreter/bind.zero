#* bind.zero

define findDebruijnIndex(stack, tag, depth)
    stack.findIndices(=*= getTagLexeme(tag)).safeIndex(depth).mapRight(1 +)


define bindOperation(tag)
    try (arity, optimize) := getBuiltin(tag)
    just Operation(tag, arity, optimize)


define bindName(stack, tag, depth)
    if isUnused(tag)
        parseError("cannot reference a symbol starting with underscore", tag)
    stack.findDebruijnIndex(tag, depth).mapRight(Variable(tag)) ?
        bindOperation(tag) ? parseError("undefined symbol", tag)


define parseParameterType(node, context)
    # TODO: count parameter to ADTs is wrong
    if isName(node)
        name := getLexeme(node)
        context.lookup(name) ? ADT(noTerm, name, [], 0, 0)
    name := getLexeme(getHead(node))
    if context.hasKey(name)
        syntaxError("type variable not allowed in applicand position", node)
    parameterTypes := getArguments(node).map(`parseParameterType(context))
    ADT(noTerm, name, parameterTypes, 0, 0)


define parseADT(node, context, count, index)
    name := getLexeme(getHead(node))
    parameterTypes := getArguments(node).map(context.get <> getLexeme)
    ADT(noTerm, name, parameterTypes, count, index)


define buildContext(dataType)
    # context maps type variable names to type variables
    components := getArguments(dataType)
    if not components.all(isName)
        syntaxError("all components should be names", dataType)
    typeVariables := (0 .. length(components)).map(TypeVariable(noTerm))
    newTable((<*=), zip(components.map(getLexeme), typeVariables))


define newConstructorType(term, parameterTypes, dataType, context, count, index)
    # todo: check that universals are not already defined and that all other
    # names are already defined; also make sure universal name is not the
    # same as the dataType name
    if isNil(parameterTypes)
        parseADT(dataType, context, count, index)
    parameterType := parseParameterType(head(parameterTypes), context)
    FunctionType(term, parameterType, newConstructorType(getBody(term),
        tail(parameterTypes), dataType, context, count, index))


define newConstructorScheme(term, parameterTypes, dataType, count, index)
    context := buildContext(dataType)
    universals := getValues(context)
    type := newConstructorType(term, parameterTypes,
        dataType, context, count, index)
    Scheme(universals, type)


define newAccessorScheme(term, dataType, returnType, count, index)
    context := buildContext(dataType)
    universals := getValues(context)
    type := FunctionType(term, parseADT(dataType, context, count, index),
        parseParameterType(returnType, context))
    Scheme(universals, type)


define bind(node, stack)
    match node
        case Name(tag, depth)
            stack.bindName(tag, depth)
        case Arrow(tag, parameter, body)
            Abstraction(getTag(parameter), Metadata(Free, Free, []),
                bind(body, getLexeme(parameter) :: stack))
        case Couple(tag, _, left, right)
            Application(tag, bind(left, stack), bind(right, stack))
        case Number(tag, value)
            Numeral(renameTag(tag, "_"), value)
        case Reference(tag, debruijn)
            Variable(tag, debruijn)
        case Operator(_, _, _)
            abort "internal error: Operator reached bind"
        case Definition(_, _, _, _)
            syntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            syntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            syntaxError("comma not inside brackets", node)
        case Case(tag, constructors, body)
            metadata := Metadata(Free, Free,
                constructors.map(`bind(stack)).map(getDebruijnIndex))
            Abstraction(tag, metadata, bind(body, getTagLexeme(tag) :: stack))
        case Section(_, _, _)
            syntaxError("invalid section", node)
        case SetBuilder(_, _)
            syntaxError("must appear on the right side of '::='", node)
        case Constructor(tag, parameterTypes, dataType, body, count, index)
            term := bind(body, stack)
            scheme := newConstructorScheme(term, parameterTypes,
                dataType, count, index)
            metadata := Metadata(Free, scheme, [])
            Abstraction(getTermTag(term), metadata, getBody(term))
        case Accessor(tag, dataType, returnType, body, count, index)
            term := bind(body, stack)
            scheme := newAccessorScheme(term, dataType, returnType,
                count, index)
            metadata := Metadata(Free, scheme, [])
            Abstraction(getTermTag(term), metadata, getBody(term))
        case Null(_)
            abort "internal error: Null reached bind"

#*
