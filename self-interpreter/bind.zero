#* bind.zero

define findParameter(level, stack, lexeme)
    with stack as table :: _
        table.lookup(lexeme).mapJust(mapFirst(level --))
    Void


define findDefiniens(stack, lexeme)
    with stack as table :: _
        table.lookup(lexeme).mapJust(second) ?? Void
    Void


define pushParameter(parameter, level, maybeNode, stack)
    lexeme := getLexeme(parameter)
    with stack as top :: stack'
        top.set(lexeme, (level, maybeNode)) :: stack'
    [newDictionary([(lexeme, (level, maybeNode))])]


define maybeAscription(node)
    with node as Abstraction(_, constraint, _)
        with constraint as Ascription(scheme)
            Just(scheme)
        Void
    with node as Numeral(_, type, _)
        Just(Scheme([], type))
    with node as Operation(_, type, _, _)
        Just(Scheme([MetaVariable(veil(getTermTag(node)), 0)], type))
    Void


define findScheme(lexeme, context)
    with context.lookup(lexeme) as Just(((_, term), _))
        maybeAscription(term)
    Void


define getNaturalType(context)
    context.findScheme("0").mapJust(getType) ??
        Variable(renameTag(noTag, "#NATURAL#", NOFIX), 0)


define getBooleanType(context)
    context.findScheme("False").mapJust(getType) ??
        Variable(renameTag(noTag, "#BOOLEAN#", NOFIX), 0)


define getStringType(context, tag)
    natural := getNaturalType(context)
    listType := context.findScheme("[]").mapJust(getType) ??
        parseError("List not defined", tag)
    with listType as Application(_, left, _)
        Application(noTag, left, natural)
    parseError("List type invalid", tag)


define getOperationType(context, tag)
    lexeme := getTagLexeme(tag)
    syntax(>->) := syntax(++)
    (>->) := Implication(noTag)
    if ["+", "--", "*", "//", "%"].any(=*= lexeme)
        natural := getNaturalType(context)
        Just(natural >-> natural >-> natural)
    if ["=", "=/=", "<", ">", "<=", ">="].any(=*= lexeme)
        natural := getNaturalType(context)
        boolean := getBooleanType(context)
        Just(natural >-> natural >-> boolean)
    if lexeme =*= "(increment)"
        natural := getNaturalType(context)
        Just(natural >-> natural)
    if lexeme =*= "(undefined)"
        Just(MetaVariable(noTag, 0))
    if lexeme =*= "abort"
        string := getStringType(context, tag)
        Just(string >-> MetaVariable(noTag, 0))
    Void


define bindOperation(context, tag)
    maybe (arity, optimize) := getBuiltin(tag)
    maybe type := getOperationType(context, tag)
    Just(Operation(tag, type, arity, optimize))


define bindVariable(level, stack, tag)
    lexeme := getTagLexeme(tag)
    maybe (debruijn, maybeValue) := findParameter(level, stack, lexeme)
    Just(Variable(tag, debruijn))


define bindContextTerm(context, tag)
    context.lookup(getTagLexeme(tag)).mapJust(second)


define bindName(level, stack, context, tag)
    if isUnused(tag)
        parseError("cannot reference a symbol starting with underscore", tag)
    bindVariable(level, stack, tag) ??
        bindContextTerm(context, tag) ??
        bindOperation(context, tag) ??
        parseError("undefined symbol", tag)


define newReconstructorType(parameterTypes, returnType)
    with parameterTypes as parameterType :: parameterTypes'
        bodyType := newReconstructorType(parameterTypes', returnType)
        Implication(getTermTag(parameterType), parameterType, bodyType)
    returnType


define newDeconstructorScheme(tag, parameterTypes, adtType, universals)
    returnType := MetaVariable(veil(tag), 0)
    reconstructorType := newReconstructorType(parameterTypes, returnType)
    syntax(>->) := syntax(++)
    (>->) := Implication(veil(tag))
    fallbackType := adtType >-> returnType
    type := reconstructorType >-> fallbackType >-> adtType >-> returnType
    Scheme(returnType :: universals, type)


define getResultType(type)
    with type as Implication(_, _, bodyType)
        getResultType(bodyType)
    type


define replaceReturnType(returnType, constructorType)
    with constructorType as Implication(tag, parameterType, bodyType)
        Implication(tag, parameterType, replaceReturnType(returnType, bodyType))
    returnType


define constructObjectType(tag, constructorTypes, returnType)
    types' := constructorTypes.map(replaceReturnType(returnType))
    types'.fold(Implication(tag), returnType)


define maybeCount(node)
    with node as Constructor(_, _, _, _, count, _)
        Just(count)
    Void


define maybeConstructorIndex(node)
    with node as Constructor(_, _, _, _, _, index)
        Just(index)
    Void


define constructCaseAnnotation(tag, constructorPairs)
    if isNil(constructorPairs)
        throwError("Type error: no cases:", tag)
    (constructors, constructorSchemes) := unzip(constructorPairs)
    if not constructors.all(isConstructor)
        throwError("Type error: invalid cases:", tag)
    constructorTypes := constructorSchemes.map(getType)
    constructionTypes := constructorTypes.map(getResultType)
    names := deduplicateBy((=*=),
        constructionTypes.map(getTagLexeme <> getTermTag))
    counts := deduplicate(constructors.map(maybeCount).prune)
    if length(names) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? throwError("Type error: invalid cases", tag)
    indices := constructors.map(maybeConstructorIndex).prune
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)

    # note: all schemes should have the same universals
    universals := getUniversals(safeHead(constructorSchemes) ??
        throwError("Type error: invalid cases", tag))
    returnType := MetaVariable(tag, 0)

    constructionType := safeHead(constructionTypes) ??
        throwError("Type error: invalid cases", tag)
    objectType := constructObjectType(veil(tag), constructorTypes, returnType)
    # note: the metsvariables in the two types must be instantiated together
    # so we need a new instantiation method that merges the universals and
    # instantiates two types with the same universals.
    PolarAnnotation(Scheme(universals, constructionType),
        Scheme([returnType], objectType))


define buildCaseAnnotation(tag, constructorNames, context)
    with constructorNames.map(getLexeme).map(`lookup(context)).sequence as
            Just(constructorPairs)
        (constructors, constructorTerms) := unzip(constructorPairs.map(first))
        with constructorTerms.map(maybeAscription).sequence as Just(schemes)
            Just(constructCaseAnnotation(tag, zip(constructors, schemes)))
        Void
    Void


define getAnnotation(node)
    with node as Juxtaposition(_, left, right)
        with left as Juxtaposition(_, left', _)
            if isThisName(left', ":")
                right
            syntaxError("missing annotation", node)
        syntaxError("missing annotation", node)
    syntaxError("missing annotation", node)


define extendContext(adtTypeAST, context)
    name := getHead(adtTypeAST)
    components := getArguments(adtTypeAST)
    if not components.all(isName)
        syntaxError("all components should be names", adtTypeAST)
    tags := components.map(getTag)
    # note: metavariable 0 is reserved for the polymorphic return type
    parameterTypes := zip(tags, 1 ...).map(uncurry(MetaVariable))
    values := zip(zip(components, parameterTypes), parameterTypes)
    entries := zip(components.map(getLexeme), values)
    (context.extendTable(entries), parameterTypes)


define bind(level, stack, context, node)
    match node
        case Reference(tag, debruijn)
            if debruijn = 0
                bindName(level, stack, context, tag)
            Variable(tag, debruijn)
        case Arrow(tag, arrowType, constructorNames, parameter, body)
            with arrowType as DoubleArrow
                parameterTerm := parameter.bind(level, stack, context)
                bodyTerm := body.bind(level, stack, context)
                Implication(tag, parameterTerm, bodyTerm)
            stack' := stack.pushParameter(parameter, level, Void)
            bodyTerm := body.bind(up level, stack', context)
            if isNil(constructorNames)
                Abstraction(getTag(parameter), NoConstraint, bodyTerm)
            with buildCaseAnnotation(tag, constructorNames, context) as
                    Just(annotation)
                Abstraction(getTag(parameter), annotation, bodyTerm)
            syntaxError("invalid constructors", node)
        case Juxtaposition(tag, left, right)
            Application(tag, left.bind(level, stack, context),
                right.bind(level, stack, context))
        case Let(tag, name, value, scope)
            valueTerm := value.bind(level, stack, context)
            stack' := stack.pushParameter(name, level, Just((value, valueTerm)))
            scopeTerm := scope.bind(up level, stack', context)
            abstraction := Abstraction(getTag(name), NoConstraint, scopeTerm)
            Application(tag, abstraction, valueTerm)
        case Number(tag, value)
            Numeral(tag, getNaturalType(context), value)
        case Operator(_, _, _)
            abort "internal error: Operator reached bind"
        case Definition(_, _, _, _)
            syntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            syntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            syntaxError("comma not inside brackets", node)
        case Section(_, _, _)
            syntaxError("invalid section", node)
        case ADT(_, _)
            syntaxError("must appear on the right side of '::='", node)
        case ADT(tag, forms)
            # the parameters are already on the stack at this point
            implicit := Name(veil(tag))
            stack' := stack.pushParameter(implicit, level, Void)
            returnType := Variable(renameTag(tag, "r", NOFIX), 0)
            annotations := forms.map(getArguments).map(map(getAnnotation))
            boundAnnotations :=
                annotations.map(map(bind(up level, stack', context)))
            boundTypes := boundAnnotations.map(
                fold(Implication(veil(tag)), returnType))
            bodyType := boundTypes.fold(Implication(veil(tag)), returnType)
            Implicit(getTermTag(returnType), Top(tag), bodyType)
        case Constructor(tag, parameterTypes, adtType, function, count, index)
            (context', universals) := context.extendContext(adtType)
            parameterTypes' := parameterTypes.map(bind(level, stack, context'))
            adtType' := adtType.bind(level, stack, context')
            type := newReconstructorType(parameterTypes', adtType')
            with function as Number(_, value)
                Numeral(tag, type, value)
            scheme := Scheme(universals, type)
            function.bind(level, stack, context).setAscription(scheme)
        case Deconstructor(tag, parameterTypes, adtType, function, count, index)
            (context', universals) := context.extendContext(adtType)
            parameterTypes' := parameterTypes.map(bind(level, stack, context'))
            adtType' := adtType.bind(level, stack, context')
            scheme := universals.newDeconstructorScheme(
                tag, parameterTypes', adtType')
            function.bind(level, stack, context).setAscription(scheme)
        case Accessor(tag, adtType, returnType, function, count, index)
            (context', universals) := context.extendContext(adtType)
            adtType' := adtType.bind(level, stack, context')
            returnType' := returnType.bind(level, stack, context')
            type := Implication(tag, adtType', returnType')
            scheme := Scheme(universals, type)
            function.bind(level, stack, context).setAscription(scheme)
        case Null(_)
            abort "internal error: Null reached bind"


define bindGlobal(context, node)
    stack := [newDictionary([])]
    bind(0, stack, context, node)


define bindDefinition(state, (tag, isTypeConstructor, node))
    (tags, context, environment) := state
    term := bindGlobal(context, node)
    (index, environment') := environment.allocate(Closure(term, environment))
    constant := Constant(tag, isTypeConstructor, index)
    context' := context.set(getTagLexeme(tag), ((node, term), constant))
    (tag :: tags, context', environment')


define getDefinitions(node)
    with node as Let(tag, name, value, scope)
        # TODO: set isTypeConstructor
        (getTag(name), False, value) :: getDefinitions(scope)
    [(veil(getTag(node)), False, node)]


define maybeIndex(term)
    with term as Constant(_, _, index)
        Just(index)
    Void


define bindAST(node)
    # TODO: make state a parameter so we can bind with an existing state
    state := ([], newDictionary([]), newStore([]))
    state' := getDefinitions(node).cascade(bindDefinition, state)
    (tags, context, environment) := state'
    (reverse(tags), context, environment)

#*
