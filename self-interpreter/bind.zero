#* bind.zero

define findDebruijnIndex(level, stack, lexeme)
    head(stack).lookup(lexeme).mapJust(level -)


define bindOperation(tag)
    maybe (arity, optimize) := getBuiltin(tag)
    Just(Operation(tag, arity, optimize))


define bindName(level, stack, tag)
    if isUnused(tag)
        parseError("cannot reference a symbol starting with underscore", tag)
    findDebruijnIndex(level, stack, getTagLexeme(tag)).mapJust(Variable(tag)) ??
        bindOperation(tag) ?? parseError("undefined symbol", tag)


define getADTFixity(root)
    if isReference(root) then getReferenceFixity(root) else NOFIX


define parseParameterType(node, context)
    # TODO: count parameter to ADTs is wrong
    if isName(node)
        if isUnderscore(getTag(node))
            BottomType(noTerm)        # todo: remove after implementing (=>)
        name := getLexeme(node)
        context.lookup(name) ??
            ADT(noTerm, name, getADTFixity(node), [], FreeType, 0, 0)
    root := getHead(node)
    name := getLexeme(root)
    if context.hasKey(name)
        syntaxError("type variable not allowed in applicand position", node)
    parameterTypes := getArguments(node).map(`parseParameterType(context))
    if name =*= "=>"
        if length(parameterTypes) =/= 2
            syntaxError("(=>) requires two arguments", node)
        match parameterTypes
            case []; FunctionType(noTerm, FreeType, FreeType)
            case left :: parameterTypes'
                match parameterTypes'
                    case []; FunctionType(noTerm, left, FreeType)
                    case right :: _
                        FunctionType(noTerm, left, right)
    ADT(noTerm, name, getADTFixity(root), parameterTypes, FreeType, 0, 0)


define parseADT(node, context, count, index)
    root := getHead(node)
    name := getLexeme(root)
    parameterTypes := getArguments(node).map(`get(context) <> getLexeme)
    fixity := getADTFixity(root)
    ADT(noTerm, name, fixity, parameterTypes, FreeType, count, index)


define buildContext(dataType)
    # context maps type variable names to type variables
    components := getArguments(dataType)
    if not components.all(isName)
        syntaxError("all components should be names", dataType)
    typeVariables := (0 .. length(components) - 1).map(TypeVariable(noTerm))
    newDictionary(zip(components.map(getLexeme), typeVariables))


define newConstructorType(term, parameterTypes, dataType, context, count, index)
    # todo: check that universals are not already defined and that all other
    # names are already defined; also make sure universal name is not the
    # same as the dataType name
    if isNil(parameterTypes)
        parseADT(dataType, context, count, index)
    parameterType := parseParameterType(head(parameterTypes), context)
    FunctionType(term, parameterType, newConstructorType(getBody(term),
        tail(parameterTypes), dataType, context, count, index))


define newConstructorScheme(term, parameterTypes, dataType, count, index)
    context := buildContext(dataType)
    universals := getValues(context)
    type := newConstructorType(term, parameterTypes,
        dataType, context, count, index)
    Scheme(universals, type)


define newAccessorScheme(term, dataType, returnType, count, index)
    context := buildContext(dataType)
    universals := getValues(context)
    type := FunctionType(term, parseADT(dataType, context, count, index),
        parseParameterType(returnType, context))
    Scheme(universals, type)


define bind(level, stack, node)
    match node
        case Reference(tag, debruijn, _depth, fixity)
            if debruijn = 0
                bindName(level, stack, tag)
            Variable(tag, debruijn)
        case Arrow(tag, _, constructors, parameter, body)
            constructors' := constructors.map(bind(level, stack))
            indices := constructors'.map(getDebruijnIndex)
            metadata := Metadata(Free, Free, indices)
            stack' := head(stack).set(getLexeme(parameter), level) :: stack
            body' := bind(up level, stack', body)
            Abstraction(getTag(parameter), metadata, body')
        case Couple(tag, _, left, right)
            Application(tag, isLetCouple(node),
                bind(level, stack, left), bind(level, stack, right))
        case Number(tag, value)
            Numeral(renameTag(tag, "_"), value)
        case Operator(_, _, _)
            abort "internal error: Operator reached bind"
        case Definition(_, _, _, _)
            syntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            syntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            syntaxError("comma not inside brackets", node)
        case Section(_, _, _)
            syntaxError("invalid section", node)
        case SetBuilder(_, _)
            syntaxError("must appear on the right side of '::='", node)
        case Constructor(tag, parameterTypes, dataType, body, count, index)
            term := bind(level, stack, body)
            scheme := newConstructorScheme(term, parameterTypes,
                dataType, count, index)
            metadata := Metadata(Free, scheme, [])
            Abstraction(getTermTag(term), metadata, getBody(term))
        case Accessor(tag, dataType, returnType, body, count, index)
            term := bind(level, stack, body)
            scheme := newAccessorScheme(term, dataType, returnType,
                count, index)
            metadata := Metadata(Free, scheme, [])
            Abstraction(getTermTag(term), metadata, getBody(term))
        case Null(_)
            abort "internal error: Null reached bind"


define bindAST(node)
    stack := [newDictionary([])]
    bind(0, stack, node)

#*
