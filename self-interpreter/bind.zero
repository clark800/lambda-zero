#* bind.zero

# temporary function that can be removed after schemes are removed
define convertToSchemeType(implicits, level, type)
    with type as Implication(tag, left, right)
        left' := convertToSchemeType(implicits, level, left)
        right' := convertToSchemeType(implicits, up level, right)
        Implication(tag, left', right')
    with type as Application(tag, left, right)
        left' := convertToSchemeType(implicits, level, left)
        right' := convertToSchemeType(implicits, level, right)
        Application(tag, left', right')
    with type as Variable(tag, debruijn)
        if debruijn > level -- implicits
            MetaVariable(tag, level -- debruijn + 1)
        Variable(tag, debruijn)
    type


# temporary function that can be removed after schemes are removed
define convertToScheme(level, type)
    with type as Implicit(tag, parameter, body)
        match convertToScheme(up level, body)
            case Scheme(universals, type')
                id := length(universals) + 1
                Scheme(universals ++ [MetaVariable(tag, id)], type')
    Scheme([], convertToSchemeType(level, level, type))


define findParameter(level, stack, lexeme)
    with stack as table :: _
        table.lookup(lexeme).mapJust(mapFirst(level --))
    Void


define findDefiniens(stack, lexeme)
    with stack as table :: _
        table.lookup(lexeme).mapJust(second) ?? Void
    Void


define pushParameter(parameter, level, maybeNode, stack)
    lexeme := getLexeme(parameter)
    with stack as top :: stack'
        top.insert(lexeme, (level, maybeNode)) :: stack'
    [newDictionary([(lexeme, (level, maybeNode))])]


define maybeAscription(node)
    with node as Abstraction(_, constraint, _)
        with constraint as Ascription(scheme)
            Just(scheme)
        Void
    with node as Numeral(_, type, _)
        Just(Scheme([], type))
    with node as Operation(_, type, _, _)
        Just(Scheme([MetaVariable(veil(getTermTag(node)), 0)], type))
    Void


define findScheme(lexeme, context)
    with context.lookup(lexeme) as Just(((_, term), _))
        maybeAscription(term)
    Void


define getNaturalType(context)
    context.findScheme("0").mapJust(getType) ??
        Variable(renameTag(noTag, "#NATURAL#", NOFIX), 0)


define getBooleanType(context)
    context.findScheme("False").mapJust(getType) ??
        Variable(renameTag(noTag, "#BOOLEAN#", NOFIX), 0)


define getStringType(context, tag)
    natural := getNaturalType(context)
    listType := context.findScheme("[]").mapJust(getType) ??
        parseError("List not defined", tag)
    with listType as Application(_, left, _)
        Application(noTag, left, natural)
    parseError("List type invalid", tag)


define getOperationType(context, tag)
    lexeme := getTagLexeme(tag)
    syntax(>->) := syntax(++)
    (>->) := Implication(noTag)
    if ["+", "--", "*", "//", "%"].any(=*= lexeme)
        natural := getNaturalType(context)
        Just(natural >-> natural >-> natural)
    if ["=", "=/=", "<", ">", "<=", ">="].any(=*= lexeme)
        natural := getNaturalType(context)
        boolean := getBooleanType(context)
        Just(natural >-> natural >-> boolean)
    if lexeme =*= "(increment)"
        natural := getNaturalType(context)
        Just(natural >-> natural)
    if lexeme =*= "(undefined)"
        Just(MetaVariable(noTag, 0))
    if lexeme =*= "abort"
        string := getStringType(context, tag)
        Just(string >-> MetaVariable(noTag, 0))
    Void


define bindOperation(context, tag)
    maybe (arity, optimize) := getBuiltin(tag)
    maybe type := getOperationType(context, tag)
    Just(Operation(tag, type, arity, optimize))


define bindVariable(level, stack, tag)
    lexeme := getTagLexeme(tag)
    maybe (debruijn, maybeValue) := findParameter(level, stack, lexeme)
    Just(Variable(tag, debruijn))


define bindContextTerm(context, tag)
    context.lookup(getTagLexeme(tag)).mapJust(second)


define bindName(level, stack, context, tag)
    if isUnused(tag)
        parseError("cannot reference a symbol starting with underscore", tag)
    bindVariable(level, stack, tag) ??
        bindContextTerm(context, tag) ??
        bindOperation(context, tag) ??
        parseError("undefined symbol", tag)


define newReconstructorType(parameterTypes, returnType)
    with parameterTypes as parameterType :: parameterTypes'
        bodyType := newReconstructorType(parameterTypes', returnType)
        Implication(getTermTag(parameterType), parameterType, bodyType)
    returnType


define newReconstructorAST'(parameterTypeASTs, returnTypeAST)
    with parameterTypeASTs as parameterTypeAST :: parameterTypeASTs'
        bodyTypeAST := newReconstructorAST'(parameterTypeASTs', returnTypeAST)
        DoubleArrow(parameterTypeAST, bodyTypeAST)
    returnTypeAST


define newReconstructorAST(parameterTypeASTs, returnTypeAST)
    typeAST := newReconstructorAST'(parameterTypeASTs, returnTypeAST)
    parameters := getArguments(returnTypeAST)
    parameters.fold(ImplicitArrow, typeAST)


define newDeconstructorAST(tag, parameterTypeASTs, adtTypeAST)
    # todo: change name from "r" so it can't clash with user's names
    returnType := Name(renameTag(tag, "r", NOFIX))
    reconstructorType := newReconstructorAST'(parameterTypeASTs, returnType)
    syntax(>->) := syntax(++)
    (>->) := DoubleArrow
    fallbackType := adtTypeAST >-> returnType
    typeAST := reconstructorType >-> fallbackType >-> adtTypeAST >-> returnType
    parameters := getArguments(adtTypeAST)
    ImplicitArrow(returnType, parameters.fold(ImplicitArrow, typeAST))


define getResultType(type)
    with type as Implication(_, _, bodyType)
        getResultType(bodyType)
    type


define replaceReturnType(returnType, constructorType)
    with constructorType as Implication(tag, parameterType, bodyType)
        Implication(tag, parameterType, replaceReturnType(returnType, bodyType))
    returnType


define constructObjectType(tag, constructorTypes, returnType)
    types' := constructorTypes.map(replaceReturnType(returnType))
    types'.fold(Implication(tag), returnType)


define maybeCount(node)
    with node as Constructor(_, _, _, _, count, _)
        Just(count)
    Void


define maybeConstructorIndex(node)
    with node as Constructor(_, _, _, _, _, index)
        Just(index)
    Void


define constructCaseAnnotation(tag, constructorPairs)
    if isNil(constructorPairs)
        throwError("Type error: no cases:", tag)
    (constructors, constructorSchemes) := unzip(constructorPairs)
    if not constructors.all(isConstructor)
        throwError("Type error: invalid cases:", tag)
    constructorTypes := constructorSchemes.map(getType)
    constructionTypes := constructorTypes.map(getResultType)
    names := deduplicateBy((=*=),
        constructionTypes.map(getTagLexeme <> getTermTag))
    counts := deduplicate(constructors.map(maybeCount).prune)
    if length(names) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? throwError("Type error: invalid cases", tag)
    indices := constructors.map(maybeConstructorIndex).prune
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)

    # note: all schemes should have the same universals
    universals := getUniversals(safeHead(constructorSchemes) ??
        throwError("Type error: invalid cases", tag))
    returnType := MetaVariable(tag, 0)

    constructionType := safeHead(constructionTypes) ??
        throwError("Type error: invalid cases", tag)
    objectType := constructObjectType(veil(tag), constructorTypes, returnType)
    # note: the metsvariables in the two types must be instantiated together
    # so we need a new instantiation method that merges the universals and
    # instantiates two types with the same universals.
    PolarAnnotation(Scheme(universals, constructionType),
        Scheme([returnType], objectType))


define buildCaseAnnotation(tag, constructorNames, context)
    with constructorNames.map(getLexeme).map(`lookup(context)).sequence as
            Just(constructorPairs)
        (constructors, constructorTerms) := unzip(constructorPairs.map(first))
        with constructorTerms.map(maybeAscription).sequence as Just(schemes)
            Just(constructCaseAnnotation(tag, zip(constructors, schemes)))
        Void
    Void


define getAnnotation(node)
    with node as Juxtaposition(_, left, right)
        with left as Juxtaposition(_, left', _)
            if isThisName(left', ":")
                right
            syntaxError("missing annotation", node)
        syntaxError("missing annotation", node)
    syntaxError("missing annotation", node)


define bind(level, stack, context, node)
    match node
        case Reference(tag, debruijn)
            if debruijn = 0
                bindName(level, stack, context, tag)
            Variable(tag, debruijn)
        case Arrow(tag, arrowType, constructorNames, parameter, body)
            with arrowType as Double
                parameterTerm := parameter.bind(level, stack, context)
                # todo: add support for names on left side of double arrows
                stack' := stack.pushParameter(Name(veil(tag)), level, Void)
                bodyTerm := body.bind(up level, stack', context)
                Implication(tag, parameterTerm, bodyTerm)
            stack' := stack.pushParameter(parameter, level, Void)
            bodyTerm := body.bind(up level, stack', context)
            with arrowType as Squiggle
                Implicit(tag, Top(tag), bodyTerm)
            if isNil(constructorNames)
                Abstraction(getTag(parameter), NoConstraint, bodyTerm)
            with buildCaseAnnotation(tag, constructorNames, context) as
                    Just(annotation)
                Abstraction(getTag(parameter), annotation, bodyTerm)
            syntaxError("invalid constructors", node)
        case Juxtaposition(tag, left, right)
            Application(tag, left.bind(level, stack, context),
                right.bind(level, stack, context))
        case Let(tag, name, value, scope)
            valueTerm := value.bind(level, stack, context)
            stack' := stack.pushParameter(name, level, Just((value, valueTerm)))
            scopeTerm := scope.bind(up level, stack', context)
            abstraction := Abstraction(getTag(name), NoConstraint, scopeTerm)
            Application(tag, abstraction, valueTerm)
        case Number(tag, value)
            Numeral(tag, getNaturalType(context), value)
        case Operator(_, _, _)
            abort "internal error: Operator reached bind"
        case Definition(_, _, _, _)
            syntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            syntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            syntaxError("comma not inside brackets", node)
        case Section(_, _, _)
            syntaxError("invalid section", node)
        case SetBuilder(_, _)
            syntaxError("must appear on the right side of '::='", node)
        case ADT(tag, forms)
            # the ADT parameters are already on the stack at this point
            # todo: change name from "r" so it can't clash with user's names
            returnType := Name(renameTag(tag, "r", NOFIX))
            annotations := forms.map(getArguments).map(map(getAnnotation))
            argumentTypes := annotations.map(fold(DoubleArrow, returnType))
            bodyType := argumentTypes.fold(DoubleArrow, returnType)
            ImplicitArrow(returnType, bodyType).bind(level, stack, context)
        case Constructor(tag, parameterTypes, adtType, function, count, index)
            typeAST := newReconstructorAST(parameterTypes, adtType)
            type := typeAST.bind(level, stack, context)
            with function as Number(_, value)
                Numeral(tag, type, value)
            scheme := convertToScheme(0, type)
            function.bind(level, stack, context).setAscription(scheme)
        case Deconstructor(tag, parameterTypes, adtType, function, count, index)
            typeAST := newDeconstructorAST(tag, parameterTypes, adtType)
            type := typeAST.bind(level, stack, context)
            scheme := convertToScheme(0, type)
            function.bind(level, stack, context).setAscription(scheme)
        case Accessor(tag, adtType, returnType, function, count, index)
            arrowAST := DoubleArrow(adtType, returnType)
            parameters := getArguments(adtType)
            typeAST := parameters.fold(ImplicitArrow, arrowAST)
            scheme := convertToScheme(0, typeAST.bind(level, stack, context))
            function.bind(level, stack, context).setAscription(scheme)
        case Null(_)
            abort "internal error: Null reached bind"


define bindGlobal(context, node)
    stack := [newDictionary([])]
    bind(0, stack, context, node)


define bindDefinition(state, (tag, isTypeConstructor, node))
    (tags, context, environment) := state
    term := bindGlobal(context, node)
    (index, environment') := environment.append(Closure(term, environment))
    constant := Constant(tag, isTypeConstructor, index)
    context' := context.insert(getTagLexeme(tag), ((node, term), constant))
    (tag :: tags, context', environment')


define getDefinitions(node)
    with node as Let(tag, name, value, scope)
        # TODO: set isTypeConstructor
        (getTag(name), False, value) :: getDefinitions(scope)
    [(veil(getTag(node)), False, node)]


define maybeIndex(term)
    with term as Constant(_, _, index)
        Just(index)
    Void


define bindAST(node)
    # TODO: make state a parameter so we can bind with an existing state
    state := ([], newDictionary([]), newArray([]))
    state' := getDefinitions(node).cascade(bindDefinition, state)
    (tags, context, environment) := state'
    (reverse(tags), context, environment)

#*
