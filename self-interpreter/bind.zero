#* bind.zero

define findDebruijnIndex(level, stack, lexeme)
    with stack as table :: _
        table.lookup(lexeme).mapJust(level -)
    Void


define pushParameter(lexeme, level, stack)
    with stack as top :: stack'
        top.set(lexeme, level) :: stack'
    [newDictionary([(lexeme, level)])]


define bindOperation(tag)
    maybe (arity, optimize) := getBuiltin(tag)
    Just(Operation(tag, arity, optimize))


define bindName(level, stack, tag)
    if isUnused(tag)
        parseError("cannot reference a symbol starting with underscore", tag)
    findDebruijnIndex(level, stack, getTagLexeme(tag)).mapJust(Variable(tag)) ??
        bindOperation(tag) ?? parseError("undefined symbol", tag)


define getADTFixity(root)
    if isReference(root) then getReferenceFixity(root) else NOFIX


define parseParameterType(node, context)
    # TODO: count parameter to ADTs is wrong
    if isName(node)
        if isUnderscore(getTag(node))
            BottomType(noTerm)        # todo: remove after implementing (=>)
        name := getLexeme(node)
        context.lookup(name) ??
            ADT(noTerm, name, getADTFixity(node), [], FreeType, 0, 0)
    root := getHead(node)
    name := getLexeme(root)
    if context.hasKey(name)
        syntaxError("type variable not allowed in applicand position", node)
    parameterTypes := getArguments(node).map(`parseParameterType(context))
    if name =*= "=>"
        if length(parameterTypes) =/= 2
            syntaxError("(=>) requires two arguments", node)
        with parameterTypes as left :: parameterTypes'
            with parameterTypes' as right :: _
                FunctionType(noTerm, left, right)
            FunctionType(noTerm, left, FreeType)
        FunctionType(noTerm, FreeType, FreeType)
    ADT(noTerm, name, getADTFixity(root), parameterTypes, FreeType, 0, 0)


define parseADT(node, context, count, index)
    root := getHead(node)
    name := getLexeme(root)
    parameterTypes := getArguments(node).map(`get(context) <> getLexeme)
    fixity := getADTFixity(root)
    ADT(noTerm, name, fixity, parameterTypes, FreeType, count, index)


define buildContext(adtTypeAST)
    # context maps type variable names to type variables
    # type variable with index 0 is reserved for deconstructors
    components := getArguments(adtTypeAST)
    if not components.all(isName)
        syntaxError("all components should be names", adtTypeAST)
    typeVariables := (1 .. length(components)).map(TypeVariable(noTerm))
    newDictionary(zip(components.map(getLexeme), typeVariables))


define newReconstructorType(term, context, parameterTypeASTs, returnType)
    with parameterTypeASTs as typeAST :: parameterTypeASTs'
        parameterType := parseParameterType(typeAST, context)
        bodyType := newReconstructorType(
            getBody(term), context, parameterTypeASTs', returnType)
        FunctionType(term, parameterType, bodyType)
    returnType


define newConstructorScheme(term, parameterTypeASTs, adtTypeAST, count, index)
    # todo: check that universals are not already defined and that all other
    # names are already defined; also make sure universal name is not the
    # same as the dataType name
    context := buildContext(adtTypeAST)
    universals := getValues(context)
    adtType := parseADT(adtTypeAST, context, count, index)
    type := newReconstructorType(term, context, parameterTypeASTs, adtType)
    Scheme(universals, type)


define newDeconstructorScheme(term, parameterTypeASTs, adtTypeAST, count, index)
    returnType := TypeVariable(term, 0)
    context := buildContext(adtTypeAST)
    universals := returnType :: getValues(context)
    adtType := parseADT(adtTypeAST, context, count, index)
    reconstructorType :=
        newReconstructorType(term, context, parameterTypeASTs, returnType)
    syntax(>->) := syntax(++)
    (>->) := FunctionType(term)
    fallbackType := adtType >-> returnType
    type := reconstructorType >-> fallbackType >-> adtType >-> returnType
    Scheme(universals, type)


define newAccessorScheme(term, dataType, returnType, count, index)
    context := buildContext(dataType)
    universals := getValues(context)
    type := FunctionType(term, parseADT(dataType, context, count, index),
        parseParameterType(returnType, context))
    Scheme(universals, type)


define bind(level, stack, node)
    match node
        case Reference(tag, debruijn, _depth, fixity)
            if debruijn = 0
                bindName(level, stack, tag)
            Variable(tag, debruijn)
        case Arrow(tag, _, constructors, parameter, body)
            constructors' := constructors.map(bind(level, stack))
            indices := constructors'.map(getDebruijnIndex)
            metadata := Metadata(Free, Free, indices)
            stack' := stack.pushParameter(getLexeme(parameter), level)
            body' := bind(up level, stack', body)
            Abstraction(getTag(parameter), metadata, body')
        case Couple(tag, _, left, right)
            Application(tag, isLetCouple(node),
                bind(level, stack, left), bind(level, stack, right))
        case Number(tag, value)
            Numeral(renameTag(tag, "_"), value)
        case Operator(_, _, _)
            abort "internal error: Operator reached bind"
        case Definition(_, _, _, _)
            syntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            syntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            syntaxError("comma not inside brackets", node)
        case Section(_, _, _)
            syntaxError("invalid section", node)
        case SetBuilder(_, _)
            syntaxError("must appear on the right side of '::='", node)
        case Constructor(tag, parameterTypes, dataType, body, count, index)
            term := bind(level, stack, body)
            scheme := newConstructorScheme(term, parameterTypes,
                dataType, count, index)
            metadata := Metadata(Free, scheme, [])
            Abstraction(getTermTag(term), metadata, getBody(term))
        case Deconstructor(tag, parameterTypes, dataType, body, count, index)
            term := bind(level, stack, body)
            scheme := newDeconstructorScheme(term, parameterTypes,
                dataType, count, index)
            metadata := Metadata(Free, scheme, [])
            Abstraction(getTermTag(term), metadata, getBody(term))
        case Accessor(tag, dataType, returnType, body, count, index)
            term := bind(level, stack, body)
            scheme := newAccessorScheme(term, dataType, returnType,
                count, index)
            metadata := Metadata(Free, scheme, [])
            Abstraction(getTermTag(term), metadata, getBody(term))
        case Null(_)
            abort "internal error: Null reached bind"


define bindAST(node)
    stack := [newDictionary([])]
    bind(0, stack, node)

#*
