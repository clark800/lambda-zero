#* bind.zero

define findDebruijnIndex(parameterNames, tag)
    if isUnused(tag)
        parseError("cannot reference a symbol starting with underscore", tag)
    parameterNames.indexOf(getTagLexeme(tag)).mapRight(1 +) ?
        parseError("undefined symbol", tag)


define bindOperation(tag)
    try (arity, optimize) := getBuiltin(tag)
    return Operation(tag, arity, optimize)


define isDefined(tag, parameterNames)
    bool(bindOperation(tag)) or (not isUnderscore(tag) and
        parameterNames.contains(getTagLexeme(tag)))


define parseType(node, context)
    if isName(node)
        name := getLexeme(node)
        context.lookup(name) ? NominalType(noTerm, name, [])
    name := getLexeme(getHead(node))
    if context.hasKey(name)
        syntaxError("type variable not allowed in applicand position", node)
    NominalType(noTerm, name, getArguments(node).map(`parseType(context)))


define buildContext(dataType)
    # context maps type variable names to type variables
    components := getArguments(dataType)
    if not components.all(isName)
        syntaxError("all components should be names", dataType)
    typeVariables := (0 .. length(components)).map(TypeVariable(noTerm))
    newTable((<*=), zip(components.map(getLexeme), typeVariables))


define newConstructorType(term, parameterTypes, dataType, context)
    # todo: check that universals are not already defined and that all other
    # names are already defined; also make sure universal name is not the
    # same as the dataType name
    if isNil(parameterTypes)
        parseType(dataType, context)
    parameterType := parseType(head(parameterTypes), context)
    FunctionType(term, parameterType, newConstructorType(getBody(term),
        tail(parameterTypes), dataType, context))


define newConstructorScheme(term, parameterTypes, dataType)
    context := buildContext(dataType)
    universals := getValues(context)
    type := newConstructorType(term, parameterTypes, dataType, context)
    Scheme(universals, type)


define newAccessorScheme(term, dataType, returnType)
    context := buildContext(dataType)
    universals := getValues(context)
    type := FunctionType(term, parseType(dataType, context),
        parseType(returnType, context))
    Scheme(universals, type)


define bind(node, parameterNames)
    match node
        case Name(tag)
            bindOperation(tag) ?
                Variable(tag, parameterNames.findDebruijnIndex(tag))
        case Arrow(tag, parameter, body)
            if isDefined(getTag(parameter), parameterNames)
                syntaxError("symbol already defined", parameter)
            parameterName := getLexeme(parameter)
            Abstraction(getTag(parameter), Free,
                bind(body, parameterName :: parameterNames))
        case Couple(tag, _, left, right)
            Application(tag, bind(left, parameterNames),
                             bind(right, parameterNames))
        case Number(tag, value)
            Numeral(renameTag(tag, "_"), value)
        case Reference(tag, debruijn)
            Variable(tag, debruijn)
        case Operator(_, _, _)
            error("internal error: Operator reached bind")
        case Definition(_, _, _, _)
            syntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            syntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            syntaxError("comma not inside brackets", node)
        case Case(tag, constructors, body)
            # todo: add constructors to Abstraction
            Abstraction(tag, Free,
                bind(body, getTagLexeme(tag) :: parameterNames))
        case Section(_, _, _)
            syntaxError("invalid section", node)
        case ADT(_, _)
            syntaxError("must appear on the right side of '::='", node)
        case Constructor(tag, parameterTypes, dataType, body)
            term := bind(body, parameterNames)
            scheme := newConstructorScheme(term, parameterTypes, dataType)
            Abstraction(getTermTag(term), scheme, getBody(term))
        case Accessor(tag, dataType, returnType, body)
            term := bind(body, parameterNames)
            scheme := newAccessorScheme(term, dataType, returnType)
            Abstraction(getTermTag(term), scheme, getBody(term))
        case Null(_)
            error("internal error: Null reached bind")

#*
