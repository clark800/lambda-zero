#* bind.zero

define findParameter(level, stack, lexeme)
    with stack as table :: _
        table.lookup(lexeme).mapJust(mapFirst(level --))
    Void


define findDefiniens(stack, lexeme)
    with stack as table :: _
        table.lookup(lexeme).mapJust(second) ?? Void
    Void


define pushParameter(parameter, level, maybeNode, stack)
    lexeme := getLexeme(parameter)
    with stack as top :: stack'
        top.set(lexeme, (level, maybeNode)) :: stack'
    [newDictionary([(lexeme, (level, maybeNode))])]


define bindOperation(tag)
    maybe (arity, optimize) := getBuiltin(tag)
    Just(Operation(tag, Top(tag), arity, optimize))  # todo: set type


define bindVariable(level, stack, tag)
    lexeme := getTagLexeme(tag)
    maybe (debruijn, maybeValue) := findParameter(level, stack, lexeme)
    Just(Variable(tag, debruijn))


define bindName(level, stack, tag)
    if isUnused(tag)
        parseError("cannot reference a symbol starting with underscore", tag)
    bindVariable(level, stack, tag) ?? bindOperation(tag) ??
        parseError("undefined symbol", tag)


define parseParameterType(node, context)
    if isName(node)
        tag := getTag(node)
        context.lookup(getLexeme(node)) ?? Construction(tag, [])
    with node as Arrow(tag, arrowType, _, parameter, body)
        with arrowType as DoubleArrow
            left := parseParameterType(parameter, context)
            right := parseParameterType(body, context)
            Implication(tag, left, right)
        syntaxError("invalid arrow in annotation", node)
    root := getHead(node)
    name := getLexeme(root)
    if context.hasKey(name)
        syntaxError("type variable not allowed in applicand position", node)
    parameterTypes := getArguments(node).map(`parseParameterType(context))
    Construction(getTag(root), parameterTypes)


define newReconstructorType(context, parameterTypeASTs, returnType)
    with parameterTypeASTs as typeAST :: parameterTypeASTs'
        parameterType := parseParameterType(typeAST, context)
        bodyType := newReconstructorType(context,
            parameterTypeASTs', returnType)
        Implication(getTermTag(parameterType), parameterType, bodyType)
    returnType


define parseConstruction(node)
    # context maps type variable names to type variables
    # type variable with index 0 is reserved for deconstructors
    root := getHead(node)
    components := getArguments(node)
    if not components.all(isName)
        syntaxError("all components should be names", node)
    tag := veil(getTag(node))
    parameterTypes := (1 .. length(components)).map(MetaVariable(tag))
    context := newDictionary(zip(components.map(getLexeme), parameterTypes))
    type := Construction(getTag(root), parameterTypes)
    (type, parameterTypes, context)


define newConstructorScheme(tag, parameterTypeASTs, adtTypeAST)
    # todo: check that universals are not already defined and that all other
    # names are already defined; also make sure universal name is not the
    # same as the dataType name
    (adtType, universals, context) := parseConstruction(adtTypeAST)
    type := newReconstructorType(context, parameterTypeASTs, adtType)
    Scheme(universals, type)


define newDeconstructorScheme(tag, parameterTypeASTs, adtTypeAST)
    returnType := MetaVariable(veil(tag), 0)
    (adtType, componentTypes, context) := parseConstruction(adtTypeAST)
    universals := returnType :: componentTypes
    reconstructorType :=
        newReconstructorType(context, parameterTypeASTs, returnType)
    syntax(>->) := syntax(++)
    (>->) := Implication(veil(tag))
    fallbackType := adtType >-> returnType
    type := reconstructorType >-> fallbackType >-> adtType >-> returnType
    Scheme(universals, type)


define newAccessorScheme(tag, dataType, returnType)
    (adtType, universals, context) := parseConstruction(dataType)
    type := Implication(tag, adtType, parseParameterType(returnType, context))
    Scheme(universals, type)


define getResultType(type)
    with type as Implication(_, _, bodyType)
        getResultType(bodyType)
    type


define replaceConstruction(returnType, constructorType)
    if isConstruction(constructorType)
        returnType
    with constructorType as Implication(tag, parameterType, bodyType)
        Implication(tag, parameterType,
            replaceConstruction(returnType, bodyType))
    throwError("Type error: invalid constructor", getTermTag(constructorType))


define constructObjectType(tag, constructorTypes, returnType)
    types' := constructorTypes.map(replaceConstruction(returnType))
    types'.fold(Implication(tag), returnType)


define maybeCount(node)
    with node as Constructor(_, _, _, _, count, _)
        Just(count)
    Void


define maybeIndex(node)
    with node as Constructor(_, _, _, _, _, index)
        Just(index)
    Void


define maybeConstructorScheme(node)
    with node as Constructor(tag, parameterTypes, adtType, _, _, _)
        Just(newConstructorScheme(tag, parameterTypes, adtType))
    Void


define constructCaseAnnotation(tag, constructors, constructorSchemes)
    if isNil(constructors)
        throwError("Type error: no cases:", tag)
    if not constructors.all(isConstructor)
        throwError("Type error: invalid cases:", tag)
    constructorTypes := constructorSchemes.map(getType)
    constructionTypes := constructorTypes.map(getResultType)
    if not constructionTypes.all(isConstruction)
        throwError("Type error: invalid cases:", tag)
    names := deduplicateBy((=*=),
        constructionTypes.map(getTagLexeme <> getTermTag))
    counts := deduplicate(constructors.map(maybeCount).prune)
    if length(names) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? throwError("Type error: invalid cases", tag)
    indices := constructors.map(maybeIndex).prune
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)

    # note: all schemes should have the same universals
    universals := getUniversals(safeHead(constructorSchemes) ??
        throwError("Type error: invalid cases", tag))
    returnType := MetaVariable(tag, 0)

    constructionType := safeHead(constructionTypes) ??
        throwError("Type error: invalid cases", tag)
    objectType := constructObjectType(veil(tag), constructorTypes, returnType)
    # note: the metsvariables in the two types must be instantiated together
    # so we need a new instantiation method that merges the universals and
    # instantiates two types with the same universals.
    PolarAnnotation(Scheme(universals, constructionType),
        Scheme([returnType], objectType))


define buildCaseAnnotation(tag, constructorNames, stack)
    with constructorNames.map(getLexeme).map(findDefiniens(stack)).sequence as
            Just(constructors)
        with constructors.map(maybeConstructorScheme).sequence as
                Just(constructorSchemes)
            Just(constructCaseAnnotation(tag, constructors, constructorSchemes))
        Void
    Void


define getNumeralType(stack)
    tag := renameTag(noTag, "#NATURAL#", NOFIX)
    fallback := Construction(tag, [])    # in case naturals are not defined
    with findDefiniens(stack, "0") as Just(constructor)
        with maybeConstructorScheme(constructor) as Just(scheme)
            getType(scheme)
        fallback
    fallback


define getAnnotation(node)
    with node as Juxtaposition(_, left, right)
        with left as Juxtaposition(_, left', _)
            if isThisName(left', ":")
                right
            syntaxError("missing annotation", node)
        syntaxError("missing annotation", node)
    syntaxError("missing annotation", node)


define bind(level, stack, node)
    match node
        case Reference(tag, debruijn)
            if debruijn = 0
                bindName(level, stack, tag)
            Variable(tag, debruijn)
        case Arrow(tag, arrowType, constructorNames, parameter, body)
            with arrowType as DoubleArrow
                parameterTerm := bind(level, stack, parameter)
                bodyTerm := bind(level, stack, body)
                Implication(tag, parameterTerm, bodyTerm)
            stack' := stack.pushParameter(parameter, level, Void)
            bodyTerm := bind(up level, stack', body)
            if isNil(constructorNames)
                Abstraction(getTag(parameter), NoConstraint, bodyTerm)
            with buildCaseAnnotation(tag, constructorNames, stack) as
                    Just(annotation)
                Abstraction(getTag(parameter), annotation, bodyTerm)
            syntaxError("invalid constructors", node)
        case Juxtaposition(tag, left, right)
            Application(tag, False,
                bind(level, stack, left), bind(level, stack, right))
        case Let(tag, name, value, scope)
            valueTerm := bind(level, stack, value)
            stack' := stack.pushParameter(name, level, Just(value))
            scopeTerm := bind(up level, stack', scope)
            abstraction := Abstraction(getTag(name), NoConstraint, scopeTerm)
            Application(tag, True, abstraction, valueTerm)
        case Number(tag, value)
            Numeral(tag, getNumeralType(stack), value)
        case Operator(_, _, _)
            abort "internal error: Operator reached bind"
        case Definition(_, _, _, _)
            syntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            syntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            syntaxError("comma not inside brackets", node)
        case Section(_, _, _)
            syntaxError("invalid section", node)
        case ADT(_, _)
            syntaxError("must appear on the right side of '::='", node)
        case ADT(tag, forms)
            # the parameters are already on the stack at this point
            implicit := Name(veil(tag))
            stack' := stack.pushParameter(implicit, level, Void)
            returnType := Variable(renameTag(tag, "r", NOFIX), 0)
            annotations := forms.map(getArguments).map(map(getAnnotation))
            boundAnnotations := annotations.map(map(bind(up level, stack')))
            boundTypes := boundAnnotations.map(
                fold(Implication(veil(tag)), returnType))
            bodyType := boundTypes.fold(Implication(veil(tag)), returnType)
            Implicit(getTermTag(returnType), Top(tag), bodyType)
        case Constructor(tag, parameterTypes, adtType, function, count, index)
            scheme := newConstructorScheme(tag, parameterTypes, adtType)
            with function as Number(_, value)
                Numeral(tag, getType(scheme), value)
            bind(level, stack, function).setAscription(scheme)
        case Deconstructor(tag, parameterTypes, adtType, function, count, index)
            scheme := newDeconstructorScheme(tag, parameterTypes, adtType)
            bind(level, stack, function).setAscription(scheme)
        case Accessor(tag, adtType, returnType, function, count, index)
            scheme := newAccessorScheme(tag, adtType, returnType)
            bind(level, stack, function).setAscription(scheme)
        case Null(_)
            abort "internal error: Null reached bind"


define bindAST(node)
    stack := [newDictionary([])]
    bind(0, stack, node)

#*
