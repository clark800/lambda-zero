#* bind.zero

define findDebruijnIndex(stack, tag, depth)
    stack.findIndices(=*= getTagLexeme(tag)).safeIndex(depth).mapJust(1 +)


define bindOperation(tag)
    maybe (arity, optimize) := getBuiltin(tag)
    just(Operation(tag, arity, optimize))


define bindName(stack, tag, depth)
    if isUnused(tag)
        parseError("cannot reference a symbol starting with underscore", tag)
    stack.findDebruijnIndex(tag, depth).mapJust(Variable(tag)) ??
        bindOperation(tag) ?? parseError("undefined symbol", tag)


define getADTFixity(root)
    if isReference(root) then getReferenceFixity(root) else NOFIX


define parseParameterType(node, context)
    # TODO: count parameter to ADTs is wrong
    if isName(node)
        if isUnderscore(getTag(node))
            BottomType(noTerm)        # todo: remove after implementing (=>)
        name := getLexeme(node)
        context.lookup(name) ??
            ADT(noTerm, name, getADTFixity(node), [], FreeType, 0, 0)
    root := getHead(node)
    name := getLexeme(root)
    if context.hasKey(name)
        syntaxError("type variable not allowed in applicand position", node)
    parameterTypes := getArguments(node).map(`parseParameterType(context))
    ADT(noTerm, name, getADTFixity(root), parameterTypes, FreeType, 0, 0)


define parseADT(node, context, count, index)
    root := getHead(node)
    name := getLexeme(root)
    parameterTypes := getArguments(node).map(context.get <> getLexeme)
    fixity := getADTFixity(root)
    ADT(noTerm, name, fixity, parameterTypes, FreeType, count, index)


define buildContext(dataType)
    # context maps type variable names to type variables
    components := getArguments(dataType)
    if not components.all(isName)
        syntaxError("all components should be names", dataType)
    typeVariables := (0 .. length(components) - 1).map(TypeVariable(noTerm))
    newDictionary(zip(components.map(getLexeme), typeVariables))


define newConstructorType(term, parameterTypes, dataType, context, count, index)
    # todo: check that universals are not already defined and that all other
    # names are already defined; also make sure universal name is not the
    # same as the dataType name
    if isNil(parameterTypes)
        parseADT(dataType, context, count, index)
    parameterType := parseParameterType(head(parameterTypes), context)
    FunctionType(term, parameterType, newConstructorType(getBody(term),
        tail(parameterTypes), dataType, context, count, index))


define newConstructorScheme(term, parameterTypes, dataType, count, index)
    context := buildContext(dataType)
    universals := getValues(context)
    type := newConstructorType(term, parameterTypes,
        dataType, context, count, index)
    Scheme(universals, type)


define newAccessorScheme(term, dataType, returnType, count, index)
    context := buildContext(dataType)
    universals := getValues(context)
    type := FunctionType(term, parseADT(dataType, context, count, index),
        parseParameterType(returnType, context))
    Scheme(universals, type)


define bind(node, stack)
    match node
        case Reference(tag, debruijn, depth, fixity)
            if debruijn = 0
                stack.bindName(tag, depth)
            Variable(tag, debruijn)
        case Arrow(tag, _, constructors, parameter, body)
            indices := constructors.map(`bind(stack)).map(getDebruijnIndex)
            metadata := Metadata(Free, Free, indices)
            Abstraction(getTag(parameter), metadata,
                bind(body, getLexeme(parameter) :: stack))
        case Couple(tag, _, left, right)
            Application(tag, isLetCouple(node),
                bind(left, stack), bind(right, stack))
        case Number(tag, value)
            Numeral(renameTag(tag, "_"), value)
        case Operator(_, _, _)
            abort "internal error: Operator reached bind"
        case Definition(_, _, _, _)
            syntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            syntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            syntaxError("comma not inside brackets", node)
        case Section(_, _, _)
            syntaxError("invalid section", node)
        case SetBuilder(_, _)
            syntaxError("must appear on the right side of '::='", node)
        case Constructor(tag, parameterTypes, dataType, body, count, index)
            term := bind(body, stack)
            scheme := newConstructorScheme(term, parameterTypes,
                dataType, count, index)
            metadata := Metadata(Free, scheme, [])
            Abstraction(getTermTag(term), metadata, getBody(term))
        case Accessor(tag, dataType, returnType, body, count, index)
            term := bind(body, stack)
            scheme := newAccessorScheme(term, dataType, returnType,
                count, index)
            metadata := Metadata(Free, scheme, [])
            Abstraction(getTermTag(term), metadata, getBody(term))
        case Null(_)
            abort "internal error: Null reached bind"

#*
