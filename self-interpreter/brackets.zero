#* brackets.zero

define applyToCommaList(tag, base, arguments)
    with arguments as CommaPair(_, left, right)
        Juxtaposition(tag, applyToCommaList(tag, base, left), right)
    Juxtaposition(tag, base, arguments)

define getCommaListSize(commaList)
    with commaList as CommaPair(_, left, _)
        getCommaListSize(left) + 1
    1

define newTuple(tag, commaList)
    n := getCommaListSize(commaList)
    lexeme := repeat(',').take(n -- 1)
    constructor := Name(renameTag(tag, lexeme, NOFIX))
    applyToCommaList(tag, constructor, commaList)

define getCommaListElements(commaList)
    if isNull(commaList) then []
    with commaList as CommaPair(_, left, right)
        getCommaListElements(left) ++ [right]
    [commaList]

define reduceUnmatched(open, _left, _right)
    syntaxError("missing close for", open)

define reduceParentheses(open, function, contents)
    if not isThisOperator(open, "(")
        syntaxError("missing close for", open)
    tag := getTag(open)
    if isNull(contents)
        unit := Name(renameTag(tag, "()", NOFIX))
        if isNull(function)
            unit
        Juxtaposition(tag, function, unit)
    if isDefinition(contents)
        syntaxError("missing scope for definition", contents)
    contents' := if isSection(contents) then
        wrapSection(tag, contents) else contents
    if not isNull(function)
        applyToCommaList(tag, function, contents')
    if isCommaPair(contents')
        newTuple(tag, contents')
    if isArrow(contents')
        lockArrow(contents')
    with contents' as Juxtaposition(_, left, right)
        Juxtaposition(tag, left, right)
    contents'

define createList(tag, commaList, list)
    with commaList as CommaPair(_, left, right)
        createList(tag, left, prependList(tag, right, list))
    prependList(tag, commaList, list)

define reduceSquare(open, left, contents)
    if not isThisOperator(open, "[")
        syntaxError("missing close for", open)
    tag := getTag(open)
    if isNull(contents)
        if isNull(left)
            newNil(tag)
        syntaxError("missing argument to", open)
    if not isNull(left)
        n := getCommaListSize(contents)
        constructor := Name(renameTag(tag, repeat('[').take(n), NOFIX))
        applyToCommaList(tag, Juxtaposition(tag, constructor, left), contents)
    createList(tag, contents, newNil(tag))

define reduceCurly(open, left, patterns)
    if not isNull(left)
        syntaxError("missing space before", open)
    if not isThisOperator(open, "{")
        syntaxError("missing close for", open)
    SetBuilder(getTag(open), getCommaListElements(patterns))

define reduceEOF(open, left, contents)
    if not isNull(left)
        syntaxError("invalid syntax", open)
    if not isEOF(open)
        syntaxError("missing close for", open)
    contents

define shiftOpen(state, open)
    state' := reduceLeft(state, open)
    State(open :: getStack(state'), getOperators(state'))

define isOpenOperator(operator)
    with operator as Operator(_, _, syntax)
        getFixity(syntax) = OPENFIX
    False

define pushBracket(stack, open, close, contents)
    with stack as left :: stack'
        if not isOperator(left)
            reduceBracket(open, close, left, contents) :: stack'
        reduceBracket(open, close, Null(getTag(open)), contents) :: stack
    [reduceBracket(open, close, Null(getTag(open)), contents)]

define shiftClose'(state, close)
    stack := getStack(state)
    with stack as contents :: stack'
        if isEOF(contents)
            syntaxError("missing open for", close)
        if isOpenOperator(contents)
            open := contents
            stack'' := pushBracket(stack', open, close, Null(getTag(open)))
            State(stack'', getOperators(state))
        with stack' as open :: stack''
            if isEOF(open) and not isEOF(close)
                syntaxError("missing open for", close)
            if isOperator(contents)
                syntaxError("missing right operand for", contents)
            stack' := pushBracket(stack'', open, close, contents)
            State(stack', getOperators(state))
        syntaxError("missing open for", close)
    syntaxError("missing open for", close)


define preReduceOperator(operator, stack)
    with operator as Operator(tag, _, syntax)
        with stack as left :: stack'
            if isLeftPlaceholder(left)
                # bracketed infix operator
                Name(tag) :: stack'
            if isOpenOperator(left)
                # bracketed prefix operators
                if isThisOperator(operator, "(+)")
                    Name(renameTag(tag, "+", INFIX)) :: stack
                if isThisOperator(operator, "(-)")
                    Name(renameTag(tag, "-", INFIX)) :: stack
                Name(tag) :: stack
            fixity := getFixity(syntax)
            if fixity = INFIX or fixity = PREFIX
                newRightPlaceholder(tag) :: operator :: stack   # LeftSection
            operator :: stack
        operator :: stack
    operator :: stack


define preReduce(stack)
    with stack as top :: stack'
        if isOperator(top) and not isSpecial(top)
            preReduceOperator(top, stack')
        stack
    stack


define shiftClose(state, close)
    stack := erase(erase(erase(getStack(state), " "), "\n"), ";")
    stack' := if isEOF(close) then stack else preReduce(stack)
    state' := reduceLeft(State(stack', getOperators(state)), close)
    shiftClose'(state', close)

#*
