#* brackets.zero

define applyToCommaList(tag, base, arguments)
    if not isCommaPair(arguments)
        Juxtaposition(tag, base, arguments)
    Juxtaposition(tag, applyToCommaList(tag, base,
        getCommaLeft(arguments)), getCommaRight(arguments))

define getCommaListSize(commaList)
    if not isCommaPair(commaList)
        1
    getCommaListSize(getCommaLeft(commaList)) + 1

define newTuple(tag, commaList)
    n := getCommaListSize(commaList)
    lexeme := repeat(',').take(n -- 1)
    constructor := Name(renameTag(tag, lexeme))
    applyToCommaList(tag, constructor, commaList)

define getCommaListElements(commaList)
    if isNull(commaList) then []
    if not isCommaPair(commaList) then [commaList]
    getCommaListElements(getCommaLeft(commaList)) ++ [getCommaRight(commaList)]

define reduceUnmatched(open, _left, _right)
    syntaxError("missing close for", open)

define reduceParentheses(open, function, contents)
    if not isThisOperator(open, "(")
        syntaxError("missing close for", open)
    tag := getTag(open)
    if isNull(contents)
        unit := Name(renameTag(tag, "()"))
        if isNull(function)
            unit
        Juxtaposition(tag, function, unit)
    if isDefinition(contents)
        syntaxError("missing scope for definition", contents)
    contents' := if isSection(contents) then
        wrapSection(tag, contents) else contents
    if not isNull(function)
        applyToCommaList(tag, function, contents')
    if isCommaPair(contents')
        newTuple(tag, contents')
    if isArrow(contents')
        lockArrow(contents')
    if isJuxtaposition(contents')
        Juxtaposition(tag, getLeft(contents'), getRight(contents'))
    contents'

define createList(tag, commaList, list)
    if not isCommaPair(commaList)
        prependList(tag, commaList, list)
    createList(tag, getCommaLeft(commaList),
        prependList(tag, getCommaRight(commaList), list))

define reduceSquare(open, left, contents)
    if not isThisOperator(open, "[")
        syntaxError("missing close for", open)
    tag := getTag(open)
    if isNull(contents)
        if isNull(left)
            newNil(tag)
        syntaxError("missing argument to", open)
    if not isNull(left)
        n := getCommaListSize(contents)
        constructor := Name(renameTag(tag, repeat('[').take(n)))
        applyToCommaList(tag, Juxtaposition(tag, constructor, left), contents)
    createList(tag, contents, newNil(tag))

define reduceCurly(open, left, patterns)
    if not isNull(left)
        syntaxError("missing space before", open)
    if not isThisOperator(open, "{")
        syntaxError("missing close for", open)
    SetBuilder(getTag(open), getCommaListElements(patterns))

define reduceEOF(open, left, contents)
    if not isNull(left)
        syntaxError("invalid syntax", open)
    if not isEOF(open)
        syntaxError("missing close for", open)
    contents

define shiftOpen(state, open)
    state' := reduceLeft(state, open)
    State(open :: getStack(state'), getOperators(state'))

define isOpenOperator(operator)
    isOperator(operator) and getFixity(getSyntax(operator)) = OPENFIX

define pushBracket(stack, open, close, contents)
    with stack as left :: stack'
        if not isOperator(left)
            reduceBracket(open, close, left, contents) :: stack'
        reduceBracket(open, close, Null(getTag(open)), contents) :: stack
    [reduceBracket(open, close, Null(getTag(open)), contents)]

define shiftClose'(state, close)
    stack := getStack(state)
    with stack as contents :: stack'
        if isEOF(contents)
            syntaxError("missing open for", close)
        if isOpenOperator(contents)
            open := contents
            stack'' := pushBracket(stack', open, close, Null(getTag(open)))
            State(stack'', getOperators(state))
        with stack' as open :: stack''
            if isEOF(open) and not isEOF(close)
                syntaxError("missing open for", close)
            if isOperator(contents)
                syntaxError("missing right operand for", contents)
            stack' := pushBracket(stack'', open, close, contents)
            State(stack', getOperators(state))
        syntaxError("missing open for", close)
    syntaxError("missing open for", close)


define preReduceOperator(operator, stack)
    tag := getTag(operator)
    with stack as left :: stack'
        if isLeftPlaceholder(left)
            # bracketed infix operator
            OperatorName(tag, INFIX) :: stack'
        if isOpenOperator(left)
            # bracketed prefix operators
            if isThisOperator(operator, "(+)")
                OperatorName(renameTag(tag, "+"), INFIX) :: stack
            if isThisOperator(operator, "(-)")
                OperatorName(renameTag(tag, "-"), INFIX) :: stack
            OperatorName(tag, PREFIX) :: stack
        fixity := getFixity(getSyntax(operator))
        if fixity = INFIX or fixity = PREFIX
            newRightPlaceholder(tag) :: operator :: stack   # LeftSection
        operator :: stack
    operator :: stack


define preReduce(stack)
    with stack as top :: stack'
        if isOperator(top) and not isSpecial(top)
            preReduceOperator(top, stack')
        stack
    stack


define shiftClose(state, close)
    stack := erase(erase(erase(getStack(state), " "), "\n"), ";")
    stack' := if isEOF(close) then stack else preReduce(stack)
    state' := reduceLeft(State(stack', getOperators(state)), close)
    shiftClose'(state', close)

#*
