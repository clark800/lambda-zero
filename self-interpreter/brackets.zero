#* brackets.zero

define isCommaList(node)
    isApplication(node) and getLexeme(node) =*= ","

define applyToCommaList(tag, base, arguments)
    if not isCommaList(arguments)
        newApplication(tag, base, arguments)
    newApplication(tag, applyToCommaList(tag, base,
        getLeft(arguments)), getRight(arguments))

define getCommaListSize(commaList)
    if not isCommaList(commaList)
        1
    getCommaListSize(getLeft(commaList)) + 1

define newTuple(tag, commaList)
    n := getCommaListSize(commaList)
    lexeme := repeat(',').take(n - 1)
    constructor := newName(Tag(lexeme, getTagLocation(tag)))
    applyToCommaList(tag, constructor, commaList)

define getCommaListElements(commaList)
    if not isCommaList(commaList)
        [commaList]
    getCommaListElements(getLeft(commaList)) ++ [getRight(commaList)]

define reduceUnmatched(open, _left, _right)
    syntaxError("missing close for", open)

define newSection(tag, name, body)
    newLambda(tag, newName(renameTag(tag, name)), body)

define createSection(tag, contents)
    if isThisLexeme(contents, ".*.")
        newSection(tag, ".*", newSection(tag, "*.", contents))
    if isLeaf(getLeft(contents))
        getLeft(contents)       # parenthesized postfix operator
    newSection(tag, getLexeme(contents), contents)

define reduceParentheses(open, function, contents)
    if not isThisSymbol(open, "(")
        syntaxError("missing close for", open)
    tag := getTag(open)
    if isNull(contents)
        unit := newName(renameTag(tag, "()"))
        if isNull(function)
            unit
        newApplication(tag, function, unit)
    contents' := if isSection(contents) then
        createSection(tag, contents) else contents
    if not isNull(function)
        applyToCommaList(tag, function, contents')
    if isCommaList(contents')
        newTuple(tag, contents')
    if not isLeaf(contents')
        contents'.setTag(tag)
    contents'

define createList(tag, commaList, list)
    if not isCommaList(commaList)
        prependList(tag, commaList, list)
    createList(tag, getLeft(commaList),
        prependList(tag, getRight(commaList), list))

define reduceSquare(open, left, contents)
    if not isThisSymbol(open, "[")
        syntaxError("missing close for", open)
    tag := getTag(open)
    if isNull(contents)
        if isNull(left)
            newNil(tag)
        syntaxError("missing argument to", open)
    if isSection(contents)
        syntaxError("invalid section", open)
    if not isNull(left)
        n := getCommaListSize(contents)
        constructor := newName(renameTag(tag, repeat('[').take(n)))
        applyToCommaList(tag, newApplication(tag, constructor, left), contents)
    createList(tag, contents, newNil(tag))

define reduceCurly(open, left, patterns)
    if not isNull(left)
        syntaxError("missing space before", open)
    if not isThisSymbol(open, "{")
        syntaxError("missing close for", open)
    if isNull(patterns)
        newName(renameTag(getTag(open), "{}"))
    if isSection(patterns)
        syntaxError("invalid section", open)
    newTuple(getTag(open), patterns)

define reduceEOF(open, left, contents)
    if not isNull(left)
        syntaxError("invalid syntax", open)
    if not isEOF(open)
        syntaxError("missing close for", open)
    if isCommaList(contents)
        syntaxError("comma not inside brackets", contents)
    contents

define shiftOpen(state, open)
    state' := reduceLeft(state, open)
    State(open :: getStack(state'), getOperators(state'))

define shiftOpenCurly(state, open)
    top := head(getStack(state))
    if not isThisSymbol(top, "::=") and not isThisSymbol(top, "â©´")
        syntaxError("must appear on the right side of '::='", open)
    shiftOpen(state, open)

define isOpenOperator(operator)
    isOperator(operator) and getFixity(getSyntax(operator)) = OPENFIX

define pushBracket(stack, open, close, contents)
    if isEOF(open) or isOperator(stack[0])
        reduceBracket(open, close, NULL, contents) :: stack
    reduceBracket(open, close, stack[0], contents) :: tail(stack)

define shiftClose'(state, close)
    stack := getStack(state)
    if isEOF(stack[0])
        syntaxError("missing open for", close)
    if isOpenOperator(stack[0])
        stack' := pushBracket(tail(stack), stack[0], close, NULL)
        State(stack', getOperators(state))
    if isEOF(stack[1]) and not isEOF(close)
        syntaxError("missing open for", close)
    if isOperator(stack[0])
        syntaxError("missing right operand for", stack[0])
    stack' := pushBracket(stack.drop(2), stack[1], close, stack[0])
    State(stack', getOperators(state))

define preReduce(stack)
    top := head(stack)
    if isOperator(top) and not isSpecial(top)
        if isThisSymbol(stack[1], ".*")
            # bracketed infix operator
            convertOperator(getTag(top)) :: tail(tail(stack))
        if isOpenOperator(stack[1])
            # bracketed prefix operators
            if isThisSymbol(top, "(+)")
                convertOperator(renameTag(getTag(top), "+")) :: tail(stack)
            if isThisSymbol(top, "(-)")
                convertOperator(renameTag(getTag(top), "-")) :: tail(stack)
            convertOperator(getTag(top)) :: tail(stack)
        fixity := getFixity(getSyntax(top))
        if fixity = INFIX or fixity = PREFIX
            newName(renameTag(getTag(top), "*.")) :: stack  # section
        stack
    stack

define shiftClose(state, close)
    stack := erase(erase(erase(getStack(state), " "), "\n"), ";")
    stack' := if isEOF(close) then stack else preReduce(stack)
    state' := reduceLeft(State(stack', getOperators(state)), close)
    shiftClose'(state', close)

#*
