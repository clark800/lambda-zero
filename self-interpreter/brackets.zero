#* brackets.zero

define applyToCommaList(tag, base, arguments)
    if not isCommaPair(arguments)
        Juxtaposition(tag, base, arguments)
    Juxtaposition(tag, applyToCommaList(tag, base,
        getCommaLeft(arguments)), getCommaRight(arguments))

define getCommaListSize(commaList)
    if not isCommaPair(commaList)
        1
    getCommaListSize(getCommaLeft(commaList)) + 1

define newTuple(tag, commaList)
    n := getCommaListSize(commaList)
    lexeme := repeat(',').take(n - 1)
    constructor := Name(renameTag(tag, lexeme), 0)
    applyToCommaList(tag, constructor, commaList)

define getCommaListElements(commaList)
    if isNull(commaList) then []
    if not isCommaPair(commaList) then [commaList]
    getCommaListElements(getCommaLeft(commaList)) ++ [getCommaRight(commaList)]

define reduceUnmatched(open, _left, _right)
    syntaxError("missing close for", open)

define reduceParentheses(open, function, contents)
    if not isThisOperator(open, "(")
        syntaxError("missing close for", open)
    tag := getTag(open)
    if isNull(contents)
        unit := Name(renameTag(tag, "()"), 0)
        if isNull(function)
            unit
        Juxtaposition(tag, function, unit)
    if isDefinition(contents)
        syntaxError("missing scope for definition", contents)
    contents' := if isSection(contents) then
        wrapSection(tag, contents) else contents
    if not isNull(function)
        applyToCommaList(tag, function, contents')
    if isCommaPair(contents')
        newTuple(tag, contents')
    if isJuxtaposition(contents')
        Juxtaposition(tag, getLeft(contents'), getRight(contents'))
    contents'

define createList(tag, commaList, list)
    if not isCommaPair(commaList)
        prependList(tag, commaList, list)
    createList(tag, getCommaLeft(commaList),
        prependList(tag, getCommaRight(commaList), list))

define reduceSquare(open, left, contents)
    if not isThisOperator(open, "[")
        syntaxError("missing close for", open)
    tag := getTag(open)
    if isNull(contents)
        if isNull(left)
            newNil(tag)
        syntaxError("missing argument to", open)
    if not isNull(left)
        n := getCommaListSize(contents)
        constructor := Name(renameTag(tag, repeat('[').take(n)), 0)
        applyToCommaList(tag, Juxtaposition(tag, constructor, left), contents)
    createList(tag, contents, newNil(tag))

define reduceCurly(open, left, patterns)
    if not isNull(left)
        syntaxError("missing space before", open)
    if not isThisOperator(open, "{")
        syntaxError("missing close for", open)
    SetBuilder(getTag(open), getCommaListElements(patterns))

define reduceEOF(open, left, contents)
    if not isNull(left)
        syntaxError("invalid syntax", open)
    if not isEOF(open)
        syntaxError("missing close for", open)
    contents

define shiftOpen(state, open)
    state' := reduceLeft(state, open)
    State(open :: getStack(state'), getOperators(state'))

define isOpenOperator(operator)
    isOperator(operator) and getFixity(getSyntax(operator)) = OPENFIX

define pushBracket(stack, open, close, contents)
    if isEOF(open) or isOperator(stack[0])
        reduceBracket(open, close, Null(getTag(open)), contents) :: stack
    reduceBracket(open, close, stack[0], contents) :: tail(stack)

define shiftClose'(state, close)
    stack := getStack(state)
    if isEOF(stack[0])
        syntaxError("missing open for", close)
    if isOpenOperator(stack[0])
        open := stack[0]
        stack' := pushBracket(tail(stack), open, close, Null(getTag(open)))
        State(stack', getOperators(state))
    if isEOF(stack[1]) and not isEOF(close)
        syntaxError("missing open for", close)
    if isOperator(stack[0])
        syntaxError("missing right operand for", stack[0])
    stack' := pushBracket(stack.drop(2), stack[1], close, stack[0])
    State(stack', getOperators(state))

define preReduce(stack)
    top := head(stack)
    if isOperator(top) and not isSpecial(top)
        if isLeftPlaceholder(stack[1])
            # bracketed infix operator
            Name(getTag(top), 0) :: tail(tail(stack))
        if isOpenOperator(stack[1])
            # bracketed prefix operators
            if isThisOperator(top, "(+)")
                Name(renameTag(getTag(top), "+"), 0) :: tail(stack)
            if isThisOperator(top, "(-)")
                Name(renameTag(getTag(top), "-"), 0) :: tail(stack)
            Name(getTag(top), 0) :: tail(stack)
        fixity := getFixity(getSyntax(top))
        if fixity = INFIX or fixity = PREFIX
            newRightPlaceholder(getTag(top)) :: stack   # LeftSection
        stack
    stack

define shiftClose(state, close)
    stack := erase(erase(erase(getStack(state), " "), "\n"), ";")
    stack' := if isEOF(close) then stack else preReduce(stack)
    state' := reduceLeft(State(stack', getOperators(state)), close)
    shiftClose'(state', close)

#*
