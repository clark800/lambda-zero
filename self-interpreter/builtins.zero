#* builtins.zero

define getBuiltin(tag)
    tag' := veil(tag)
    maxInteger := 9223372036854775807

    define checkNatural(term)
        maybeNatural(term) ?? runtimeError("expected numeric argument to", tag)

    define newBoolean(b)
        metadata := Metadata(Void, Void, [])
        Abstraction(tag', metadata, Abstraction(tag', metadata,
                Variable(tag', if b then 1 else 2)))

    define compute(f, left, right)
        f(checkNatural(getTerm(left)), checkNatural(getTerm(right)))

    define makeUnaryBuiltin(f, evaluate, arguments)
        with arguments as argument :: arguments'
            argument' := evaluate(argument)
            Closure(Numeral(tag', f(checkNatural(getTerm(argument')))), [])
        runtimeError("missing argument to", tag)

    define makeBinaryBuiltin(constructor, f, evaluate, arguments)
        with arguments as left :: arguments'
            with arguments' as right :: _
                left' := evaluate(left)
                right' := evaluate(right)
                Closure(constructor(compute(f, left', right')), [])
            runtimeError("missing argument to", tag)
        runtimeError("missing argument to", tag)

    define makeNaturalBuiltin(f, evaluate, arguments)
        makeBinaryBuiltin(Numeral(tag'), f, evaluate, arguments)

    define makeComparisonBuiltin(f, evaluate, arguments)
        makeBinaryBuiltin(newBoolean, f, evaluate, arguments)

    define addBuiltin(left, right)
        if left > maxInteger -- right
            runtimeError("overflow in", tag)
        left + right

    define monusBuiltin(left, right)
        left -- right

    define multiplyBuiltin(left, right)
        if right =/= 0 and left > maxInteger // right
            runtimeError("overflow in", tag)
        left * right

    define divideBuiltin(left, right)
        left // right

    define moduloBuiltin(left, right)
        left % right

    define incrementBuiltin(argument)
        if argument >= maxInteger
            runtimeError("overflow in", tag)
        argument + 1

    define abortBuiltin(evaluate, arguments)
        with arguments as argument :: _
            message := serializeString(evaluate, argument) ??
                runtimeError("expected string argument to", tag)
            abort message
        runtimeError("missing argument to", tag)

    builtins := newDictionary([
        ("+", (2, makeNaturalBuiltin(addBuiltin))),
        ("--", (2, makeNaturalBuiltin(monusBuiltin))),
        ("*", (2, makeNaturalBuiltin(multiplyBuiltin))),
        ("//", (2, makeNaturalBuiltin(divideBuiltin))),
        ("%", (2, makeNaturalBuiltin(moduloBuiltin))),
        ("=", (2, makeComparisonBuiltin(=))),
        ("=/=", (2, makeComparisonBuiltin(=/=))),
        ("<", (2, makeComparisonBuiltin(<))),
        (">", (2, makeComparisonBuiltin(>))),
        ("<=", (2, makeComparisonBuiltin(<=))),
        (">=", (2, makeComparisonBuiltin(>=))),
        ("abort", (1, abortBuiltin)),
        ("(increment)", (1, makeUnaryBuiltin(incrementBuiltin))),
        ("(undefined)", (0, closure -> (abort "undefined")))
    ])

    builtins.lookup(getTagLexeme(tag))

#*
