#* builtins.zero

define getBuiltin(tag)
    tag' := renameTag(tag, "_")
    maxInteger := 9223372036854775807

    define checkNatural(term)
        maybeNatural(term) ? runtimeError("expected numeric argument to", tag)

    define newBoolean(b)
        Abstraction(tag', Abstraction(tag', Variable(tag', if b then 1 else 2)))

    define compute(f, left, right)
        f(checkNatural(getTerm(left)), checkNatural(getTerm(right)))

    define makeUnaryBuiltin(f, evaluate, arguments)
        if length(arguments) < 1
            runtimeError("missing argument to", tag)
        argument := evaluate(arguments[0])
        Closure(Numeral(tag', f(checkNatural(getTerm(argument)))), [])

    define makeNaturalBuiltin(f, evaluate, arguments)
        if length(arguments) < 2
            runtimeError("missing argument to", tag)
        left := evaluate(arguments[0])
        right := evaluate(arguments[1])
        Closure(Numeral(tag', f.compute(left, right)), [])

    define makeComparisonBuiltin(f, evaluate, arguments)
        if length(arguments) < 2
            runtimeError("missing argument to", tag)
        left := evaluate(arguments[0])
        right := evaluate(arguments[1])
        Closure(newBoolean(f.compute(left, right)), [])

    define addBuiltin(left, right)
        if left > maxInteger - right
            runtimeError("overflow in", tag)
        left + right

    define subtractBuiltin(left, right)
        if right > left
            runtimeError("underflow in", tag)
        left - right

    define multiplyBuiltin(left, right)
        if right =/= 0 and left > maxInteger // right
            runtimeError("overflow in", tag)
        left * right

    define divideBuiltin(left, right)
        if right = 0
            runtimeError("divide by zero in", tag)
        left // right

    define moduloBuiltin(left, right)
        if right = 0
            left
        left % right

    define upBuiltin(argument)
        if argument >= maxInteger
            runtimeError("overflow in", tag)
        argument + 1

    define errorBuiltin(evaluate, arguments)
        if length(arguments) < 1
            runtimeError("missing argument to", tag)
        closure := head(arguments)
        message := serializeString(evaluate, closure) ?
            runtimeError("expected string argument to", tag)
        error(message)

    builtins := newDictionary([
        ("+", (2, makeNaturalBuiltin(addBuiltin))),
        ("-", (2, makeNaturalBuiltin(subtractBuiltin))),
        ("*", (2, makeNaturalBuiltin(multiplyBuiltin))),
        ("//", (2, makeNaturalBuiltin(divideBuiltin))),
        ("%", (2, makeNaturalBuiltin(moduloBuiltin))),
        ("=", (2, makeComparisonBuiltin(=))),
        ("=/=", (2, makeComparisonBuiltin(=/=))),
        ("<", (2, makeComparisonBuiltin(<))),
        (">", (2, makeComparisonBuiltin(>))),
        ("<=", (2, makeComparisonBuiltin(<=))),
        (">=", (2, makeComparisonBuiltin(>=))),
        ("up", (1, makeUnaryBuiltin(upBuiltin))),
        ("error", (1, errorBuiltin)),
        ("(undefined)", (0, closure -> undefined))
    ])

    builtins.lookup(getTagLexeme(tag))

#*
