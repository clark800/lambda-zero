#* builtins.zero

def getBuiltin(tag)
    tag' := veil(tag)
    typeN := Variable(renameTag(noTag, "#NATURAL#", NOFIX), 0)
    maxInteger := 9223372036854775807


    def checkNatural(term)
        maybeNatural(term) ?? runtimeError("expected numeric argument to", tag)


    def newBoolean(b)
        FreeFunction(tag', FreeFunction(tag',
            Variable(tag', if b then 1 else 2)))


    def compute(f, left, right)
        f(checkNatural(getTerm(left)), checkNatural(getTerm(right)))


    def makeUnaryBuiltin(f, evaluate, arguments)
        with arguments as argument :: arguments'
            argument' := evaluate(argument)
            Closure(Numeral(tag', typeN,
                f(checkNatural(getTerm(argument')))), newArray([]))
        runtimeError("missing argument to", tag)


    def makeBinaryBuiltin(constructor, f, evaluate, arguments)
        with arguments as left :: arguments'
            with arguments' as right :: _
                left' := evaluate(left)
                right' := evaluate(right)
                Closure(constructor(compute(f, left', right')), newArray([]))
            runtimeError("missing argument to", tag)
        runtimeError("missing argument to", tag)


    def makeNaturalBuiltin(f, evaluate, arguments)
        makeBinaryBuiltin(Numeral(tag', typeN), f, evaluate, arguments)


    def makeComparisonBuiltin(f, evaluate, arguments)
        makeBinaryBuiltin(newBoolean, f, evaluate, arguments)


    def addBuiltin(left, right)
        if left > maxInteger -- right
            runtimeError("overflow in", tag)
        left + right


    def monusBuiltin(left, right)
        left -- right


    def multiplyBuiltin(left, right)
        if right =/= 0 and left > maxInteger // right
            runtimeError("overflow in", tag)
        left * right


    def divideBuiltin(left, right)
        left // right


    def moduloBuiltin(left, right)
        left % right


    def incrementBuiltin(argument)
        if argument >= maxInteger
            runtimeError("overflow in", tag)
        argument + 1


    def abortBuiltin(evaluate, arguments)
        with arguments as argument :: _
            message := serializeString(evaluate, argument) ??
                runtimeError("expected string argument to", tag)
            abort message
        runtimeError("missing argument to", tag)


    builtins := newDictionary([
        ("+", (2, makeNaturalBuiltin(addBuiltin))),
        ("--", (2, makeNaturalBuiltin(monusBuiltin))),
        ("*", (2, makeNaturalBuiltin(multiplyBuiltin))),
        ("//", (2, makeNaturalBuiltin(divideBuiltin))),
        ("%", (2, makeNaturalBuiltin(moduloBuiltin))),
        ("=", (2, makeComparisonBuiltin((=)))),
        ("=/=", (2, makeComparisonBuiltin((=/=)))),
        ("<", (2, makeComparisonBuiltin((<)))),
        (">", (2, makeComparisonBuiltin((>)))),
        ("<=", (2, makeComparisonBuiltin((<=)))),
        (">=", (2, makeComparisonBuiltin((>=)))),
        ("abort", (1, abortBuiltin)),
        ("(increment)", (1, makeUnaryBuiltin(incrementBuiltin))),
        ("(undefined)", (0, closure -> (abort "undefined")))
    ])

    builtins.lookup(getTagLexeme(tag))

#*
