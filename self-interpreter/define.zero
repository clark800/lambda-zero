#* define.zero

define getHead(node)
    if isJuxtaposition(node) then getHead(getLeft(node)) else node

define applyDefinition(tag, left, right, scope)
    Juxtaposition(tag, newPatternArrow(tag, left, scope), right)

define applyTryDefinition(tag, left, right, scope)
    Juxtaposition(tag, Juxtaposition(tag, Name(renameTag(tag, "??")),
        right), newPatternArrow(tag, left, scope))

define hasRecursiveCalls(node, name)
    if isName(node)
        getLexeme(node) =*= getLexeme(name)
    if isArrow(node)
        hasRecursiveCalls(getArrowRight(node), name)
    if isJuxtaposition(node)
        hasRecursiveCalls(getLeft(node), name) or
            hasRecursiveCalls(getRight(node), name)
    false

define transformRecursion(name, value)
    if not isName(name) or not hasRecursiveCalls(value, name)
        value
    tag := getTag(name)
    fix' := Name(renameTag(tag, "fix"))
    Juxtaposition(tag, fix', Arrow(tag, Name(tag), value))

define isTupleConstructor(node)
    isName(node) and not isNil(getLexeme(node)) and getLexeme(node)[0] = ','

define isTuple(node)
    if isJuxtaposition(node)
        isTuple(getLeft(node))
    isTupleConstructor(node)

define reduceDefine'(tag, operator, left, right)
    if isThisLexeme(left, "syntax") or isTuple(left)
        Definition(tag, left, right)
    (name, value) := getNameAndValue(newPatternArrow(tag), left, right)
    if not isName(name)
        syntaxError("invalid left hand side", operator)
    if isThisName(name, "main")
        applyDefinition(getTag(name), name, value, name)
    Definition(tag, name, transformRecursion(name, value))

define reduceDefine(operator, left, right)
    tag := getTag(operator)
    if isJuxtaposition(left) and isThisLexeme(left, "try")
        reduceDefine'(renameTag(tag, "try"), operator, getRight(left), right)
    reduceDefine'(renameTag(tag, ":="), operator, left, right)

define isValidConstructorParameter(parameter)
    isJuxtaposition(parameter) and isJuxtaposition(getLeft(parameter)) and
    isValidPattern(getRight(parameter)) and
    isName(getRight(getLeft(parameter))) and
    (isThisName(getLeft(getLeft(parameter)), ":") or
     isThisName(getLeft(getLeft(parameter)), "âˆˆ"))

define newGetterDefinition(tag, n, j, m, (parameter, k), scope)
    if not isValidConstructorParameter(parameter)
        syntaxError("invalid constructor parameter", parameter)
    name := getRight(getLeft(parameter))
    if isUnused(getTag(name))
        scope
    projector := newProjector(tag, m, k)
    undefined' := Name(renameTag(tag, "undefined"))
    arguments := (0 .. n - 1).map(q -> if q = j then projector else undefined)
    getter := Arrow(tag, Name(renameTag(tag, "_")),
        arguments.cascade(Juxtaposition(tag), newUnderscore(tag, 1)))
    applyDefinition(tag, name, getter, scope)

define newConstructorDefinition(tag, n, (pattern, j), scope)
    name := getHead(pattern)
    if not isName(name)
        syntaxError("invalid constructor name", name)
    parameters := getArguments(pattern)
    m := length(parameters)
    scope' := zip(parameters, naturals).fold(
        newGetterDefinition(tag, n, j, m), scope)
    base := newUnderscore(tag, n - j)
    arguments := reverse(n + 1 .. n + m).map(newUnderscore(tag))
    body := arguments.cascade(Juxtaposition(tag), base)
    constructor := ((Arrow(tag, Name(renameTag(tag, "_"))))^^(n + m))(body)
    applyDefinition(tag, name, constructor, scope')

define reduceADT(operator, left, right)
    tag := renameTag(getTag(operator), "::=")
    if not isValidPattern(left)
        syntaxError("invalid left hand side", operator)
    if not isThisLexeme(right, "{") and not isThisLexeme(right, "{}")
        syntaxError("ADT required to right of", operator)
    Definition(tag, left, right)

define applyADTDefinition(tag, left, right, scope)
    undefined' := Name(renameTag(tag, "undefined"))
    scope' := applyDefinition(tag, getHead(left), undefined', scope)
    constructors := getArguments(right)
    n := length(constructors)
    zip(constructors, naturals).fold(newConstructorDefinition(tag, n), scope')

#*
