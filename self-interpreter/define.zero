#* define.zero

define isTupleConstructor(node)
    isName(node) and getLexeme(node).startsWith(",")

define isTuple(node)
    if isJuxtaposition(node)
        isTuple(getLeft(node))
    isTupleConstructor(node)

define applyPlainDefinition(tag, name, value, scope)
    if isJuxtaposition(name) and isTuple(name)
        Juxtaposition(tag, newPatternArrow(name, scope), value)
    Let(tag, newPatternArrow(name, scope), value)

define applyMaybeDefinition(tag, name, value, scope)
    Juxtaposition(tag, Juxtaposition(tag, Name(renameTag(tag, "onJust")),
        newPatternArrow(name, scope)), value)

define applyTryDefinition(tag, name, value, scope)
    Juxtaposition(tag, Juxtaposition(tag, Name(renameTag(tag, "onRight")),
        newPatternArrow(name, scope)), value)

define transformRecursion(name, value)
    if not isName(name) or not isArrow(value) or not containsName(name, value)
        value
    tag := getTag(name)
    fix' := Name(renameTag(tag, "fix"))
    Juxtaposition(tag, fix', LockedArrow(Name(tag), value))

define isValidPattern(node)
    isName(node) or (isJuxtaposition(node) and
        isValidPattern(getLeft(node)) and isValidPattern(getRight(node)))

define isValidConstructorParameter(parameter)
    isJuxtaposition(parameter) and isJuxtaposition(getLeft(parameter)) and
    isValidPattern(getRight(parameter)) and
    isName(getRight(getLeft(parameter))) and
    (isThisName(getLeft(getLeft(parameter)), ":") or
     isThisName(getLeft(getLeft(parameter)), "âˆˆ"))

define newGetterDefinition(tag, dataType, n, j, m, (parameter, k), scope)
    if not isValidConstructorParameter(parameter)
        syntaxError("invalid constructor parameter", parameter)
    name := getRight(getLeft(parameter))
    if isUnused(getTag(name))
        scope
    projector := newProjector(tag, m, k)
    undefined' := Name(renameTag(tag, "(undefined)"))
    arguments := (0 .. n -- 1).map(q -> if q = j then projector else undefined')
    body := UnderscoreArrow(tag,
        arguments.cascade(Juxtaposition(tag), Underscore(tag, 1)))
    returnType := getRight(parameter)
    accessor := Accessor(tag, dataType, returnType, body, n, j + 1)
    applyPlainDefinition(tag, name, accessor, scope)

define readParameterTypes(form)
    if not isJuxtaposition(form) then []
    readParameterTypes(getLeft(form)) ++ [getRight(getRight(form))]

define newConstructorDefinition(tag, dataType, n, (form, j), scope)
    parameters := getArguments(form)
    m := length(parameters)
    scope' := zip(parameters, 0...).fold(
        newGetterDefinition(tag, dataType, n, j, m), scope)

    if isNumber(form) and getNumericValue(form) = 0
        zero := Name(renameTag(getTag(form), "0"))
        applyPlainDefinition(tag, zero, form, scope')
    if isJuxtaposition(form) and isThisName(getLeft(form), "up")
        name := getLeft(form)
        increment := Name(renameTag(getTag(name), "(increment)"))
        applyPlainDefinition(tag, name, increment, scope')

    name := getHead(form)
    if not isName(name)
        syntaxError("invalid constructor name", name)
    arguments := reverse(n + 1 .. n + m).map(Underscore(tag))
    base := arguments.cascade(Juxtaposition(tag), Underscore(tag, n -- j))
    body := (UnderscoreArrow(tag)^<>(n + m))(base)
    parameterTypes := readParameterTypes(form)
    constructor := Constructor(tag, parameterTypes, dataType, body, n, j + 1)
    applyPlainDefinition(tag, name, constructor, scope')


define newFallbackCase(tag, m)
    fallback := Underscore(tag, m + 2)
    instance := Underscore(tag, m + 1)
    body := Juxtaposition(tag, fallback, instance)
    (1 .. m).cascade(b -> _ -> UnderscoreArrow(tag, b), body)


define newDeconstructorDefinition(tag, dataType, n, ms, (form, j), scope)
    reconstructor := Underscore(tag, 3)
    arguments := (1 .. n).map(k -> if k -- 1 = j then reconstructor else
        newFallbackCase(tag, ms.safeAt(k -- 1) ?? 0))
    body := arguments.cascade(Juxtaposition(tag), Underscore(tag, 1))
    function := UnderscoreArrow(tag, UnderscoreArrow(tag,
        UnderscoreArrow(tag, body)))
    parameterTypes := readParameterTypes(form)
    deconstructor := Deconstructor(tag, parameterTypes, dataType,
        function, n, j + 1)
    name := Name(addPrefix(getTag(getHead(form)), '@'))
    applyPlainDefinition(tag, name, deconstructor, scope)


define newConstructorDefinitions(tag, dataType, n, ms, formj, scope)
    scope' := newDeconstructorDefinition(tag, dataType, n, ms, formj, scope)
    newConstructorDefinition(tag, dataType, n, formj, scope')


define applyADTDefinition(tag, left, right, scope)
    forms := getForms(right)
    n := length(forms)
    ms := forms.map(length <> getArguments)
    scope' := zip(forms, 0...).fold(
        newConstructorDefinitions(tag, left, n, ms), scope)
    undefined' := Name(renameTag(tag, "(undefined)"))
    applyPlainDefinition(tag, getHead(left), undefined', scope')


define applyDefinition(definition, scope)
    tag := getTag(definition)
    name := getDefiniendum(definition)
    value := getDefiniens(definition)
    match getDefinitionType(definition)
        PlainDefinition -> applyPlainDefinition(tag, name, value, scope)
        MaybeDefinition -> applyMaybeDefinition(tag, name, value, scope)
        TryDefinition -> applyTryDefinition(tag, name, value, scope)
        SyntaxDefinition -> scope
        ADTDefinition -> applyADTDefinition(tag, name, value, scope)

define reduceDefine'(tag, definitionType, left, right)
    if isTuple(left) or isAsPattern(left)
        Definition(tag, definitionType, left, right)
    (name, value) := getNameAndValue(newPatternArrow, left, right)
    if not isName(name)
        parseError("invalid left hand side", tag)
    if isThisName(name, "main")
        applyPlainDefinition(tag, name, value, name)
    Definition(tag, definitionType, name, transformRecursion(name, value))

define reduceDefine(operator, left, right)
    tag := getTag(operator)
    if isDefinition(right)   # todo: remove after converting exceptions
        syntaxError("missing scope for definition", right)
    if isKeyphrase(left, "maybe")
        reduceDefine'(tag, MaybeDefinition, getRight(left), right)
    if isKeyphrase(left, "try")
        reduceDefine'(tag, TryDefinition, getRight(left), right)
    if isKeyphrase(left, "syntax")
        reduceDefine'(tag, SyntaxDefinition, getRight(left), right)
    reduceDefine'(tag, PlainDefinition, left, right)

define reduceADTDefine(operator, left, right)
    if not isValidPattern(left)
        syntaxError("invalid left hand side", operator)
    if not isSetBuilder(right)
        syntaxError("ADT required to right of", operator)
    Definition(getTag(operator), ADTDefinition, left, right)

#*
