--* define.zero

applyDefinition(tag, name, value, scope) :=
    newApplication(tag, reduceLambda(name, name, scope), value)

hasRecursiveCalls(node, name) := (
    if isLeaf(node)
        getLexeme(node) =*= getLexeme(name)
    hasRecursiveCalls(getLeft(node), name) \/
        hasRecursiveCalls(getRight(node), name)
)

transformRecursion(name, value) := (
    if not isSymbol(name) \/ not hasRecursiveCalls(value, name)
        value
    tag := getTag(name)
    newApplication(tag, newYCombinator(tag),
        newLambda(tag, newName(tag), value))
)

getNameAndValue(operator, left, right) := (
    if isNull(right)
        undefined                   -- force syntax errors
    if not isApplication(left)
        (left, right)
    getNameAndValue(operator, getLeft(left),
        reduceLambda(operator, getRight(left), right))
)

isTupleConstructor(node) := isSymbol(node) /\
    not isNil(getLexeme(node)) /\ getLexeme(node)[0] = ','

isTuple(node) := (
    if isApplication(node)
        isTuple(getLeft(node))
    isTupleConstructor(node)
)

reduceDefine(operator, left, right) := (
    tag := renameTag(getTag(operator), ":=")
    if isTuple(left)
        newDefinition(tag, left, right)
    (name, value) := getNameAndValue(operator, left, right)
    if isBuiltin(name)
        syntaxError("cannot define a builtin operator", name)
    if not isSymbol(name)
        syntaxError("invalid left hand side", operator)
    if isThisSymbol(name, "main")
        applyDefinition(getTag(name), name, value, name)
    newDefinition(tag, name, transformRecursion(name, value))
)

isValidConstructorParameter(parameter) :=
    isApplication(parameter) /\ isApplication(getLeft(parameter)) /\
    isValidPattern(getRight(parameter)) /\
    isSymbol(getRight(getLeft(parameter))) /\
    (isThisSymbol(getLeft(getLeft(parameter)), ":") \/
     isThisSymbol(getLeft(getLeft(parameter)), "âˆˆ"))

newGetterDefinition(tag, n, j, m, (parameter, k), scope) := (
    if not isValidConstructorParameter(parameter)
        syntaxError("invalid constructor parameter", parameter)
    name := getRight(getLeft(parameter))
    if isUnused(name)
        scope
    projector := newProjector(tag, m, k)
    undefined' := newName(renameTag(tag, "undefined"))
    arguments := (0 .. n - 1).map(q -> q = j ? projector || undefined)
    getter := newLambda(tag, newUnderscore(tag, 0),
        arguments.cascade(newApplication(tag), newUnderscore(tag, 1)))
    applyDefinition(tag, name, getter, scope)
)

newConstructorDefinition(tag, n, (pattern, j), scope) := (
    name := getHead(pattern)
    if not isSymbol(name)
        syntaxError("invalid constructor name", name)
    parameters := getArguments(pattern)
    m := length(parameters)
    scope' := zip(parameters, naturals).fold(
        newGetterDefinition(tag, n, j, m), scope)
    base := newUnderscore(tag, n - j)
    arguments := reverse(n + 1 .. n + m).map(newUnderscore(tag))
    body := arguments.cascade(newApplication(tag), base)
    constructor := ((newLambda(tag, newUnderscore(tag, 0)))^^(n + m))(body)
    applyDefinition(tag, name, constructor, scope')
)

reduceADT(operator, left, right) := (
    tag := renameTag(getTag(operator), "::=")
    if not isValidPattern(left)
        syntaxError("invalid left hand side", operator)
    if not isThisLexeme(right, "{") /\ not isThisLexeme(right, "{}")
        syntaxError("ADT required to right of", operator)
    newDefinition(tag, left, right)
)

applyADTDefinition(tag, left, right, scope) := (
    undefined' := newName(renameTag(tag, "undefined"))
    scope' := applyDefinition(tag, getHead(left), undefined', scope)
    constructors := getArguments(right)
    n := length(constructors)
    zip(constructors, naturals).fold(newConstructorDefinition(tag, n), scope')
)

--*
