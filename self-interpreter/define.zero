#* define.zero

define isTupleConstructor(node)
    isName(node) and getLexeme(node).startsWith(",")


define isTuple(node)
    with node as Juxtaposition(_, left, _)
        isTuple(left)
    isTupleConstructor(node)


define applyPlainDefinition(tag, name, value, scope)
    if isName(name)
        Let(tag, name, value, scope)
    Juxtaposition(tag, newPatternArrow(name, scope), value)


define applyMaybeDefinition(tag, name, value, scope)
    Juxtaposition(tag, Juxtaposition(tag, Name(renameTag(tag, "onJust", NOFIX)),
        newPatternArrow(name, scope)), value)


define applyTryDefinition(tag, name, value, scope)
    Juxtaposition(tag, Juxtaposition(tag,
        Name(renameTag(tag, "onRight", NOFIX)),
        newPatternArrow(name, scope)), value)


define applyFix(name, value)
    tag := getTag(name)
    fix' := Name(renameTag(tag, "fix", NOFIX))
    Juxtaposition(tag, fix', LockedArrow(name, value))


define transformRecursion(name, value)
    if not isName(name) or not isArrow(value) or not containsName(name, value)
        value
    applyFix(name, value)


define isValidPattern(node)
    if isName(node)
        True
    with node as Juxtaposition(_, left, right)
        isValidPattern(left) and isValidPattern(right)
    with node as Arrow(_, arrowType, _, left, right)
        with arrowType as DoubleArrow
            isValidPattern(left) and isValidPattern(right)
        False
    False


define isValidConstructorParameter(parameter)
    with parameter as Juxtaposition(_, left, right)
        if not isValidPattern(right)
            False
        with left as Juxtaposition(_, left', right')
            isName(right') and
                (isThisName(left', ":") or isThisName(left', "âˆˆ"))
        False
    False


define newGetterDefinition(tag, dataType, n, j, m, (parameter, k), scope)
    if not isValidConstructorParameter(parameter)
        syntaxError("invalid constructor parameter", parameter)
    with parameter as Juxtaposition(_, left, returnType)
        with left as Juxtaposition(_, _, name)
            if isUnused(getTag(name))
                scope
            projector := newProjector(tag, m, k)
            undefined' := Name(renameTag(tag, "(undefined)", NOFIX))
            arguments := (0 .. n -- 1).map(q ->
                if q = j then projector else undefined')
            body := UnderscoreArrow(tag,
                arguments.cascade(Juxtaposition(tag), Underscore(tag, 1)))
            accessor := Accessor(tag, dataType, returnType, body, n, j + 1)
            applyPlainDefinition(tag, name, accessor, scope)
        syntaxError("invalid constructor parameter", parameter)
    syntaxError("invalid constructor parameter", parameter)


define readParameterTypes(form)
    with form as Juxtaposition(_, left, right)
        with right as Juxtaposition(_, left', right')
            readParameterTypes(left) ++ [right']
        syntaxError("invalid form", form)
    []


define getConstructorBody(name, n, m, j)
    tag := getTag(name)
    with name as Number(tag, value)
        if value =/= 0
            syntaxError("invalid constructor name", name)
        Number(tag, 0)
    if not isName(name)
        syntaxError("invalid constructor name", name)
    if isThisName(name, "up")
        if m =/= 1
            syntaxError("expected one parameter to", name)
        Name(renameTag(tag, "(increment)", NOFIX))
    arguments := reverse(n + 1 .. n + m).map(Underscore(tag))
    base := arguments.cascade(Juxtaposition(tag), Underscore(tag, n -- j))
    (UnderscoreArrow(tag)^<>(n + m))(base)


define newConstructorDefinition(tag, dataType, n, (form, j), scope)
    parameters := getArguments(form)
    m := length(parameters)
    scope' := zip(parameters, 0...).fold(
        newGetterDefinition(tag, dataType, n, j, m), scope)
    name := getHead(form)
    body := getConstructorBody(name, n, m, j)
    if isNull(body)
        syntaxError("invalid constructor", name)   # force errors
    parameterTypes := readParameterTypes(form)
    constructor := Constructor(tag, parameterTypes, dataType, body, n, j + 1)
    applyPlainDefinition(tag, Name(getTag(name)), constructor, scope')


define newFallbackCase(tag, m)
    fallback := Underscore(tag, m + 2)
    instance := Underscore(tag, m + 1)
    body := Juxtaposition(tag, fallback, instance)
    (1 .. m).cascade(b -> _ -> UnderscoreArrow(tag, b), body)


define newDeconstructorDefinition(tag, dataType, n, ms, (form, j), scope)
    reconstructor := Underscore(tag, 3)
    arguments := (1 .. n).map(k -> if k -- 1 = j then reconstructor else
        newFallbackCase(tag, ms.safeAt(k -- 1) ?? 0))
    body := arguments.cascade(Juxtaposition(tag), Underscore(tag, 1))
    function := UnderscoreArrow(tag, UnderscoreArrow(tag,
        UnderscoreArrow(tag, body)))
    parameterTypes := readParameterTypes(form)
    deconstructor := Deconstructor(tag, parameterTypes, dataType,
        function, n, j + 1)
    name := Name(addPrefix(getTag(getHead(form)), '@'))
    applyPlainDefinition(tag, name, deconstructor, scope)


define newConstructorDefinitions(tag, dataType, n, ms, formj, scope)
    scope' := newDeconstructorDefinition(tag, dataType, n, ms, formj, scope)
    newConstructorDefinition(tag, dataType, n, formj, scope')


define applyADTDefinition(tag, left, right, scope)
    with right as SetBuilder(_, forms)
        n := length(forms)
        ms := forms.map(length <> getArguments)
        scope' := zip(forms, 0...).fold(
            newConstructorDefinitions(tag, left, n, ms), scope)
        name := getHead(left)
        parameters := getArguments(left)
        # todo: use the same method for parameters as with normal functions
        if not parameters.all(isName)
            syntaxError("parameters to type constructor must be names", name)
        value := parameters.fold(LockedArrow, ADT(getTag(name), forms))
        value' := if forms.any(containsName(name)) then
            applyFix(name, value) else value
        applyPlainDefinition(tag, name, value', scope')
    syntaxError("internal error", left)


define applyDefinition(definition, scope)
    with definition as Definition(tag, type, name, value)
        match type
            PlainDefinition -> applyPlainDefinition(tag, name, value, scope)
            MaybeDefinition -> applyMaybeDefinition(tag, name, value, scope)
            TryDefinition -> applyTryDefinition(tag, name, value, scope)
            SyntaxDefinition -> scope
            ADTDefinition -> applyADTDefinition(tag, name, value, scope)
    syntaxError("internal error", definition)


define reduceDefine'(tag, definitionType, left, right)
    if isTuple(left) or isAsPattern(left)
        Definition(tag, definitionType, left, right)
    (name, value) := getNameAndValue(newPatternArrow, left, right)
    if not isName(name)
        parseError("invalid left hand side", tag)
    if isThisName(name, "main")
        applyPlainDefinition(tag, name, value, name)
    Definition(tag, definitionType, name, transformRecursion(name, value))


define reduceDefine(operator, left, right)
    tag := getTag(operator)
    if isDefinition(right)   # todo: remove after converting exceptions
        syntaxError("missing scope for definition", right)
    with left as Juxtaposition(_, left', right')
        if isThisName(left', "maybe")
            reduceDefine'(tag, MaybeDefinition, right', right)
        if isThisName(left', "try")
            reduceDefine'(tag, TryDefinition, right', right)
        if isThisName(left', "syntax")
            reduceDefine'(tag, SyntaxDefinition, right', right)
        reduceDefine'(tag, PlainDefinition, left, right)
    reduceDefine'(tag, PlainDefinition, left, right)


define reduceADTDefine(operator, left, right)
    if not isValidPattern(left)
        syntaxError("invalid left hand side", operator)
    if not isSetBuilder(right)
        syntaxError("ADT required to right of", operator)
    Definition(getTag(operator), ADTDefinition, left, right)

#*
