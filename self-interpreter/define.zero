#* define.zero

define getHead(node)
    if isApplication(node) then getHead(getLeft(node)) else node

define applyDefinition(tag, name, value, scope)
    newApplication(tag, newPatternLambda(tag, name, scope), value)

define hasRecursiveCalls(node, name)
    if isLeaf(node)
        getLexeme(node) =*= getLexeme(name)
    hasRecursiveCalls(getLeft(node), name) or
        hasRecursiveCalls(getRight(node), name)

define transformRecursion(name, value)
    if not isSymbol(name) or not hasRecursiveCalls(value, name)
        value
    tag := getTag(name)
    newApplication(tag, newYCombinator(tag),
        newLambda(tag, newName(tag), value))

define isTupleConstructor(node)
    isSymbol(node) and not isNil(getLexeme(node)) and getLexeme(node)[0] = ','

define isTuple(node)
    if isApplication(node)
        isTuple(getLeft(node))
    isTupleConstructor(node)

define reduceDefine(operator, left, right)
    tag := renameTag(getTag(operator), ":=")
    if isThisLexeme(left, "syntax") or isTuple(left)
        newDefinition(tag, left, right)
    (name, value) := getNameAndValue(newPatternLambda(tag), left, right)
    if isBuiltin(name)
        syntaxError("cannot define a builtin operator", name)
    if not isSymbol(name)
        syntaxError("invalid left hand side", operator)
    if isThisSymbol(name, "main")
        applyDefinition(getTag(name), name, value, name)
    newDefinition(tag, name, transformRecursion(name, value))

define isValidConstructorParameter(parameter)
    isApplication(parameter) and isApplication(getLeft(parameter)) and
    isValidPattern(getRight(parameter)) and
    isSymbol(getRight(getLeft(parameter))) and
    (isThisSymbol(getLeft(getLeft(parameter)), ":") or
     isThisSymbol(getLeft(getLeft(parameter)), "âˆˆ"))

define newGetterDefinition(tag, n, j, m, (parameter, k), scope)
    if not isValidConstructorParameter(parameter)
        syntaxError("invalid constructor parameter", parameter)
    name := getRight(getLeft(parameter))
    if isUnused(name)
        scope
    projector := newProjector(tag, m, k)
    undefined' := newName(renameTag(tag, "undefined"))
    arguments := (0 .. n - 1).map(q -> if q = j then projector else undefined)
    getter := newLambda(tag, newUnderscore(tag, 0),
        arguments.cascade(newApplication(tag), newUnderscore(tag, 1)))
    applyDefinition(tag, name, getter, scope)

define newConstructorDefinition(tag, n, (pattern, j), scope)
    name := getHead(pattern)
    if not isSymbol(name)
        syntaxError("invalid constructor name", name)
    parameters := getArguments(pattern)
    m := length(parameters)
    scope' := zip(parameters, naturals).fold(
        newGetterDefinition(tag, n, j, m), scope)
    base := newUnderscore(tag, n - j)
    arguments := reverse(n + 1 .. n + m).map(newUnderscore(tag))
    body := arguments.cascade(newApplication(tag), base)
    constructor := ((newLambda(tag, newUnderscore(tag, 0)))^^(n + m))(body)
    applyDefinition(tag, name, constructor, scope')

define reduceADT(operator, left, right)
    tag := renameTag(getTag(operator), "::=")
    if not isValidPattern(left)
        syntaxError("invalid left hand side", operator)
    if not isThisLexeme(right, "{") and not isThisLexeme(right, "{}")
        syntaxError("ADT required to right of", operator)
    newDefinition(tag, left, right)

define applyADTDefinition(tag, left, right, scope)
    undefined' := newName(renameTag(tag, "undefined"))
    scope' := applyDefinition(tag, getHead(left), undefined', scope)
    constructors := getArguments(right)
    n := length(constructors)
    zip(constructors, naturals).fold(newConstructorDefinition(tag, n), scope')

#*
