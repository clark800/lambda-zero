#* define.zero

define getHead(node)
    if isJuxtaposition(node) then getHead(getLeft(node)) else node

define applyPlainDefinition(tag, name, value, scope)
    Let(tag, newPatternArrow(tag, name, scope), value)

define applyTryDefinition(tag, name, value, scope)
    Juxtaposition(tag, Juxtaposition(tag, Name(renameTag(tag, "??"), 0),
        value), newPatternArrow(tag, name, scope))

define transformRecursion(name, value)
    if not isName(name) or (not isArrow(value) and not isCase(value)) or
            not containsName(name, value)
        value
    tag := getTag(name)
    fix' := Name(renameTag(tag, "fix"), 0)
    Juxtaposition(tag, fix', Arrow(tag, Name(tag, 0), value))

define isTupleConstructor(node)
    isName(node) and not isNil(getLexeme(node)) and getLexeme(node)[0] = ','

define isTuple(node)
    if isJuxtaposition(node)
        isTuple(getLeft(node))
    isTupleConstructor(node)

define isValidPattern(node)
    isName(node) or (isJuxtaposition(node) and
        isValidPattern(getLeft(node)) and isValidPattern(getRight(node)))

define isValidConstructorParameter(parameter)
    isJuxtaposition(parameter) and isJuxtaposition(getLeft(parameter)) and
    isValidPattern(getRight(parameter)) and
    isName(getRight(getLeft(parameter))) and
    (isThisName(getLeft(getLeft(parameter)), ":") or
     isThisName(getLeft(getLeft(parameter)), "âˆˆ"))

define newGetterDefinition(tag, dataType, n, j, m, (parameter, k), scope)
    if not isValidConstructorParameter(parameter)
        syntaxError("invalid constructor parameter", parameter)
    name := getRight(getLeft(parameter))
    if isUnused(getTag(name))
        scope
    projector := newProjector(tag, m, k)
    undefined' := Name(renameTag(tag, "undefined"), 0)
    arguments := (0 .. n - 1).map(q -> if q = j then projector else undefined)
    body := UnderscoreArrow(tag,
        arguments.cascade(Juxtaposition(tag), newUnderscore(tag, 1)))
    returnType := getRight(parameter)
    accessor := Accessor(tag, dataType, returnType, body)
    applyPlainDefinition(tag, name, accessor, scope)

define readParameterTypes(form)
    if not isJuxtaposition(form) then []
    readParameterTypes(getLeft(form)) ++ [getRight(getRight(form))]

define newConstructorDefinition(tag, dataType, n, (form, j), scope)
    parameters := getArguments(form)
    m := length(parameters)
    scope' := zip(parameters, naturals).fold(
        newGetterDefinition(tag, dataType, n, j, m), scope)

    if isNumber(form) and getNumericValue(form) = 0
        zero := Name(renameTag(getTag(form), "0"), 0)
        applyPlainDefinition(tag, zero, form, scope')
    if isJuxtaposition(form) and isThisName(getLeft(form), "up")
        name := getLeft(form)
        increment := Name(renameTag(getTag(name), "(increment)"), 0)
        applyPlainDefinition(tag, name, increment, scope')

    name := getHead(form)
    if not isName(name)
        syntaxError("invalid constructor name", name)
    arguments := reverse(n + 1 .. n + m).map(newUnderscore(tag))
    base := arguments.cascade(Juxtaposition(tag), newUnderscore(tag, n - j))
    body := (UnderscoreArrow(tag) ^^ (n + m))(base)
    parameterTypes := readParameterTypes(form)
    constructor := Constructor(tag, parameterTypes, dataType, body)
    applyPlainDefinition(tag, name, constructor, scope')

define applyADTDefinition(tag, left, right, scope)
    forms := getForms(right)
    n := length(forms)
    scope' := zip(forms, naturals).fold(
        newConstructorDefinition(tag, left, n), scope)
    undefined' := Name(renameTag(tag, "undefined"), 0)
    applyPlainDefinition(tag, getHead(left), undefined', scope')

define applyDefinition(definition, scope)
    tag := getTag(definition)
    name := getDefinee(definition)
    value := getDefinedValue(definition)
    match getDefinitionType(definition)
        case PlainDefinition -> applyPlainDefinition(tag, name, value, scope)
        case TryDefinition -> applyTryDefinition(tag, name, value, scope)
        case SyntaxDefinition -> scope
        case ADTDefinition -> applyADTDefinition(tag, name, value, scope)

define reduceDefine'(tag, definitionType, left, right)
    if isTuple(left)
        Definition(tag, definitionType, left, right)
    (name, value) := getNameAndValue(newPatternArrow(tag), left, right)
    if not isName(name)
        parseError("invalid left hand side", tag)
    if isThisName(name, "main")
        applyPlainDefinition(tag, name, value, name)
    Definition(tag, definitionType, name, transformRecursion(name, value))

define reduceDefine(operator, left, right)
    tag := getTag(operator)
    if isKeyphrase(left, "try")
        reduceDefine'(tag, TryDefinition, getRight(left), right)
    if isKeyphrase(left, "syntax")
        reduceDefine'(tag, SyntaxDefinition, getRight(left), right)
    reduceDefine'(tag, PlainDefinition, left, right)

define reduceADTDefine(operator, left, right)
    if not isValidPattern(left)
        syntaxError("invalid left hand side", operator)
    if not isSetBuilder(right)
        syntaxError("ADT required to right of", operator)
    Definition(getTag(operator), ADTDefinition, left, right)

#*
