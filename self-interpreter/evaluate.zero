#* evaluate.zero

def expandNumeral(tag, type, n)
    FreeFunction(tag, FreeFunction(tag,
            n |> 0 -> Variable(tag, -_ 2); up n' ->
                Application(tag, Variable(tag, -_ 1), Numeral(tag, type, n'))))


def evaluate(metacontext, stack, closure @ Closure(term, environment))
    evaluate := evaluate(metacontext)
    done := if isNil(stack) then closure else enclose(Unknown(getTermTag(term)))

    match term
        case MetaVariable(tag, index)
            if index is +_ n
                if metacontext.getMetaValue(n) is Just(closure')
                    evaluate(stack, closure')
                done
            done
        case Type(tag, index) -> done
        case Variable(tag, index)
            evaluate(stack, environment.seek(index) ?? enclose(Unknown(tag)))
        case Singleton(tag, type, element) -> done
        case Function(tag, domain, body)
            if stack is argument :: stack'
                evaluate(stack', Closure(body, environment.push(argument)))
            closure
        case Implication(tag, domain, body) -> done
        case Intersection(tag, domain, body) -> done
        case Application(tag, applicand, argument)
            evaluate(Closure(argument, environment) :: stack,
                Closure(applicand, environment))
        case Numeral(tag, type, n)
            if isNil(stack)
                enclose(term)
            evaluate(stack, Closure(expandNumeral(tag, type, n), environment))
        case Operation(tag, term', Optimization(arity, operator))
            if operator(evaluate([]), stack.take(arity)) is Just(closure')
                evaluate(stack.drop(arity), closure')
            evaluate(stack, Closure(term', environment))


def evaluateClosure(closure)
    evaluate(emptyMetacontext, [], closure)


def evaluateTerm(term)
    evaluateClosure(Closure(term, newArray([])))

#*
