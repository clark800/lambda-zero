#* evaluate.zero

define expandNumeral(tag, type, n)
    Abstraction(tag, NoConstraint,
        Abstraction(tag, NoConstraint,
            n |> 0 -> Variable(tag, 2); up n' ->
                Application(tag, False, Variable(tag, 1),
                Numeral(tag, type, n'))))


define evaluate(closure @ Closure(term, environment), stack)
    match term
        case Top(tag)
            runtimeError("Top", tag)
        case Variable(_, debruijn)
            with environment.seek(debruijn -- 1) as Just(closure')
                evaluate(closure', stack)
            closure
        case MetaVariable(tag, _)
            runtimeError("MetaVariable", tag)
        case Abstraction(_, _, body)
            with stack as argument :: stack'
                evaluate(Closure(body, environment.push(argument)), stack')
            closure
        case Implication(tag, _, _)
            runtimeError("Implication", tag)
        case Implicit(tag, _, _)
            runtimeError("Implicit", tag)
        case Application(_, _, applicand, argument)
            evaluate(Closure(applicand, environment),
                     Closure(argument, environment) :: stack)
        case Construction(tag, _)
            runtimeError("Construction", tag)
        case Numeral(tag, type, n)
            with stack as _ :: _
                numeral := expandNumeral(tag, type, n)
                evaluate(Closure(numeral, environment), stack)
            closure
        case Operation(_, _, arity, operator)
            result := operator(`evaluate([]), stack.take(arity))
            evaluate(result, stack.drop(arity))


define evaluateClosure(closure)
    evaluate(closure, [])


define evaluateTerm(term)
    evaluateClosure(Closure(term, []))

#*
