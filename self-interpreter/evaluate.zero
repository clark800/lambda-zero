#* evaluate.zero

define expandNatural(natural)
    n := getValue(natural)
    tag := getTag(natural)
    underscore := newUnderscore(tag, 0)
    body := n = 0 ? newUnderscore(tag, 2) ||
        newApplication(tag, newUnderscore(tag, 1), newNatural(tag, n - 1))
    newLambda(tag, underscore, newLambda(tag, underscore, body))

define evaluate(closure, stack)
    (term, environment) := (getTerm(closure), getEnvironment(closure))
    getNodeType(term).match(
        SYMBOL -> evaluate(environment[getDebruijnIndex(term) - 1], stack);
        LAMBDA -> stack.isNil ? closure ||
            evaluate(Closure(getBody(term), stack[0] :: environment),
                tail(stack));
        APPLICATION ->
            evaluate(Closure(getLeft(term), environment),
                     Closure(getRight(term), environment) :: stack);
        DEFINITION -> runtimeError("definition", term);
        NATURAL -> stack.isNil ? closure ||
            evaluate(Closure(expandNatural(term), environment), stack);
        BUILTIN -> (
            (arity, builtin) := getBuiltin(term) ?! undefined
            arguments := (stack.takeSafe(arity) ?!
                runtimeError("missing argument to", term)).map(`evaluate([]))
            right := arity > 1 ? arguments[1] || Closure(NULL, [])
            evaluate(builtin(arguments[0], right), stack.dropSafe(arity))
        )
    )

#*
