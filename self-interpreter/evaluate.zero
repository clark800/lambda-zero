#* evaluate.zero

define expandNatural(tag, n)
    metadata := Metadata(Free, Free, [])
    Abstraction(tag, metadata, Abstraction(tag, metadata,
        if n = 0 then Variable(tag, 2) else
            Application(tag, False, Variable(tag, 1), Numeral(tag, n - 1))))


define evaluate(closure @ Closure(term, environment), stack)
    match term
        case Variable(_, debruijn)
            evaluate(environment.seek(debruijn - 1), stack)
        case Abstraction(_, _, body)
            stack |> [] -> closure; argument :: stack' ->
                evaluate(Closure(body, environment.push(argument)), stack')
        case Application(_, _, applicand, argument)
            evaluate(Closure(applicand, environment),
                     Closure(argument, environment) :: stack)
        case Numeral(tag, n)
            if isNil(stack) then closure else
                evaluate(Closure(expandNatural(tag, n), environment), stack)
        case Operation(_, arity, operator)
            result := operator(`evaluate([]), stack.take(arity))
            evaluate(result, stack.drop(arity))


define evaluateClosure(closure)
    evaluate(closure, newRandomAccessList([]))


define evaluateTerm(term)
    evaluateClosure(Closure(term, []))

#*
