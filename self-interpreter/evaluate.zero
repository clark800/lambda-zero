#* evaluate.zero

define expandNatural(tag, n)
    Function(tag, Function(tag, if n = 0 then Reference(tag, 2) else
        Application(Reference(tag, 1), Natural(tag, n - 1))))


define evaluate(closure @ Closure(term, environment), stack)
    match term
        case Reference(_, debruijn)
            evaluate(environment[debruijn - 1], stack)
        case Function(_, body)
            if isNil(stack) then closure else
                evaluate(Closure(body, stack[0] :: environment), tail(stack))
        case Application(left, right)
            evaluate(Closure(left, environment),
                     Closure(right, environment) :: stack)
        case Natural(tag, n)
            if isNil(stack) then closure else
                evaluate(Closure(expandNatural(tag, n), environment), stack)
        case Optimization(tag)
            (arity, builtin) := getBuiltin(`evaluate([]), tag) ? undefined
            arguments := (stack.takeSafe(arity) ?
                runtimeError("missing argument to", tag)).map(`evaluate([]))
            right := if arity > 1 then arguments[1] else arguments[0]
            evaluate(builtin(arguments[0], right), stack.dropSafe(arity))


define evaluateClosure(closure)
    evaluate(closure, [])


define evaluateTerm(term)
    evaluateClosure(Closure(term, []))

#*
