#* evaluate.zero

def expandNumeral(tag, type, n)
    FreeFunction(tag, FreeFunction(tag,
            n |> 0 -> Variable(tag, -_ 2); up n' ->
                Application(tag, Variable(tag, -_ 1), Numeral(tag, type, n'))))


def evaluate(stack, closure @ Closure(term, environment))
    match term
        case Unknown(tag)
            closure
        case MetaVariable(tag, id)
            if isNil(stack) then closure else enclose(Unknown(tag))
        case Universe(tag, level)
            if isNil(stack) then closure else enclose(Unknown(tag))
        case Variable(tag, index)
            evaluate(stack, environment.seek(index) ?? enclose(Unknown(tag)))
        case Function(tag, type, body)
            if stack is argument :: stack'
                evaluate(stack', Closure(body, environment.push(argument)))
            closure
        case Implication(tag, domain, body)
            if isNil(stack) then closure else enclose(Unknown(tag))
        case Intersection(tag, domain, body)
            if isNil(stack) then closure else enclose(Unknown(tag))
        case Application(tag, applicand, argument)
            evaluate(Closure(argument, environment) :: stack,
                Closure(applicand, environment))
        case Construction(tag, parameter, type, signatures)
            if isNil(stack) then closure else enclose(Unknown(tag))
        case Element(tag, type, term')
            evaluate(stack, Closure(term', environment))
        case Numeral(tag, type, n)
            if isNil(stack) then closure else
            evaluate(stack, Closure(expandNumeral(tag, type, n), environment))
        case Operation(tag, term', Optimization(arity, operator))
            if operator(evaluate([]), stack.take(arity)) is Just(closure')
                evaluate(stack.drop(arity), closure')
            evaluate(stack, Closure(term', environment))


def evaluateClosure(closure)
    evaluate([], closure)


def evaluateTerm(term)
    evaluateClosure(Closure(term, newArray([])))

#*
