#* evaluate.zero

def expandNumeral(tag, type, n)
    FreeFunction(tag, FreeFunction(tag,
            n |> 0 -> Variable(tag, -_ 2); up n' ->
                Application(tag, Variable(tag, -_ 1), Numeral(tag, type, n'))))


def evaluate(metacontext, stack, closure @ Closure(term, environment))
    evaluate := evaluate(metacontext)

    def evaluateBinder(body)
        if stack is argument :: stack'
            evaluate(stack', Closure(body, environment.push(argument)))
        closure

    match term
        case Unknown(tag) -> closure
        case MetaVariable(tag, index)
            if index is +_ n
                if metacontext.getMetaValue(n) is Just(closure')
                    evaluate(stack, closure')
                pass
            if isNil(stack) then closure else enclose(Unknown(tag))
        case Type(tag, index)
            if isNil(stack) then closure else enclose(Unknown(tag))
        case Variable(tag, index)
            evaluate(stack, environment.seek(index) ?? enclose(Unknown(tag)))
        case Singleton(tag, type, index)
            if isNil(stack) then closure else enclose(Unknown(tag))
        case Function(tag, domain, body) -> evaluateBinder(body)
        case Implication(tag, domain, body) -> evaluateBinder(body)
        case Intersection(tag, domain, body) -> evaluateBinder(body)
        case Application(tag, applicand, argument)
            evaluate(Closure(argument, environment) :: stack,
                Closure(applicand, environment))
        case Numeral(tag, type, n)
            if isNil(stack)
                enclose(term)
            evaluate(stack, Closure(expandNumeral(tag, type, n), environment))
        case Operation(tag, term', Optimization(arity, operator))
            if operator(evaluate([]), stack.take(arity)) is Just(closure')
                evaluate(stack.drop(arity), closure')
            evaluate(stack, Closure(term', environment))


def evaluateClosure(closure)
    evaluate(emptyMetacontext, [], closure)


def evaluateTerm(term)
    evaluateClosure(Closure(term, newArray([])))

#*
