#* evaluate.zero

define expandNatural(natural)
    n := getValue(natural)
    tag := getTag(natural)
    underscore := newUnderscore(tag, 0)
    body := if n = 0 then newUnderscore(tag, 2) else
        newApplication(tag, newUnderscore(tag, 1), newNatural(tag, n - 1))
    newLambda(tag, underscore, newLambda(tag, underscore, body))


define evaluate(closure, stack)
    (term, environment) := (getTerm(closure), getEnvironment(closure))
    match getNodeType(term)
        case SYMBOL
            evaluate(environment[getDebruijnIndex(term) - 1], stack)
        case LAMBDA
            if stack.isNil
                closure
            evaluate(Closure(getBody(term), stack[0] :: environment),
                tail(stack))
        case APPLICATION
            evaluate(Closure(getLeft(term), environment),
                     Closure(getRight(term), environment) :: stack)
        case DEFINITION
            runtimeError("definition", term)
        case NATURAL
            if stack.isNil
                closure
            evaluate(Closure(expandNatural(term), environment), stack)
        case BUILTIN
            (arity, builtin) := try getBuiltin(term) except undefined
            arguments := (try stack.takeSafe(arity) except
                runtimeError("missing argument to", term)).map(`evaluate([]))
            right := if arity > 1 then arguments[1] else Closure(NULL, [])
            evaluate(builtin(arguments[0], right), stack.dropSafe(arity))

#*
