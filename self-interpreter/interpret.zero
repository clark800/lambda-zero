#* interpret.zero

def splitCodeAndInput(input)
    (code, afterCode) := input.splitOn("\0")
    afterCode |> [] -> (code, []); _ :: input' -> (code, input')


def isMain(term)
    # todo: detect the name "main" rather than parameter name "input"
    isFunction(term) and getTagLexeme(getTermTag(term)) =*= "input"


def newNilTerm(tag)
    FreeFunction(tag, FreeFunction(tag, Variable(tag, 2)))


def constructString(tag, string)
    # todo: implement this
    newNilTerm(veil(tag))


def evaluateMain(Closure(main, environment), input)
    # todo: use tag for "input" parameter to main
    tag := getTermTag(main)
    term := Application(tag, main, constructString(tag, input))
    serializeString(evaluateClosure, Closure(term, environment)) ??
        runtimeError("expected string from", tag)


def showDefinition((tag, term))
    showTag(tag) ++ " := " ++ showTerm(term)


def showDefinitions(tags, environment)
    terms := environment.toList.map(getTerm)
    zip(tags, terms).map(showDefinition).joinWith("\n")


def main(input)
    (code, input') := splitCodeAndInput(input)
    (tags, context, environment) := parse(code)
    term := environment.peek(0).mapJust(getTerm) ?? abort("No input")
    if code.startsWith("#% dump")
        showDefinitions(tags, environment)
    closure := evaluateTerm(environment, term)
    if isMain(getTerm(closure))
        evaluateMain(closure, input')
    serialize(closure)


#main(input) := lex(input).map(showToken).joinWith("\n")
#main(input) := showAST(parse(input))

#*
