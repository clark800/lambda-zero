#* interpret.zero

define execute(ast)
    evaluate(Closure(ast, []), [])

define splitCodeAndInput(input)
    (code, afterCode) := input.splitOn("\0")
    input' := afterCode.isNil ? [] || tail(afterCode)
    (code, input')

define extractOutputString(closure)
    # term is (z -> p -> z) or (z -> p -> ((p c) cs))
    body := getBody(getBody(getTerm(closure)))
    isSymbol(body) ? []
    dummy := Closure(NULL, [])
    environment' := dummy :: dummy :: getEnvironment(closure)
    characterTerm := getRight(getLeft(body))
    characterClosure := Closure(characterTerm, environment')
    character := getCharacter(getTerm(evaluate(characterClosure, [])))
    remaining := evaluate(Closure(getRight(body), environment'), [])
    character :: extractOutputString(remaining)

define main(input)
    (code, input') := splitCodeAndInput(input)
    ast := parse(code, input')
    closure := execute(ast)
    term := getTerm(closure)
    if isLambda(term) and isThisSymbol(getParameter(term), "input")
        # todo: construct input
        string := newName(renameTag(getTag(term), "[]"))
        stack := [Closure(string, [])]
        extractOutputString(evaluate(closure, stack))
    serialize(closure)

#main(input) := lex(input).map(showToken).joinWith("\n")
#main(input) := showAST(parse(input, ""))

#*
