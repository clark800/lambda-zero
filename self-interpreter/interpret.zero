#* interpret.zero

define splitCodeAndInput(input)
    (code, afterCode) := input.splitOn("\0")
    afterCode |> [] -> (code, []); _ :: input' -> (code, input')


define isMain(term)
    # todo: detect the name "main" rather than parameter name "input"
    isAbstraction(term) and getTagLexeme(getTermTag(term)) =*= "input"


define newNilTerm(tag)
    Abstraction(tag, NoConstraint,
        Abstraction(tag, NoConstraint, Variable(tag, 2)))


define constructString(tag, string)
    # todo: implement this
    newNilTerm(veil(tag))


define evaluateMain(Closure(main, environment), input)
    # todo: use tag for "input" parameter to main
    tag := getTermTag(main)
    term := Application(tag, main, constructString(tag, input))
    serializeString(evaluateClosure, Closure(term, environment)) ??
        runtimeError("expected string from", tag)


define showDefinition((tag, term))
    showTag(tag) ++ " := " ++ showTerm(term)


define showDefinitions(tags, environment)
    terms := environment.dump.map(second).map(getTerm)
    zip(tags, terms).map(showDefinition).joinWith("\n")


define main(input)
    (code, input') := splitCodeAndInput(input)
    (tags, context, environment) := parse(code)
    term := environment.rseek(0).mapJust(getTerm) ?? abort("No input")
    if code.startsWith("#% dump")
        showDefinitions(tags, environment)
    closure := evaluateTerm(environment, term)
    if isMain(getTerm(closure))
        evaluateMain(closure, input')
    serialize(closure)


#main(input) := lex(input).map(showToken).joinWith("\n")
#main(input) := showAST(parse(input))

#*
