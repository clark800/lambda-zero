#* interpret.zero

define splitCodeAndInput(input)
    (code, afterCode) := input.splitOn("\0")
    input' := if afterCode.isNil then [] else tail(afterCode)
    (code, input')


define isMain(term)
    # todo: detect the name "main" rather than parameter name "input"
    isAbstraction(term) and getTagLexeme(getTermTag(term)) =*= "input"


define newNilTerm(tag)
    metadata := Metadata(Free, Free, [])
    Abstraction(tag, metadata, Abstraction(tag, metadata, Variable(tag, 2)))


define constructString(tag, string)
    # todo: implement this
    newNilTerm(renameTag(tag, "_"))


define evaluateMain(Closure(main, environment), input)
    # todo: use tag for "input" parameter to main
    tag := getTermTag(main)
    term := Application(tag, false, main, constructString(tag, input))
    serializeString(evaluateClosure, Closure(term, environment)) ??
        runtimeError("expected string from", tag)


define main(input)
    (code, input') := splitCodeAndInput(input)
    closure := evaluateTerm(parse(code))
    if isMain(getTerm(closure))
        evaluateMain(closure, input')
    serialize(closure)


#main(input) := lex(input).map(showToken).joinWith("\n")
#main(input) := showAST(parse(input))

#*
