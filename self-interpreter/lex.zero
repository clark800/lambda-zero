--* lex.zero

LocationType ::= {Location(
    getLocationFile : List(Integer),
    getLocationLine : Integer,
    getLocationColumn : Integer
)}

TagType ::= {Tag(getTagLexeme : List(Integer), getTagLocation : LocationType)}

isLineComment(lexeme) := lexeme.startsWith("--")
isBlockComment(lexeme) := lexeme.startsWith("{=")
isNumeric(lexeme) := isDigit(head(lexeme)) \/
    ((head(lexeme) = '+' \/ head(lexeme) = '-') /\ ! isNil(tail(lexeme)) /\
      isDigit(head(tail(lexeme))))
isNewline(c) := c = '\n' \/ c = '\r'
isInvalid(c) := c != 0 /\ isControl(c) /\ ! isBlank(c) /\ ! isNewline(c)
isDelimiter(c) := " \t\n\r\0,;.`()[]{}@$\"".any((= c)) \/ isInvalid(c)

splitQuoteCharacter(quote, ns) := (
    ns.isNil \/ head(ns) = quote \/ isNewline(head(ns)) ? ([], ns)
    n := (head(ns) = '\\' /\ ! isNil(tail(ns))) ? 2 || 1
    ns.splitAt(n)
)

shiftSplit((a, b)) := isNil(b) ? (a, b) || (a ++ [head(b)], tail(b))

splitQuote(ns) := (
    quote := head(ns)
    (a, b) := tail(ns).splitWith(splitQuoteCharacter(quote))
    ! b.isNil /\ head(b) = quote ?
        shiftSplit((quote :: a, b))
    (quote :: a, b)
)

splitNumeric(ns) := (
    (before, after) := ns.splitWhen(isDelimiter)
    isNil(after) \/ isNil(tail(after)) \/ head(after) != '.' \/
        ! isDigit(head(tail(after))) ? (before, after)
    (before', after') := tail(after).splitWhen(isDelimiter)
    (before ++ [head(after)] ++ before', after')
)

splitLexeme(ns) := (
    ns.isNil ? ([], [])
    c := head(ns)
    c.isBlank ? ns.splitWhen((!) <> isBlank)
    c.isNewline ? ns.splitWhen((!) <> isNewline)
    c.isQuote ? splitQuote(ns)
    ns.isLineComment ? ns.splitWhen(isNewline)
    ns.isBlockComment ? ns.splitOn("=}").shiftSplit.shiftSplit
    ns.isNumeric ? splitNumeric(ns)
    c = '.' ? ns.splitWhen(!= '.')
    c.isDelimiter ? ([head(ns)], tail(ns))
    ns.splitWhen(isDelimiter)
)

advanceLocation'(lexeme, line, column) := (
    isNil(lexeme) ? (line, column)
    head(lexeme) = '\n' ? tail(lexeme).advanceLocation'(line + 1, 1)
    tail(lexeme).advanceLocation'(line, column + 1)
)

advanceLocation(location, lexeme) := (
    isLineComment(lexeme) /\ lexeme[2] = '*' ? (
        (_, after) := lexeme.drop(3).splitWhen((!) <> isBlank)
        (file, _) := after.splitWhen(= '\n')
        Location(file, isNil(file) ? 0 || 1, 0)
    )
    isBlockComment(lexeme) \/ isNewline(head(lexeme)) ? (
        (line, column) := lexeme.advanceLocation'(
            location.getLocationLine, location.getLocationColumn)
        Location(location.getLocationFile, line, column)
    )
    Location(location.getLocationFile, location.getLocationLine,
        location.getLocationColumn + length(lexeme))
)

splitLexemes(string, splitter, location) := (
    string.isNil ? []
    (lexeme, remaining) := splitter(string)
    nextLocation := advanceLocation(location, lexeme)
    Tag(lexeme, location) :: remaining.splitLexemes(splitter, nextLocation)
)

scan(string) := string.splitLexemes(splitLexeme, Location("", 1, 1))

showLocation(location) :=
    (location.getLocationFile.isNil ? "" || location.getLocationFile ++ " ") ++
    "line " ++ showNatural(location.getLocationLine) ++
    " column " ++ showNatural(location.getLocationColumn)

showTag(tag) :=
    "'" ++ tag.getTagLexeme ++
    "' at " ++ showLocation(tag.getTagLocation)

TokenCode ::= {
    Blank, Newline, Symbolic, Numeric, Character, String, Comment, Invalid
}
TokenType ::= {Token(getTokenTag : Tag, getTokenCode : TokenCode)}

createToken(tag) := (
    lexeme := getTagLexeme(tag)
    isNil(lexeme) ? Token(tag, Symbolic)
    c := head(lexeme)
    isInvalid(c) ? Token(tag, Invalid)
    isBlank(c) ? Token(tag, Blank)
    isNewline(c) ? Token(tag, Newline)
    c = '"' ? Token(tag, String)
    c = '\'' ? Token(tag, Character)
    isNumeric(lexeme) ? Token(tag, Numeric)
    isLineComment(lexeme) \/ isBlockComment(lexeme) ? Token(tag, Comment)
    Token(tag, Symbolic)
)

getTokenCodeNumber(tokenCode) := tokenCode.match(
    Blank -> 0;
    Newline -> 1;
    Symbolic -> 2;
    Numeric -> 3;
    Character -> 4;
    String -> 5;
    Comment -> 6;
    Invalid -> 7;
)

isComment(token) := getTokenCodeNumber(getTokenCode(token)) =
                   getTokenCodeNumber(Comment)

showToken(token) := token.getTokenTag.getTagLexeme

lex(string) := scan(string).map(createToken)

START := Token(Tag("\0", Location("", 0, 0)), Symbolic)

showToken'(token) := showTag(getTokenTag(token)) ++ " " ++
    getTokenCode(token).match(
        Blank -> "Blank";
        Newline -> "Newline";
        Symbolic -> "Symbolic";
        Numeric -> "Numeric";
        Character -> "Character";
        String -> "String";
        Comment -> "Comment";
        Invalid -> "Invalid";
    )

--main(input) := scan(input).map(showTag).joinWith("\n")
--main(input) := lex(input).map(showToken').joinWith("\n")

--*
