--* parse.zero

parseEscapeCode(code, tag) := (
    code = '0' ? '\0'
    code = 'n' ? '\n'
    code = 't' ? '\t'
    code = 'r' ? '\r'
    code = '\\' ? '\\'
    code = '\"' ? '\"'
    code = '\'' ? '\''
    error("Syntax error: invalid escape sequence in " ++ showTag(tag))
)

parseQuotedCharacter(tag, string) := (
    c := head(string)
    c =/= '\\' ?
        newNatural(tag, c)
    isNil(tail(string)) ?
        error("Syntax error: missing end quote for " ++ showTag(tag))
    newNatural(tag, parseEscapeCode(head(tail(string)), tag))
)

splitStringLiteral(string) := (
    isNil(string) ? []
    n := head(string) = '\\' /\ not isNil(tail(string)) ? 2 || 1
    string.take(n) :: splitStringLiteral(string.drop(n))
)

buildStringLiteral(tag, characters) := (
    isNil(characters) ? newNil(tag)
    prependList(tag, head(characters),
        buildStringLiteral(tag, tail(characters)))
)

getQuoteContents(tag) := (
    lexeme := getTagLexeme(tag)
    lexeme.length > 1 /\ lexeme.last = head(lexeme) ? dropLast(tail(lexeme))
    error("Syntax error: missing end quote for " ++ showTag(tag))
)

getQuotedCharacters(tag) :=
    splitStringLiteral(getQuoteContents(tag)).map(parseQuotedCharacter(tag))

parseStringLiteral(tag) := buildStringLiteral(tag, getQuotedCharacters(tag))

parseCharacterLiteral(tag) := (
    characters := getQuotedCharacters(tag)
    (characters.length = 1)? head(characters)
    error("Syntax error: invalid character literal " ++ showTag(tag))
)

parseNumericLiteral(tag) := (
    lexeme := getTagLexeme(tag)
    lexeme.any((not) <> isDigit) ?
        error("Syntax error: invalid token " ++
            showLexemeAndLocationLine(tag, "'"))
    maxNatural := "9223372036854775807"
    natural := lexeme.dropWhile((= '0'))
    natural.length > maxNatural.length ?
        error("Syntax error: magnitude of natural is too large " ++
            showLexemeAndLocationLine(tag, "'"))
    natural.length = maxNatural.length /\
        zipWith(natural, (>), maxNatural).any(id) ?
        error("Syntax error: magnitude of natural is too large " ++
            showLexemeAndLocationLine(tag, "'"))
    newNatural(tag, parseNatural(lexeme, 10))
)

parseToken(operators, token) := (
    tag := getTokenTag(token)
    getTokenCode(token).match(
        Blank -> parseSymbol(operators, renameTag(tag, " "));
        Newline -> parseSymbol(operators, renameTag(tag, "\n"));
        Symbolic -> parseSymbol(operators, tag);
        Numeric -> parseNumericLiteral(tag);
        Character -> parseCharacterLiteral(tag);
        String -> parseStringLiteral(tag);
        Comment -> error("internal error");
        Invalid -> syntaxError("invalid character", newName(tag));
    )
)

shiftToken(state, token) := shift(state, parseToken(getOperators(state), token))

parse(code, input) := (
    tokens := lex(code ++ [0]) |: (not) <> isComment
    state := State([parseToken(OPERATORS, START)], OPERATORS)
    stack := getStack(tokens.cascade(shiftToken, state))
    -- use "count" to force any syntaxErrors in the stack
    stack.count((not) <> isEOF) = 0 ? syntaxError("no input", head(stack))
    length(stack) =/= 1 ? error("parser error")
    -- error(showAST(head(stack)))
    bind(head(stack))
)

--*
