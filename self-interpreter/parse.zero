#* parse.zero

define parseEscapeCode(code, tag)
    if code = '0' then '\0'
    if code = 'n' then '\n'
    if code = 't' then '\t'
    if code = 'r' then '\r'
    if code = '\\' then '\\'
    if code = '\"' then '\"'
    if code = '\'' then '\''
    parseError("invalid escape sequence in", tag)


define parseQuotedCharacter(tag, string)
    c := head(string)
    if c =/= '\\'
        Number(tag, c)
    if isNil(tail(string))
        parseError("missing end quote for", tag)
    Number(tag, parseEscapeCode(head(tail(string)), tag))


define splitStringLiteral(string)
    if isNil(string)
        []
    n := if head(string) = '\\' and not isNil(tail(string)) then 2 else 1
    string.take(n) :: splitStringLiteral(string.drop(n))


define buildStringLiteral(tag, characters)
    if isNil(characters)
        newNil(tag)
    prependList(tag, head(characters),
        buildStringLiteral(tag, tail(characters)))


define getQuoteContents(tag)
    lexeme := getTagLexeme(tag)
    if lexeme.length > 1 and lexeme.last = head(lexeme)
        dropLast(tail(lexeme))
    parseError("missing end quote for", tag)


define getQuotedCharacters(tag)
    splitStringLiteral(getQuoteContents(tag)).map(parseQuotedCharacter(tag))


define parseStringLiteral(tag)
    buildStringLiteral(tag, getQuotedCharacters(tag))


define parseCharacterLiteral(tag)
    characters := getQuotedCharacters(tag)
    if characters.length = 1
        head(characters)
    parseError("invalid character literal", tag)


define parseNumericLiteral(tag)
    lexeme := getTagLexeme(tag)
    if lexeme.any((not) <> isDigit)
        parseError("invalid token", tag)
    maxNatural := "9223372036854775807"
    natural := lexeme.dropWhile(= '0')
    if natural.length > maxNatural.length
        parseError("magnitude of numeral is too large", tag)
    if natural.length = maxNatural.length and
            zipWith(natural, (>), maxNatural).any(id)
        parseError("magnitude of numeral is too large", tag)
    Number(tag, parseNatural(lexeme, 10))


define parseToken(operators, token)
    tag := getTokenTag(token)
    match getTokenCode(token)
        case Space -> parseSymbol(operators, renameTag(tag, " "), 0)
        case VSpace -> parseError("internal error: VSpace", tag)
        case Newline -> parseSymbol(operators, renameTag(tag, "\n"),
            length(getTagLexeme(tag)) - 1)
        case Symbolic -> parseSymbol(operators, tag, 0)
        case Numeric -> parseNumericLiteral(tag)
        case Character -> parseCharacterLiteral(tag)
        case String -> parseStringLiteral(tag)
        case Comment -> parseError("internal error: Comment", tag)
        case Invalid -> parseError("invalid character", tag)


define shiftToken(state, token)
    shift(state, parseToken(getOperators(state), token))


define parse(code)
    tokens := lex(code ++ [0]) |: (not) <> isElided
    state := State([parseToken(OPERATORS, START)], OPERATORS)
    stack := getStack(tokens.cascade(shiftToken, state))
    # use "count" to force any syntaxErrors in the stack
    if stack.count((not) <> isEOF) = 0
        syntaxError("no input", head(stack))
    if length(stack) =/= 1
        error("parser error")
    # error(showAST(head(stack)))
    bind(head(stack), [])

#*
