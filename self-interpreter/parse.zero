--* parse.zero

define parseEscapeCode(code, tag)
    code = '0' ? '\0'
    code = 'n' ? '\n'
    code = 't' ? '\t'
    code = 'r' ? '\r'
    code = '\\' ? '\\'
    code = '\"' ? '\"'
    code = '\'' ? '\''
    error("Syntax error: invalid escape sequence in " ++ showTag(tag))

define parseQuotedCharacter(tag, string)
    c := head(string)
    if c =/= '\\'
        newNatural(tag, c)
    if isNil(tail(string))
        error("Syntax error: missing end quote for " ++ showTag(tag))
    newNatural(tag, parseEscapeCode(head(tail(string)), tag))

define splitStringLiteral(string)
    if isNil(string)
        []
    n := head(string) = '\\' and not isNil(tail(string)) ? 2 || 1
    string.take(n) :: splitStringLiteral(string.drop(n))

define buildStringLiteral(tag, characters)
    if isNil(characters)
        newNil(tag)
    prependList(tag, head(characters),
        buildStringLiteral(tag, tail(characters)))

define getQuoteContents(tag)
    lexeme := getTagLexeme(tag)
    if lexeme.length > 1 and lexeme.last = head(lexeme)
        dropLast(tail(lexeme))
    error("Syntax error: missing end quote for " ++ showTag(tag))

define getQuotedCharacters(tag)
    splitStringLiteral(getQuoteContents(tag)).map(parseQuotedCharacter(tag))

define parseStringLiteral(tag)
    buildStringLiteral(tag, getQuotedCharacters(tag))

define parseCharacterLiteral(tag)
    characters := getQuotedCharacters(tag)
    if characters.length = 1
        head(characters)
    error("Syntax error: invalid character literal " ++ showTag(tag))

define parseNumericLiteral(tag)
    lexeme := getTagLexeme(tag)
    if lexeme.any((not) <> isDigit)
        error("Syntax error: invalid token " ++
            showLexemeAndLocationLine(tag, "'"))
    maxNatural := "9223372036854775807"
    natural := lexeme.dropWhile(= '0')
    if natural.length > maxNatural.length
        error("Syntax error: magnitude of natural is too large " ++
            showLexemeAndLocationLine(tag, "'"))
    if natural.length = maxNatural.length and
            zipWith(natural, (>), maxNatural).any(id)
        error("Syntax error: magnitude of natural is too large " ++
            showLexemeAndLocationLine(tag, "'"))
    newNatural(tag, parseNatural(lexeme, 10))

define parseToken(operators, token)
    tag := getTokenTag(token)
    getTokenCode(token).match(
        Space -> parseSymbol(operators, renameTag(tag, " "));
        VSpace -> error("internal error");
        Newline -> parseSymbol(operators, tag);
        Symbolic -> parseSymbol(operators, tag);
        Numeric -> parseNumericLiteral(tag);
        Character -> parseCharacterLiteral(tag);
        String -> parseStringLiteral(tag);
        Comment -> error("internal error");
        Invalid -> syntaxError("invalid character", newName(tag));
    )

define shiftToken(state, token)
    shift(state, parseToken(getOperators(state), token))

define parse(code, input)
    tokens := lex(code ++ [0]) |: (not) <> isElided
    state := State([parseToken(OPERATORS, START)], OPERATORS)
    stack := getStack(tokens.cascade(shiftToken, state))
    -- use "count" to force any syntaxErrors in the stack
    if stack.count((not) <> isEOF) = 0
        syntaxError("no input", head(stack))
    if length(stack) =/= 1
        error("parser error")
    -- error(showAST(head(stack)))
    bind(head(stack))

--*
