#* ast.zero

DefinitionType ::= {PlainDefinition, MaybeDefinition, TryDefinition,
    SyntaxDefinition, ADTDefinition, BindDefinition}
ArrowType ::= {Simple, Strict, Locked, Double, Tail}

AST ::= {
    Reference(tag : TagT, debruijn : ℕ),
    Arrow(tag : TagT, type : ArrowType, constructors : List(AST),
        parameter : AST, annotation : (AST)?, body : AST),
    Juxtaposition(tag : TagT, left : AST, right : AST),
    Let(tag : TagT, isTypeConstructor : 𝔹,
        name : AST, value : AST, scope : AST),
    Number(tag : TagT, value : ℕ),
    Definition(tag : TagT, type : DefinitionType,
        definiendum : AST, definiens : AST),
    AsPattern(tag : TagT, left : AST, pattern : AST),
    CommaPair(tag : TagT, left : AST, right : AST),
    ColonPair(tag : TagT, left : AST, right : AST),
    SetBuilder(tag : TagT, forms : List(AST)),
    ADT(tag : TagT, parameters : List(AST), objectType : AST,
        signatures : List(AST)),
    Constructor(tag : TagT, type : AST, adtType : AST, function : AST,
        count : ℕ, index : ℕ),
    TypedNode(tag : TagT, type : AST, node : AST)
}


def lockArrow(node)
    if node is Arrow(tag, arrowType, constructors, left, annotation, right)
        if arrowType is Simple
            Arrow(tag, Locked, constructors, left, annotation, right)
        if arrowType is Strict
            Arrow(tag, Locked, constructors, left, annotation, right)
        node
    node


def getTag
    Reference(tag, _) -> tag
    Arrow(tag, _, _, _, _, _) -> tag
    Juxtaposition(tag, _, _) -> tag
    Let(tag, _, _, _, _) -> tag
    Number(tag, _) -> tag
    Definition(tag, _, _, _) -> tag
    AsPattern(tag, _, _) -> tag
    CommaPair(tag, _, _) -> tag
    ColonPair(tag, _, _) -> tag
    SetBuilder(tag, _) -> tag
    ADT(tag, _, _, _) -> tag
    Constructor(tag, _, _, _, _, _) -> tag
    TypedNode(tag, _, _) -> tag


def astSyntaxError(message, node)
    syntaxError(message, getTag(node))


def isPreterm
    Reference(_, _) -> True
    Arrow(_, _, _, _, _, _) -> True
    Juxtaposition(_, _, _) -> True
    Let(_, _, _, _, _) -> True
    Number(_, _) -> True
    Definition(_, _, _, _) -> False
    AsPattern(_, _, _) -> False
    CommaPair(_, _, _) -> False
    ColonPair(_, _, _) -> False
    SetBuilder(_, _) -> False
    ADT(_, _, _, _) -> True
    Constructor(_, _, _, _, _, _) -> True
    TypedNode(_, _, _) -> True


def containsName(name)
    Reference(tag, _) -> getTagLexeme(tag) =*= getTagLexeme(getTag(name))
    Arrow(_, _, _, _, _, body) -> containsName(name, body)
    Juxtaposition(_, left, right) ->
        containsName(name, left) or containsName(name, right)
    Let(_, _, _, value, scope) ->
        containsName(name, value) or containsName(name, scope)
    Number(_, _) -> False
    Definition(_, _, _, _) -> False
    AsPattern(_, _, _) -> False
    CommaPair(_, _, _) -> False
    ColonPair(_, _, right) -> containsName(name, right)
    SetBuilder(_, _) -> False
    ADT(_, _, objectType, _) -> containsName(name, objectType)
    Constructor(_, _, _, _, _, _) -> False
    TypedNode(_, _, _) -> False


def showArrow
    Simple -> " -> "
    Strict -> " -> "
    Locked -> " -> "
    Double -> " => "
    Tail -> " >-> "


def showAnnotation(showAST, annotation)
    if annotation is Just(type)
        " : " ++ showAST(type)
    ""


def showAST
    Reference(tag, _) -> showTag(tag)
    Arrow(tag, arrowType, _, parameter, annotation, body) ->
        "(" ++ showAST(parameter) ++ showAnnotation(showAST, annotation) ++
            showArrow(arrowType) ++ showAST(body) ++ ")"
    Juxtaposition(tag, left, right) ->
        "(" ++ showAST(left) ++ " " ++ showAST(right) ++ ")"
    Let(tag, _, name, value, scope) ->
        "(" ++ showAST(name) ++ " := " ++ showAST(value) ++
            ";;" ++ showAST(scope) ++ ")"
    Number(tag, value) -> showNatural(value)
    Definition(tag, _, left, right) ->
        "(" ++ showAST(left) ++ " := " ++ showAST(right) ++ ")"
    AsPattern(tag, name, pattern) ->
        "(" ++ showAST(name) ++ ")@(" ++ showAST(pattern) ++ ")"
    CommaPair(tag, left, right) ->
        "(" ++ showAST(left) ++ ", " ++ showAST(right) ++ ")"
    ColonPair(tag, left, right) ->
        "(" ++ showAST(left) ++ " : " ++ showAST(right) ++ ")"
    SetBuilder(_, forms) -> "{" ++ forms.map(showAST).joinWith(", ") ++ "}"
    ADT(tag, parameters, objectType, _) ->
        showTag(tag) ++ "(" ++ parameters.map(showAST).joinWith(", ") ++ ")"
    Constructor(_, _, _, body, _, _) -> showAST(body)
    TypedNode(_, _, node) -> showAST(node)


isReference := Reference(_, _) -> True; _ -> False
isArrow := Arrow(_, _, _, _, _, _) -> True; _ -> False
isJuxtaposition := Juxtaposition(_, _, _) -> True; _ -> False
isLet := Let(_, _, _, _, _) -> True; _ -> False
isNumber := Number(_, _) -> True; _ -> False
isDefinition := Definition(_, _, _, _) -> True; _ -> False
isAsPattern := AsPattern(_, _, _) -> True; _ -> False
isCommaPair := CommaPair(_, _, _) -> True; _ -> False
isColonPair := ColonPair(_, _, _) -> True; _ -> False
isSetBuilder := SetBuilder(_, _) -> True; _ -> False
isADT := ADT(_, _, _, _) -> True; _ -> False
isConstructor := Constructor(_, _, _, _, _, _) -> True; _ -> False
isTypedNode := TypedNode(_, _, _) -> True; _ -> False

isCase(node) := if node is Arrow(_, type, _, _, _, _);
    (type |> Locked -> False; _ -> True) <| False

Name(tag) := Reference(tag, 0)
FixedName(tag, lexeme) := Name(renameTag(tag, lexeme, NOFIX))
isName(node) := if node is Reference(_, debruijn); debruijn = 0 <| False

def TypedArrow(arrowType, parameter, body)
    if parameter is ColonPair(_, name, type)
        Arrow(getTag(name), arrowType, [], name, Just(type), body)
    Arrow(getTag(parameter), arrowType, [], parameter, Void, body)

SimpleArrow := TypedArrow(Simple)
LockedArrow := TypedArrow(Locked)
DoubleArrow := TypedArrow(Double)
TailArrow := TypedArrow(Tail)
StrictArrow(tag, constructors, body) :=
    Arrow(tag, Strict, constructors, Name(veil(tag)), Void, body)


def setAnnotation(annotation, node)
    if node is Arrow(tag, arrowType, constructors, parameter, _, body)
        Arrow(tag, arrowType, constructors, parameter, Just(annotation), body)
    abort("can only set annotation on arrow nodes")


isSyntaxDefinition(node) := if node is Definition(_, type, _, _);
    (if type is SyntaxDefinition; True <| False) <| False
getLexeme(node) := getTagLexeme(getTag(node))
showLexeme(node) := showTag(getTag(node))
isThisName(node, lexeme) := isName(node) and getLexeme(node) =*= lexeme
isUnderscore(node) := isThisName(node, "_")
isUnused(tag) := getTagLexeme(tag).startsWith("_")
UnderscoreArrow(tag, body) := LockedArrow(Name(veil(tag)), body)
Underscore(tag, debruijn) := Reference(veil(tag), debruijn)
newNil(tag) := FixedName(tag, "[]")
prependList(tag, item, list) := Juxtaposition(tag,
    Juxtaposition(tag, Name(renameTag(tag, "::", INFIX)), item), list)


def getFixityCode(fixity)
    match fixity
        Prefix(_) -> PREFIX
        Infix(_) -> INFIX
        Postfix(_) -> POSTFIX
        Openfix(_) -> OPENFIX
        Closefix(_) -> CLOSEFIX


def maybeCount(node)
    if node is Constructor(_, _, _, _, count, _)
        Just(count)
    Void


def maybeConstructorIndex(node)
    if node is Constructor(_, _, _, _, _, index)
        Just(index)
    Void

#*
