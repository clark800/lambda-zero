#* bind.zero

Local ::= {
    Parameter(level : â„•),
    Inline(term : Term)
}

GlobalT ::= {Global(
    ast : AST,
    term : Term,
    constant : Term
)}

BindingT ::= {Binding(
    tag : TagT,
    metaclosure : MetaClosureT
)}

getGlobalAST(Global(ast, _, _)) := ast
getGlobalTerm(Global(_, term, _)) := term
getGlobalConstant(Global(_, _, constant)) := constant

getBindingTag(Binding(tag, _)) := tag
getBindingMetaClosure(Binding(tag, metaclosure)) := metaclosure


def newMetaVariable(tag, metacontext)
    (index, metacontext') := metacontext.append(Void)
    (MetaVariable(tag, index), metacontext')


def bindLocal((level, table), tag)
    maybe item := table.lookup(getTagLexeme(tag))
    match item
        case Parameter(level')
            Just(Variable(tag, level -- level'))
        case Inline(term)
            Just(term)


def pushParameter(parameter, (level, table))
    (up level, table.insert(getLexeme(parameter), Parameter(level)))


def pushInline(parameter, term, (level, table))
    (level, table.insert(getLexeme(parameter), Inline(term)))


def findType(lexeme, globals)
    if globals.lookup(lexeme) is Just(Global(_, term, _))
        maybeAscription(term)
    Void


def getNaturalType(globals)
    globals.findType("0") ?? Variable(renameTag(noTag, "#NATURAL#", NOFIX), 0)


def getBooleanType(globals)
    globals.findType("False") ??
        Variable(renameTag(noTag, "#BOOLEAN#", NOFIX), 0)


def getStringType(globals, tag)
    natural := getNaturalType(globals)
    listType := globals.findType("[]") ?? syntaxError("List not defined", tag)
    if listType is Application(_, listTypeConstructor, _)
        Application(noTag, listTypeConstructor, natural)
    syntaxError("List type invalid", tag)


def getOperationType(globals, tag)
    lexeme := getTagLexeme(tag)
    syntax(>->) := syntax(++)
    (>->) := Implication(noTag)
    if ["+", "--", "*", "//", "%"].any((=*= lexeme))
        natural := getNaturalType(globals)
        Just(natural >-> natural >-> natural)
    if ["=", "=/=", "<", ">", "<=", ">="].any((=*= lexeme))
        natural := getNaturalType(globals)
        boolean := getBooleanType(globals)
        Just(natural >-> natural >-> boolean)
    if lexeme =*= "up"
        natural := getNaturalType(globals)
        Just(natural >-> natural)
    if lexeme =*= "abort"
        stringType := getStringType(globals, tag)
        Just(stringType >-> Wildcard(veil(tag)))
    Void


def bindOperation(getBuiltin, globals, tag, term)
    maybe (arity, operator) := getBuiltin(tag)
    maybe type := getOperationType(globals, tag)
    Just(Operation(tag, type, term, Optimization(arity, operator)))


def bindGlobal(globals, tag)
    globals.lookup(getTagLexeme(tag)).mapJust(getGlobalConstant)


def bindPseudoOperation(getBuiltin, globals, tag)
    if getTagLexeme(tag) =*= "abort"
        # the abort operation never returns, so the fallback term will never
        # be used and we can just let it be Wildcard
        bindOperation(getBuiltin, globals, tag, Wildcard(tag))
    Void


def bindName(getBuiltin, globals, locals, tag)
    if isUnused(tag)
        syntaxError("cannot reference a symbol starting with underscore", tag)
    bindLocal(locals, tag) ??
        bindGlobal(globals, tag) ??
        bindPseudoOperation(getBuiltin, globals, tag) ??
        syntaxError("undefined symbol", tag)


def getADTName(constructor)
    if constructor is Constructor(_, _, adtType, _, _, _)
        getLexeme(getHead(adtType))
    astSyntaxError("invalid constructor", constructor)


def getConstructionTypeAST(constructor)
    if constructor is Constructor(_, _, adtType, _, _, _)
        getArguments(adtType).fold(ImplicitArrow, adtType)
    astSyntaxError("invalid constructor", constructor)


def constructCaseAnnotation(tag, constructors)
    if isNil(constructors)
        throwError("Type error: no cases:", tag)
    if not constructors.all(isConstructor)
        throwError("Type error: invalid cases:", tag)
    adtNames := deduplicateBy((=*=), constructors.map(getADTName))
    counts := deduplicate(constructors.map(maybeCount).prune)
    if length(adtNames) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? throwError("Type error: invalid cases", tag)
    indices := deduplicate(constructors.map(maybeConstructorIndex).prune)
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)

    constructor := safeHead(constructors) ??
        throwError("Type error: invalid cases", tag)
    getConstructionTypeAST(constructor)


def buildCaseAnnotation(tag, constructorNames, globals)
    if constructorNames.map(getLexeme).map(`lookup(globals)).sequence is
            Just(constructorGlobals)
        constructors := constructorGlobals.map(getGlobalAST)
        Just(constructCaseAnnotation(tag, constructors))
    Void


def bind(getBuiltin, globals, locals, node)
    bind' := bind(getBuiltin, globals)
    match node
        case Reference(tag, debruijn)
            if debruijn = 0
                lift bindName(getBuiltin, globals, locals, tag)
            lift Variable(tag, debruijn)
        case Arrow(tag, arrowType, constructorNames,
                   parameter, annotation, body)
            if arrowType is Double
                parameterTerm <- parameter.bind'(locals)
                # todo: add support for names on left side of double arrows
                locals' := locals.pushParameter(Name(veil(tag)))
                bodyTerm <- body.bind'(locals')
                lift Implication(tag, parameterTerm, bodyTerm)

            if arrowType is Squiggle
                domain <- (
                    if annotation is Just(type)
                        type' <- type.bind'(locals)
                        lift Just(type')
                    lift Void
                )
                metavariable <- newMetaVariable(getTag(parameter))
                locals' := locals.pushInline(parameter, metavariable)
                body.bind'(locals')

            locals' := locals.pushParameter(parameter)
            (bodyTerm, codomain) <- (
                if body is ColonPair(_, body', type)
                    bodyTerm <- body'.bind'(locals')
                    codomain <- type.bind'(locals')
                    lift (bodyTerm, codomain)
                bodyTerm <- body.bind'(locals')
                lift (bodyTerm, Wildcard(veil(tag)))
            )
            if isNil(constructorNames)
                domain <- (
                    if annotation is Just(type)
                        type.bind'(locals)
                    newMetaVariable(veil(tag))
                )
                lift Function(getTag(parameter), False,
                    domain, codomain, bodyTerm)
            if not isVoid(annotation)
                astSyntaxError("parameter annotation not permitted on case",
                    node)
            if buildCaseAnnotation(tag, constructorNames, globals) is
                    Just(typeAST)
                domain <- typeAST.bind'(locals)
                lift CaseFunction(getTag(parameter), domain, codomain, bodyTerm)
            astSyntaxError("invalid constructors", node)
        case Juxtaposition(tag, left, right)
            leftTerm <- left.bind'(locals)
            rightTerm <- right.bind'(locals)
            lift Application(tag, leftTerm, rightTerm)
        case Let(tag, isTypeConstructor, name, value, scope)
            if isTypeConstructor
                astSyntaxError("type constructors must be at the top level",
                    node)
            domain <- newMetaVariable(veil(tag))
            codomain := Wildcard(veil(tag))
            valueTerm <- value.bind'(locals)
            locals' := locals.pushParameter(name)
            body <- scope.bind'(locals')
            abstraction := Function(getTag(name), False, domain, codomain, body)
            lift Application(tag, abstraction, valueTerm)
        case Number(tag, value)
            lift Numeral(tag, getNaturalType(globals), value)
        case Definition(_, _, _, _)
            astSyntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            astSyntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            astSyntaxError("comma not inside brackets", node)
        case ColonPair(_, _, _)
            astSyntaxError("colon not in valid location", node)
        case SetBuilder(_, _)
            astSyntaxError("must appear on the right side of '::='", node)
        case ADT(tag, parameters, objectType, signatures)
            parameterTerms <- parameters.mapState(bind'(locals))
            objectTerm <- objectType.bind'(locals)
            signatureTerms <- signatures.mapState(bind'(locals))
            lift Construction(tag, parameterTerms, objectTerm, signatureTerms)
        case Constructor(tag, type, adtType, function, count, index)
            type' <- type.bind'(locals)
            if function is Number(_, value)
                lift Numeral(tag, type', value)
            functionTerm <- function.bind'(locals)
            lift Element(tag, type', functionTerm)
        case TypedNode(tag, typeAST, node)
            type <- typeAST.bind'(locals)
            term <- node.bind'(locals)
            lift Element(tag, type, term)


def bindGlobal(getBuiltin, globals, node)
    locals := (0, newDictionary([]))
    metacontext := newArray([])
    bind(getBuiltin, globals, locals, node, metacontext)


def bindDefinition(getBuiltin, state, (tag, node))
    (bindings, globals, environment) := state
    (term, metacontext) := bindGlobal(getBuiltin, globals, node)
    # note: operations can only be defined at the top level
    definiens := bindOperation(getBuiltin, globals, tag, term) ?? term
    closure := Closure(definiens, environment)
    (index, environment') := environment.append(closure)
    global := Global(node, definiens, Constant(tag, index))
    globals' := globals.insert(getTagLexeme(tag), global)
    binding := Binding(tag, MetaClosure(metacontext, closure))
    (binding :: bindings, globals', environment')


def getDefinitions(node)
    if node is Let(tag, isTypeConstructor, name, value, scope)
        (getTag(name), value) :: getDefinitions(scope)
    [(veil(getTag(node)), node)]


def bindAST(getBuiltin, node)
    # TODO: make state a parameter so we can bind with an existing state
    state := ([], newDictionary([]), newArray([]))
    state' := getDefinitions(node).cascade(bindDefinition(getBuiltin), state)
    (bindings, _globals, _environment) := state'
    bindings  # top level bindings in reverse order

#*
