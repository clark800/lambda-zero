#* bind.zero

Local ::= {
    Parameter(level : â„•),
    Inline(term : Term)
}

GlobalT ::= {Global(
    ast : AST,
    term : Term,
    constant : Term
)}

BindingT ::= {Binding(
    tag : TagT,
    closure : ClosureT(Term)
)}

getGlobalAST(Global(ast, _, _)) := ast
getGlobalTerm(Global(_, term, _)) := term
getGlobalConstant(Global(_, _, constant)) := constant

getBindingTag(Binding(tag, _)) := tag
getBindingClosure(Binding(_, closure)) := closure

def bindLocal((level, table), tag)
    maybe item := table.lookup(getTagLexeme(tag))
    match item
        case Parameter(level')
            Just(Variable(tag, level -- level'))
        case Inline(term)
            Just(term)


def pushParameter(parameter, (level, table))
    (up level, table.insert(getLexeme(parameter), Parameter(level)))


def pushInline(parameter, term, (level, table))
    (level, table.insert(getLexeme(parameter), Inline(term)))


def findType(lexeme, globals)
    if globals.lookup(lexeme) is Just(Global(_, term, _))
        if term is Element(_, type, _)
            Just(type)
        if term is Numeral(_, type, _)
            Just(type)
        Void
    Void


def getNaturalType(globals)
    globals.findType("0") ?? Variable(renameTag(noTag, "#NATURAL#", NOFIX), 0)


def getBooleanType(globals)
    globals.findType("False") ??
        Variable(renameTag(noTag, "#BOOLEAN#", NOFIX), 0)


def getStringType(globals, tag)
    natural := getNaturalType(globals)
    listType := globals.findType("[]") ?? syntaxError("List not defined", tag)
    if listType is MetaFunction(_, _, listApplication)
        if listApplication is Application(_, listTypeConstructor, _)
            Application(noTag, listTypeConstructor, natural)
        pass
    syntaxError("List type invalid: " ++ showTerm(listType), tag)


def getOperationType(globals, tag)
    lexeme := getTagLexeme(tag)
    syntax(=>>) := syntax(++)
    (=>>) := Implication(noTag)
    if ["+", "--", "*", "//", "%"].any((=*= lexeme))
        natural := getNaturalType(globals)
        Just(natural =>> natural =>> natural)
    if ["=", "=/=", "<", ">", "<=", ">="].any((=*= lexeme))
        natural := getNaturalType(globals)
        boolean := getBooleanType(globals)
        Just(natural =>> natural =>> boolean)
    if lexeme =*= "up"
        natural := getNaturalType(globals)
        Just(natural =>> natural)
    if lexeme =*= "abort"
        stringType := getStringType(globals, tag)
        tag' := veil(tag)
        type := stringType =>> Variable(tag', 2)
        Just(MetaFunction(tag', Universe(tag', 0), type))
    Void


def bindOperation(getBuiltin, globals, tag, term)
    maybe (arity, operator) := getBuiltin(tag)
    maybe type := getOperationType(globals, tag)
    Just(Operation(tag, type, term, Optimization(arity, operator)))


def bindGlobal(globals, tag)
    globals.lookup(getTagLexeme(tag)).mapJust(getGlobalConstant)


def bindPseudoOperation(getBuiltin, globals, tag)
    if getTagLexeme(tag) =*= "abort"
        # the abort operation never returns, so the fallback term will never
        # be used and we can just let it be Unknown
        bindOperation(getBuiltin, globals, tag, Unknown(tag))
    Void


def bindName(getBuiltin, globals, locals, tag)
    if isUnused(tag)
        syntaxError("cannot reference a symbol starting with underscore", tag)
    bindLocal(locals, tag) ??
        bindGlobal(globals, tag) ??
        bindPseudoOperation(getBuiltin, globals, tag) ??
        syntaxError("undefined symbol", tag)


def getADTName(constructor)
    if constructor is Constructor(_, _, adtType, _, _, _)
        getLexeme(getHead(adtType))
    astSyntaxError("invalid constructor", constructor)


def getConstructionTypeAST(constructor)
    if constructor is Constructor(_, _, adtType, _, _, _)
        getArguments(adtType).fold(MetaArrow, adtType)
    astSyntaxError("invalid constructor", constructor)


def constructCaseAnnotation(tag, constructors)
    if isNil(constructors)
        throwError("Type error: no cases:", tag)
    if not constructors.all(isConstructor)
        throwError("Type error: invalid cases:", tag)
    adtNames := deduplicateBy((=*=), constructors.map(getADTName))
    counts := deduplicate(constructors.map(maybeCount).prune)
    if length(adtNames) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? throwError("Type error: invalid cases", tag)
    indices := deduplicate(constructors.map(maybeConstructorIndex).prune)
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)

    constructor := safeHead(constructors) ??
        throwError("Type error: invalid cases", tag)
    getConstructionTypeAST(constructor)


def buildCaseAnnotation(tag, constructorNames, globals)
    if constructorNames.map(getLexeme).map(`lookup(globals)).sequence is
            Just(constructorGlobals)
        constructors := constructorGlobals.map(getGlobalAST)
        Just(constructCaseAnnotation(tag, constructors))
    Void


def bind(getBuiltin, globals, locals, node)
    bind' := bind(getBuiltin, globals)
    match node
        case Reference(tag, debruijn)
            if debruijn = 0
                bindName(getBuiltin, globals, locals, tag)
            Variable(tag, debruijn)
        case Arrow(tag, arrowType, constructorNames,
                   parameter, annotation, body)
            tag' := veil(tag)
            wildcard := MetaFunction(tag', Universe(tag', 0), Variable(tag', 1))
            if arrowType is Double
                parameterTerm := parameter.bind'(locals)
                # todo: add support for names on left side of double arrows
                bodyTerm := body.bind'(locals.pushParameter(Name(veil(tag))))
                Implication(tag, parameterTerm, bodyTerm)

            locals' := locals.pushParameter(parameter)

            if arrowType is Squiggle
                domain := annotation.mapJust(bind'(locals)) ?? wildcard
                MetaFunction(getTag(parameter), domain, body.bind'(locals'))

            (bodyTerm, codomain) := (
                if body is ColonPair(_, body', type)
                    (body'.bind'(locals'), type.bind'(locals'))
                (body.bind'(locals'), wildcard)
            )
            if isNil(constructorNames)
                domain := annotation.mapJust(bind'(locals)) ?? wildcard
                Function(getTag(parameter), False, domain, codomain, bodyTerm)
            if not isVoid(annotation)
                astSyntaxError("parameter annotation not permitted on case",
                    node)
            if buildCaseAnnotation(tag, constructorNames, globals) is
                    Just(typeAST)
                domain := typeAST.bind'(locals)
                CaseFunction(getTag(parameter), domain, codomain, bodyTerm)
            astSyntaxError("invalid constructors", node)
        case Juxtaposition(tag, left, right)
            Application(tag, left.bind'(locals), right.bind'(locals))
        case Let(tag, isTypeConstructor, name, value, scope)
            if isTypeConstructor
                astSyntaxError("type constructors must be at the top level",
                    node)
            tag' := veil(tag)
            wildcard := MetaFunction(tag', Universe(tag', 0), Variable(tag', 1))
            valueTerm := value.bind'(locals)
            body := scope.bind'(locals.pushParameter(name))
            abstraction := Function(getTag(name), False,
                wildcard, wildcard, body)
            Application(tag, abstraction, valueTerm)
        case Number(tag, value)
            Numeral(tag, getNaturalType(globals), value)
        case Definition(_, _, _, _)
            astSyntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            astSyntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            astSyntaxError("comma not inside brackets", node)
        case ColonPair(_, _, _)
            astSyntaxError("colon not in valid location", node)
        case SetBuilder(_, _)
            astSyntaxError("must appear on the right side of '::='", node)
        case ADT(tag, parameters, objectType, signatures)
            parameterTerms := parameters.map(bind'(locals))
            objectTerm := objectType.bind'(locals)
            signatureTerms := signatures.map(bind'(locals))
            Construction(tag, parameterTerms, objectTerm, signatureTerms)
        case Constructor(tag, type, adtType, function, count, index)
            type' := type.bind'(locals)
            if function is Number(_, value)
                Numeral(tag, type', value)
            Element(tag, type', function.bind'(locals))
        case TypedNode(tag, type, node)
            Element(tag, type.bind'(locals), node.bind'(locals))


def bindGlobal(getBuiltin, globals, node)
    locals := (0, newDictionary([]))
    bind(getBuiltin, globals, locals, node)


def bindDefinition(getBuiltin, state, (tag, node))
    (bindings, globals, environment) := state
    term := bindGlobal(getBuiltin, globals, node)
    # note: operations can only be defined at the top level
    definiens := bindOperation(getBuiltin, globals, tag, term) ?? term
    closure := Closure(definiens, environment)
    (index, environment') := environment.append(closure)
    global := Global(node, definiens, Constant(tag, index))
    globals' := globals.insert(getTagLexeme(tag), global)
    (Binding(tag, closure) :: bindings, globals', environment')


def getDefinitions(node)
    if node is Let(tag, isTypeConstructor, name, value, scope)
        (getTag(name), value) :: getDefinitions(scope)
    [(veil(getTag(node)), node)]


def bindAST(getBuiltin, node)
    # TODO: make state a parameter so we can bind with an existing state
    state := ([], newDictionary([]), newArray([]))
    state' := getDefinitions(node).cascade(bindDefinition(getBuiltin), state)
    (bindings, _globals, _environment) := state'
    bindings  # top level bindings in reverse order

#*
