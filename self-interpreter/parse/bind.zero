#* bind.zero

def findParameter((level, table), lexeme)
    table.lookup(lexeme).mapJust(mapFirst((level --)))


def pushParameter(parameter, maybeNode, (level, table))
    (up level, table.insert(getLexeme(parameter), (level, maybeNode)))


def findType(lexeme, globals)
    if globals.lookup(lexeme) is Just(((_, term), _))
        maybeAscription(term)
    Void


def getNaturalType(globals)
    globals.findType("0") ?? Variable(renameTag(noTag, "#NATURAL#", NOFIX), 0)


def getBooleanType(globals)
    globals.findType("False") ??
        Variable(renameTag(noTag, "#BOOLEAN#", NOFIX), 0)


def getStringType(globals, tag)
    natural := getNaturalType(globals)
    listType := globals.findType("[]") ??
        syntaxError("List not defined", tag)
    if listType is Implicit(_, _, type)
        if type is Application(_, left, _)
            Application(noTag, left, natural)
        syntaxError("List type invalid", tag)
    syntaxError("List type invalid", tag)


def getOperationType(globals, tag)
    tag' := veil(tag)
    lexeme := getTagLexeme(tag)
    syntax(>->) := syntax(++)
    (>->) := Implication(noTag)
    if ["+", "--", "*", "//", "%"].any((=*= lexeme))
        natural := getNaturalType(globals)
        Just(natural >-> natural >-> natural)
    if ["=", "=/=", "<", ">", "<=", ">="].any((=*= lexeme))
        natural := getNaturalType(globals)
        boolean := getBooleanType(globals)
        Just(natural >-> natural >-> boolean)
    if lexeme =*= "up"
        natural := getNaturalType(globals)
        Just(natural >-> natural)
    if lexeme =*= "abort"
        string := getStringType(globals, tag)
        Just(Implicit(tag', Top(tag'), string >-> Variable(tag', 2)))
    Void


def bindOperation(getBuiltin, globals, tag, maybeTerm)
    maybe (arity, optimize) := getBuiltin(tag)
    maybe type := getOperationType(globals, tag)
    Just(Operation(tag, type, maybeTerm, arity, optimize))


def bindVariable(locals, tag)
    lexeme := getTagLexeme(tag)
    maybe (debruijn, maybeValue) := findParameter(locals, lexeme)
    Just(Variable(tag, debruijn))


def bindContextTerm(globals, tag)
    globals.lookup(getTagLexeme(tag)).mapJust(second)


def bindPseudoOperation(getBuiltin, globals, tag)
    if getTagLexeme(tag) =*= "abort"
        bindOperation(getBuiltin, globals, tag, Void)
    Void


def bindName(getBuiltin, globals, locals, tag)
    if isUnused(tag)
        syntaxError("cannot reference a symbol starting with underscore", tag)
    bindVariable(locals, tag) ??
        bindContextTerm(globals, tag) ??
        bindPseudoOperation(getBuiltin, globals, tag) ??
        syntaxError("undefined symbol", tag)


def getADTName(constructor)
    if constructor is Constructor(_, _, adtType, _, _, _)
        getLexeme(getHead(adtType))
    astSyntaxError("invalid constructor", constructor)


def getConstructionTypeAST(constructor)
    if constructor is Constructor(_, _, adtType, _, _, _)
        getArguments(adtType).fold(ImplicitArrow, adtType)
    astSyntaxError("invalid constructor", constructor)


def constructCaseAnnotation(tag, constructors)
    if isNil(constructors)
        throwError("Type error: no cases:", tag)
    if not constructors.all(isConstructor)
        throwError("Type error: invalid cases:", tag)
    adtNames := deduplicateBy((=*=), constructors.map(getADTName))
    counts := deduplicate(constructors.map(maybeCount).prune)
    if length(adtNames) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? throwError("Type error: invalid cases", tag)
    indices := deduplicate(constructors.map(maybeConstructorIndex).prune)
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)

    constructor := safeHead(constructors) ??
        throwError("Type error: invalid cases", tag)
    getConstructionTypeAST(constructor)


def buildCaseAnnotation(tag, constructorNames, globals)
    if constructorNames.map(getLexeme).map(`lookup(globals)).sequence is
            Just(constructorPairs)
        constructors := constructorPairs.map(first).map(first)
        Just(constructCaseAnnotation(tag, constructors))
    Void


def bind(getBuiltin, globals, locals, node)
    bind' := bind(getBuiltin, globals)
    match node
        case Reference(tag, debruijn)
            if debruijn = 0
                bindName(getBuiltin, globals, locals, tag)
            Variable(tag, debruijn)
        case Arrow(tag, arrowType, constructorNames,
                   parameter, annotation, body)
            if arrowType is Double
                parameterTerm := parameter.bind'(locals)
                # todo: add support for names on left side of double arrows
                locals' := locals.pushParameter(Name(veil(tag)), Void)
                bodyTerm := body.bind'(locals')
                Implication(tag, parameterTerm, bodyTerm)

            if arrowType is Squiggle
                locals' := locals.pushParameter(parameter, Void)
                bodyTerm := body.bind'(locals')
                Implicit(tag, Top(tag), bodyTerm)

            locals' := locals.pushParameter(parameter, Void)
            (bodyTerm, codomain) := (
                if body is ColonPair(_, body', type)
                    (body'.bind'(locals'), type.bind'(locals'))
                (body.bind'(locals'), MetaVariable(veil(tag), 0))
            )
            if isNil(constructorNames)
                domain := annotation.mapJust(bind'(locals)) ??
                    MetaVariable(veil(tag), 0)
                Function(getTag(parameter), False, domain, codomain, bodyTerm)
            if not isVoid(annotation)
                astSyntaxError("parameter annotation not permitted on case",
                    node)
            if buildCaseAnnotation(tag, constructorNames, globals) is
                    Just(typeAST)
                domain := typeAST.bind'(locals)
                CaseFunction(getTag(parameter), domain, codomain, bodyTerm)
            astSyntaxError("invalid constructors", node)
        case Juxtaposition(tag, left, right)
            Application(tag, left.bind'(locals), right.bind'(locals))
        case Let(tag, isTypeConstructor, name, value, scope)
            if isTypeConstructor
                astSyntaxError("type constructors must be at the top level",
                    node)
            valueTerm := value.bind'(locals)
            locals' := locals.pushParameter(name, Just((value, valueTerm)))
            scopeTerm := scope.bind'(locals')
            abstraction := FreeFunction(getTag(name), scopeTerm)
            Application(tag, abstraction, valueTerm)
        case Number(tag, value)
            Numeral(tag, getNaturalType(globals), value)
        case Definition(_, _, _, _)
            astSyntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            astSyntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            astSyntaxError("comma not inside brackets", node)
        case ColonPair(_, _, _)
            astSyntaxError("colon not in valid location", node)
        case SetBuilder(_, _)
            astSyntaxError("must appear on the right side of '::='", node)
        case ADT(tag, parameters, objectType, signatures)
            Construction(tag, parameters.map(bind'(locals)),
                objectType.bind'(locals), signatures.map(bind'(locals)))
        case Constructor(tag, type, adtType, function, count, index)
            type' := type.bind'(locals)
            if function is Number(_, value)
                Numeral(tag, type', value)
            Element(tag, type', function.bind'(locals))
        case TypedNode(tag, typeAST, node)
            type := typeAST.bind'(locals)
            Element(tag, type, node.bind'(locals))


def bindGlobal(getBuiltin, globals, node)
    locals := (0, newDictionary([]))
    bind(getBuiltin, globals, locals, node)


def bindDefinition(getBuiltin, state, (tag, node))
    (tags, globals, environment) := state
    term := bindGlobal(getBuiltin, globals, node)
    # note: operations can only be defined at the top level
    definiens := bindOperation(getBuiltin, globals, tag, Just(term)) ?? term
    (index, environment') := environment.append(Closure(definiens, environment))
    constant := Constant(tag, index)
    globals' := globals.insert(getTagLexeme(tag), ((node, definiens), constant))
    (tag :: tags, globals', environment')


def getDefinitions(node)
    if node is Let(tag, isTypeConstructor, name, value, scope)
        (getTag(name), value) :: getDefinitions(scope)
    [(veil(getTag(node)), node)]


def bindAST(getBuiltin, node)
    # TODO: make state a parameter so we can bind with an existing state
    state := ([], newDictionary([]), newArray([]))
    state' := getDefinitions(node).cascade(bindDefinition(getBuiltin), state)
    (tags, globals, environment) := state'
    (reverse(tags), globals, environment)

#*
