#* bind.zero

Local ::= {
    Parameter(level : â„•),
    Inline(term : Term)
}

GlobalT ::= {Global(
    ast : AST,
    term : Term,
    constant : Term
)}

BindingT ::= {Binding(
    tag : TagT,
    closure : ClosureT(Term),
    ascription : (ClosureT(Term))?
)}

getGlobalAST(Global(ast, _, _)) := ast
getGlobalTerm(Global(_, term, _)) := term
getGlobalConstant(Global(_, _, constant)) := constant

getBindingTag(Binding(tag, _, _)) := tag
getBindingClosure(Binding(_, closure, _)) := closure
getBindingAscription(Binding(_, _, ascription)) := ascription

def bindLocal((level, table), tag)
    maybe item := table.lookup(getTagLexeme(tag))
    match item
        case Parameter(level')
            Just(Variable(tag, -_(level -- level')))
        case Inline(term)
            Just(term)


def pushParameter(parameter, (level, table))
    (up level, table.insert(getLexeme(parameter), Parameter(level)))


def pushInline(parameter, term, (level, table))
    (level, table.insert(getLexeme(parameter), Inline(term)))


def getNaturalType(tag, globals)
    if globals.lookup("0") is Just(Global(_, term, _))
        if term is Numeral(_, type, _)
            type
        syntaxError("0 must be a numeral to use numerals", tag)
    syntaxError("must define 0 before using numerals", tag)


def bindOperation(getBuiltin, globals, tag, term)
    maybe (arity, operator) := getBuiltin(tag)
    Just(Operation(tag, term, Optimization(arity, operator)))


def bindGlobal(globals, tag)
    globals.lookup(getTagLexeme(tag)).mapJust(getGlobalConstant)


def bindName(getBuiltin, globals, locals, tag)
    if isUnused(tag)
        syntaxError("cannot reference a symbol starting with underscore", tag)
    bindLocal(locals, tag) ??
        bindGlobal(globals, tag) ??
        syntaxError("undefined symbol", tag)


def getADTName(constructor)
    if constructor is Constructor(_, _, adtType, _, _, _)
        getHead(adtType)
    astSyntaxError("invalid constructor", constructor)


def getTypeConstructor(tag, constructors)
    if isNil(constructors)
        throwError("Type error: no cases:", tag)
    if not constructors.all(isConstructor)
        throwError("Type error: invalid cases:", tag)
    adtNames := constructors.map(getADTName)
    adtLexemes := adtNames.map(getLexeme).deduplicateBy((=*=))
    counts := deduplicate(constructors.map(maybeCount).prune)
    if length(adtLexemes) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? throwError("Type error: invalid cases", tag)
    indices := deduplicate(constructors.map(maybeConstructorIndex).prune)
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)
    safeHead(adtNames) ?? throwError("Type error: invalid cases", tag)


def getTypeFamily(tag, constructorNames, globals)
    if constructorNames.map(getLexeme).map(`lookup(globals)).sequence is
            Just(constructorGlobals)
        constructors := constructorGlobals.map(getGlobalAST)
        typeConstructor := getTypeConstructor(tag, constructors)
        tag' := getTag(typeConstructor)
        if bindGlobal(globals, tag') is Just(constant)
            if constant is Variable(_, index)
                if index is +_ n
                    Type(tag', -_ n)
                pass
            pass
        throwError("Type error: undefined type constructor", tag)
    throwError("Type error: undefined constructor", tag)


def bind(getBuiltin, globals, index, locals, node)
    bind' := bind(getBuiltin, globals, index)
    match node
        case TypeConstant(tag, index)
            Type(tag, index)
        case Reference(tag, debruijn)
            if debruijn = 0
                bindName(getBuiltin, globals, locals, tag)
            Variable(tag, -_ debruijn)
        case Arrow(tag, arrowType, constructorNames,
                   parameter, annotation, body)
            if arrowType is Double
                parameterTerm := parameter.bind'(locals)
                # todo: add support for names on left side of double arrows
                bodyTerm := body.bind'(locals.pushParameter(Name(veil(tag))))
                Implication(tag, parameterTerm, bodyTerm)

            locals' := locals.pushParameter(parameter)

            if arrowType is Tail
                domain := annotation.mapJust(bind'(locals)) ?? Type(tag, +_ 0)
                Intersection(getTag(parameter), domain, body.bind'(locals'))

            bodyTerm := body.bind'(locals')
            if isNil(constructorNames)
                domain := annotation.mapJust(bind'(locals)) ?? Unknown(tag)
                Function(getTag(parameter), domain, bodyTerm)
            if not isVoid(annotation)
                astSyntaxError("parameter annotation not permitted on case",
                    node)
            typeFamily := getTypeFamily(tag, constructorNames, globals)
            if isUnknown(typeFamily)   # force errors
                astSyntaxError("error binding pattern match", node)
            Function(getTag(parameter), typeFamily, bodyTerm)
        case Juxtaposition(tag, left, right)
            Application(tag, left.bind'(locals), right.bind'(locals))
        case Let(tag, isTypeConstructor, name, value, scope)
            if isTypeConstructor
                astSyntaxError("type constructors must be at the top level",
                    node)
            valueTerm := value.bind'(locals)
            body := scope.bind'(locals.pushParameter(name))
            abstraction := Function(getTag(name), Unknown(tag), body)
            Application(tag, abstraction, valueTerm)
        case Number(tag, value)
            Numeral(tag, getNaturalType(tag, globals), value)
        case Definition(_, _, _, _)
            astSyntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            astSyntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            astSyntaxError("comma not inside brackets", node)
        case ColonPair(_, _, _)
            astSyntaxError("colon not in valid location", node)
        case SetBuilder(_, _)
            astSyntaxError("must appear on the right side of '::='", node)
        case ADT(tag, parameters, constructorType, body)
            type := constructorType.bind'(locals)
            domainTerm := Singleton(tag, type, index)
            bodyTerm := body.bind'(locals.pushParameter(Name(tag)))
            Intersection(tag, domainTerm, bodyTerm)
        case Constructor(tag, type, adtType, function, count, index)
            if function is Number(_, value)
                Numeral(tag, type.bind'(locals), value)
            function.bind'(locals)
        case TypedNode(tag, type, function)
            function.bind'(locals)


def bindGlobal(getBuiltin, globals, index, node)
    locals := (0, newDictionary([]))
    bind(getBuiltin, globals, index, locals, node)


def getAscription
    case Constructor(_, type, _, _, _, _) -> Just(type)
    case TypedNode(_, type, _) -> Just(type)
    case _ -> Void


def bindDefinition(getBuiltin, state, (tag, node))
    (bindings, globals, environment) := state
    bindGlobal' := bindGlobal(getBuiltin, globals, getSize(environment))
    term := bindGlobal'(node)
    # note: operations can only be defined at the top level
    definiens := bindOperation(getBuiltin, globals, tag, term) ?? term
    closure := Closure(definiens, environment)
    ascription := getAscription(node).mapJust(type ->
        Closure(bindGlobal'(type), environment))

    (index, environment') := environment.append(closure)
    global := Global(node, definiens, Variable(tag, +_ index))
    globals' := globals.insert(getTagLexeme(tag), global)
    (Binding(tag, closure, ascription) :: bindings, globals', environment')


def getDefinitions(node)
    if node is Let(tag, isTypeConstructor, name, value, scope)
        (getTag(name), value) :: getDefinitions(scope)
    [(veil(getTag(node)), node)]


def bindAST(getBuiltin, node)
    # TODO: make state a parameter so we can bind with an existing state
    state := ([], newDictionary([]), newArray([]))
    state' := getDefinitions(node).cascade(bindDefinition(getBuiltin), state)
    (bindings, _globals, _environment) := state'
    bindings  # top level bindings in reverse order

#*
