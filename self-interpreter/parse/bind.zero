#* bind.zero

Local ::= {
    Parameter(level : â„•),
    Inline(term : Term)
}

GlobalT ::= {Global(
    ast : AST,
    term : Term,
    constant : Term
)}

BindingT ::= {Binding(
    tag : TagT,
    closure : ClosureT(Term)
)}

getGlobalAST(Global(ast, _, _)) := ast
getGlobalTerm(Global(_, term, _)) := term
getGlobalConstant(Global(_, _, constant)) := constant

getBindingTag(Binding(tag, _)) := tag
getBindingClosure(Binding(_, closure)) := closure

def bindLocal((level, table), tag)
    maybe item := table.lookup(getTagLexeme(tag))
    match item
        case Parameter(level')
            Just(Variable(tag, -_(level -- level')))
        case Inline(term)
            Just(term)


def pushParameter(parameter, (level, table))
    (up level, table.insert(getLexeme(parameter), Parameter(level)))


def pushInline(parameter, term, (level, table))
    (level, table.insert(getLexeme(parameter), Inline(term)))


def findType(lexeme, globals)
    if globals.lookup(lexeme) is Just(Global(_, term, _))
        if term is Element(_, type, _)
            Just(type)
        if term is Numeral(_, type, _)
            Just(type)
        Void
    Void


def getNaturalType(tag, globals)
    globals.findType("0") ??
        syntaxError("must define 0 before using numerals", tag)


def bindOperation(getBuiltin, globals, tag, term)
    maybe (arity, operator) := getBuiltin(tag)
    Just(Operation(tag, term, Optimization(arity, operator)))


def bindGlobal(globals, tag)
    globals.lookup(getTagLexeme(tag)).mapJust(getGlobalConstant)


def bindName(getBuiltin, globals, locals, tag)
    if isUnused(tag)
        syntaxError("cannot reference a symbol starting with underscore", tag)
    bindLocal(locals, tag) ??
        bindGlobal(globals, tag) ??
        syntaxError("undefined symbol", tag)


def getADTName(constructor)
    if constructor is Constructor(_, _, adtType, _, _, _)
        getLexeme(getHead(adtType))
    astSyntaxError("invalid constructor", constructor)


def getConstructionTypeAST(constructor)
    if constructor is Constructor(_, _, adtType, _, _, _)
        getArguments(adtType).fold(MetaArrow, adtType)
    astSyntaxError("invalid constructor", constructor)


def constructCaseAnnotation(tag, constructors)
    if isNil(constructors)
        throwError("Type error: no cases:", tag)
    if not constructors.all(isConstructor)
        throwError("Type error: invalid cases:", tag)
    adtNames := deduplicateBy((=*=), constructors.map(getADTName))
    counts := deduplicate(constructors.map(maybeCount).prune)
    if length(adtNames) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? throwError("Type error: invalid cases", tag)
    indices := deduplicate(constructors.map(maybeConstructorIndex).prune)
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)

    constructor := safeHead(constructors) ??
        throwError("Type error: invalid cases", tag)
    getConstructionTypeAST(constructor)


def buildCaseAnnotation(tag, constructorNames, globals)
    if constructorNames.map(getLexeme).map(`lookup(globals)).sequence is
            Just(constructorGlobals)
        constructors := constructorGlobals.map(getGlobalAST)
        Just(constructCaseAnnotation(tag, constructors))
    Void


def bind(getBuiltin, globals, locals, node)
    bind' := bind(getBuiltin, globals)
    match node
        case Reference(tag, debruijn)
            if debruijn = 0
                bindName(getBuiltin, globals, locals, tag)
            Variable(tag, -_ debruijn)
        case Arrow(tag, arrowType, constructorNames,
                   parameter, annotation, body)
            if arrowType is Double
                parameterTerm := parameter.bind'(locals)
                # todo: add support for names on left side of double arrows
                bodyTerm := body.bind'(locals.pushParameter(Name(veil(tag))))
                Implication(tag, parameterTerm, bodyTerm)

            locals' := locals.pushParameter(parameter)

            if arrowType is Squiggle
                domain := annotation.mapJust(bind'(locals)) ?? Universe(tag, 0)
                MetaFunction(getTag(parameter), domain, body.bind'(locals'))

            bodyTerm := body.bind'(locals')
            if isNil(constructorNames)
                domain := annotation.mapJust(bind'(locals))
                type := domain.mapJust(Domain) ?? Inferred
                Function(getTag(parameter), type, bodyTerm)
            if not isVoid(annotation)
                astSyntaxError("parameter annotation not permitted on case",
                    node)
            if buildCaseAnnotation(tag, constructorNames, globals) is
                    Just(typeAST)
                domain := typeAST.bind'(locals)
                Function(getTag(parameter), PatternMatch(domain), bodyTerm)
            astSyntaxError("invalid constructors", node)
        case Juxtaposition(tag, left, right)
            Application(tag, left.bind'(locals), right.bind'(locals))
        case Let(tag, isTypeConstructor, name, value, scope)
            if isTypeConstructor
                astSyntaxError("type constructors must be at the top level",
                    node)
            valueTerm := value.bind'(locals)
            body := scope.bind'(locals.pushParameter(name))
            abstraction := Function(getTag(name), Inferred, body)
            Application(tag, abstraction, valueTerm)
        case Number(tag, value)
            Numeral(tag, getNaturalType(tag, globals), value)
        case Definition(_, _, _, _)
            astSyntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            astSyntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            astSyntaxError("comma not inside brackets", node)
        case ColonPair(_, _, _)
            astSyntaxError("colon not in valid location", node)
        case SetBuilder(_, _)
            astSyntaxError("must appear on the right side of '::='", node)
        case ADT(tag, parameters, objectType, signatures)
            parameterTerms := parameters.map(bind'(locals))
            objectTerm := objectType.bind'(locals)
            signatureTerms := signatures.map(bind'(locals))
            Construction(tag, parameterTerms, objectTerm, signatureTerms)
        case Constructor(tag, type, adtType, function, count, index)
            type' := type.bind'(locals)
            if function is Number(_, value)
                Numeral(tag, type', value)
            Element(tag, type', function.bind'(locals))
        case TypedNode(tag, type, node)
            Element(tag, type.bind'(locals), node.bind'(locals))


def bindGlobal(getBuiltin, globals, node)
    locals := (0, newDictionary([]))
    bind(getBuiltin, globals, locals, node)


def bindDefinition(getBuiltin, state, (tag, node))
    (bindings, globals, environment) := state
    term := bindGlobal(getBuiltin, globals, node)
    # note: operations can only be defined at the top level
    definiens := bindOperation(getBuiltin, globals, tag, term) ?? term
    closure := Closure(definiens, environment)
    (index, environment') := environment.append(closure)
    global := Global(node, definiens, Variable(tag, +_ index))
    globals' := globals.insert(getTagLexeme(tag), global)
    (Binding(tag, closure) :: bindings, globals', environment')


def getDefinitions(node)
    if node is Let(tag, isTypeConstructor, name, value, scope)
        (getTag(name), value) :: getDefinitions(scope)
    [(veil(getTag(node)), node)]


def bindAST(getBuiltin, node)
    # TODO: make state a parameter so we can bind with an existing state
    state := ([], newDictionary([]), newArray([]))
    state' := getDefinitions(node).cascade(bindDefinition(getBuiltin), state)
    (bindings, _globals, _environment) := state'
    bindings  # top level bindings in reverse order

#*
