#* bind.zero

GlobalT ::= {Global(index : â„•, ast : AST, term : Term)}

BindingT ::= {Binding(
    tag : TagT,
    closure : ClosureT(Term),
    ascription : (ClosureT(Term))?
)}

getGlobalIndex(Global(index, _, _)) := index
getGlobalAST(Global(_, ast, _)) := ast
getGlobalTerm(Global(_, _, term)) := term

getBindingTag(Binding(tag, _, _)) := tag
getBindingClosure(Binding(_, closure, _)) := closure
getBindingAscription(Binding(_, _, ascription)) := ascription


def pushParameter(parameter, (level, table))
    (up level, table.insert(getLexeme(parameter), level))


def newVariable(tag, negative, index, level, level')
    tag' := if level' < index then setGlobal(tag) else tag
    debruijn := level -- level'
    Variable(tag', if negative then -_ debruijn else +_ debruijn)


def bindVariable(parameters @ (level, table), index, negative, tag)
    table.lookup(getTagLexeme(tag)).mapJust(
        newVariable(tag, negative, index, level))


def bindName(getBuiltin, parameters, index, negative, tag)
    if isUnused(tag)
        syntaxError("cannot reference a symbol starting with underscore", tag)
    bindVariable(parameters, index, negative, tag) ??
        syntaxError("undefined symbol", tag)


def bindOperation(getBuiltin, tag, term)
    maybe (arity, operator) := getBuiltin(tag)
    Just(Operation(tag, term, Optimization(arity, operator)))


def getADTName(constructor)
    if constructor is Constructor(_, _, adtType, _, _, _)
        getHead(adtType)
    astSyntaxError("invalid constructor", constructor)


def getTypeConstructor(tag, constructors)
    if isNil(constructors)
        throwError("Type error: no cases:", tag)
    if not constructors.all(isConstructor)
        throwError("Type error: invalid cases:", tag)
    adtNames := constructors.map(getADTName)
    adtLexemes := adtNames.map(getLexeme).deduplicateBy((=*=))
    counts := deduplicate(constructors.map(maybeCount).sift)
    if length(adtLexemes) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? throwError("Type error: invalid cases", tag)
    indices := deduplicate(constructors.map(maybeConstructorIndex).sift)
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)
    safeHead(adtNames) ?? throwError("Type error: invalid cases", tag)


def getConstructorFamily(tag, constructorNames, globals)
    if constructorNames.map(getLexeme).map(`lookup(globals)).collect is
            Just(constructorGlobals)
        constructors := constructorGlobals.map(getGlobalAST)
        typeConstructor := getTypeConstructor(tag, constructors)
        adtLexeme := getTagLexeme(getTag(typeConstructor))
        if globals.lookup(adtLexeme) is Just(Global(index, _, _))
            Type(getTag(typeConstructor), -_ index)
        throwError("Type error: undefined type constructor", tag)
    throwError("Type error: undefined constructor", tag)


def getNaturalName(tag, globals)
    if globals.lookup("0") is Just(Global(_, _, term))
        if term is Numeral(_, type, _)
            Name(getTermTag(type))
        syntaxError("0 must be a numeral to use numerals", tag)
    syntaxError("must define 0 before using numerals", tag)


def bind(getBuiltin, globals, index, parameters, node)
    bind' := bind(getBuiltin, globals, index, parameters)
    bind''(p) := bind(getBuiltin, globals, index, parameters.pushParameter(p))

    match node
        case Family(tag)
            Type(tag, -_ index)
        case Reference(tag, debruijn)
            if abs(debruijn) > 0
                Variable(tag, debruijn)
            bindName(getBuiltin, parameters, index, isNegative(debruijn), tag)
        case Arrow(tag, arrowType, constructorNames,
                   parameter, annotation, body)
            if arrowType is Double
                # todo: add support for names on left side of double arrows
                Implication(tag, bind'(parameter), body.bind''(Name(veil(tag))))

            if arrowType is Tail
                domain := annotation.mapJust(bind') ?? Type(tag, +_ 0)
                Intersection(getTag(parameter), domain, body.bind''(parameter))

            bodyTerm := body.bind''(parameter)
            if isNil(constructorNames)
                domain := annotation.mapJust(bind') ?? Unknown(tag)
                Function(getTag(parameter), domain, bodyTerm)
            if not isVoid(annotation)
                astSyntaxError("parameter annotation not permitted on case",
                    node)
            typeFamily := getConstructorFamily(tag, constructorNames, globals)
            if isUnknown(typeFamily)   # force errors
                astSyntaxError("error binding pattern match", node)
            Function(getTag(parameter), typeFamily, bodyTerm)
        case Juxtaposition(tag, left, right)
            Application(tag, bind'(left), bind'(right))
        case Let(tag, isTypeConstructor, name, value, scope)
            if isTypeConstructor
                astSyntaxError("type constructors must be at the top level",
                    node)
            abstraction := FreeFunction(getTag(name), scope.bind''(name))
            Application(tag, abstraction, bind'(value))
        case Number(tag, value)
            type := bind'(getNaturalName(tag, globals))
            Numeral(tag, type, value)
        case Definition(_, _, _, _)
            astSyntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            astSyntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            astSyntaxError("comma not inside brackets", node)
        case ColonPair(_, _, _)
            astSyntaxError("colon not in valid location", node)
        case SetBuilder(_, _)
            astSyntaxError("must appear on the right side of '::='", node)
        case ADT(tag, adtParameters, constructorType, body)
            domainTerm := Singleton(tag, bind'(constructorType), Unknown(tag))
            Intersection(tag, domainTerm, body.bind''(Name(tag)))
        case Constructor(tag, type, adtType, function, count, index)
            if function is Number(_, value)
                Numeral(tag, bind'(type), value)
            bind'(function)
        case TypedNode(tag, type, function)
            bind'(function)


def getAscription
    case Constructor(_, type, _, _, _, _) -> Just(type)
    case TypedNode(_, type, _) -> Just(type)
    case _ -> Void


def bindDefinition(getBuiltin, state, (tag, node))
    (bindings, parameters, globals, environment) := state
    bindNode := bind(getBuiltin, globals, getSize(environment), parameters)
    term := bindNode(node)
    # note: operations can only be defined at the top level
    definiens := bindOperation(getBuiltin, tag, term) ?? term
    closure := Closure(definiens, environment)
    ascription := getAscription(node).mapJust(type ->
        Closure(bindNode(type), environment))
    bindings' := Binding(tag, closure, ascription) :: bindings

    parameters' := parameters.pushParameter(Name(tag))
    (index, environment') := environment.append(closure)
    global := Global(index, node, definiens)
    globals' := globals.insert(getTagLexeme(tag), global)
    (bindings', parameters', globals', environment')


def getDefinitions(node)
    if node is Let(tag, isTypeConstructor, name, value, scope)
        (getTag(name), value) :: getDefinitions(scope)
    [(veil(getTag(node)), node)]


def bindAST(getBuiltin, node)
    # TODO: make state a parameter so we can bind with an existing state
    parameters := (0, newDictionary([]))
    state := ([], parameters, newDictionary([]), newArray([]))
    state' := getDefinitions(node).cascade(bindDefinition(getBuiltin), state)
    (bindings, _parameters, _globals, _environment) := state'
    bindings  # top level bindings in reverse order

#*
