#* bind.zero

def findParameter(level, stack, lexeme)
    if stack is table :: _
        table.lookup(lexeme).mapJust(mapFirst((level --)))
    Void


def pushParameter(parameter, level, maybeNode, stack)
    lexeme := getLexeme(parameter)
    if stack is top :: stack'
        top.insert(lexeme, (level, maybeNode)) :: stack'
    [newDictionary([(lexeme, (level, maybeNode))])]


def findType(lexeme, context)
    if context.lookup(lexeme) is Just(((_, term), _))
        maybeAscription(term)
    Void


def getNaturalType(context)
    context.findType("0") ?? Variable(renameTag(noTag, "#NATURAL#", NOFIX), 0)


def getBooleanType(context)
    context.findType("False") ??
        Variable(renameTag(noTag, "#BOOLEAN#", NOFIX), 0)


def getStringType(context, tag)
    natural := getNaturalType(context)
    listType := context.findType("[]") ??
        syntaxError("List not defined", tag)
    if listType is Implicit(_, _, type)
        if type is Application(_, left, _)
            Application(noTag, left, natural)
        syntaxError("List type invalid", tag)
    syntaxError("List type invalid", tag)


def getOperationType(context, tag)
    tag' := veil(tag)
    lexeme := getTagLexeme(tag)
    syntax(>->) := syntax(++)
    (>->) := Implication(noTag)
    if ["+", "--", "*", "//", "%"].any((=*= lexeme))
        natural := getNaturalType(context)
        Just(natural >-> natural >-> natural)
    if ["=", "=/=", "<", ">", "<=", ">="].any((=*= lexeme))
        natural := getNaturalType(context)
        boolean := getBooleanType(context)
        Just(natural >-> natural >-> boolean)
    if lexeme =*= "up"
        natural := getNaturalType(context)
        Just(natural >-> natural)
    if lexeme =*= "abort"
        string := getStringType(context, tag)
        Just(Implicit(tag', Top(tag'), string >-> Variable(tag', 2)))
    Void


def bindOperation(getBuiltin, context, tag, maybeTerm)
    maybe (arity, optimize) := getBuiltin(tag)
    maybe type := getOperationType(context, tag)
    Just(Operation(tag, type, maybeTerm, arity, optimize))


def bindVariable(level, stack, tag)
    lexeme := getTagLexeme(tag)
    maybe (debruijn, maybeValue) := findParameter(level, stack, lexeme)
    Just(Variable(tag, debruijn))


def bindContextTerm(context, tag)
    context.lookup(getTagLexeme(tag)).mapJust(second)


def bindPseudoOperation(getBuiltin, context, tag)
    if getTagLexeme(tag) =*= "abort"
        bindOperation(getBuiltin, context, tag, Void)
    Void


def bindName(getBuiltin, level, stack, context, tag)
    if isUnused(tag)
        syntaxError("cannot reference a symbol starting with underscore", tag)
    bindVariable(level, stack, tag) ??
        bindContextTerm(context, tag) ??
        bindPseudoOperation(getBuiltin, context, tag) ??
        syntaxError("undefined symbol", tag)


def getADTName(constructor)
    if constructor is Constructor(_, _, adtType, _, _, _)
        getLexeme(getHead(adtType))
    astSyntaxError("invalid constructor", constructor)


def getConstructionTypeAST(constructor)
    if constructor is Constructor(_, _, adtType, _, _, _)
        getArguments(adtType).fold(ImplicitArrow, adtType)
    astSyntaxError("invalid constructor", constructor)


def constructCaseAnnotation(tag, constructors)
    if isNil(constructors)
        throwError("Type error: no cases:", tag)
    if not constructors.all(isConstructor)
        throwError("Type error: invalid cases:", tag)
    adtNames := deduplicateBy((=*=), constructors.map(getADTName))
    counts := deduplicate(constructors.map(maybeCount).prune)
    if length(adtNames) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? throwError("Type error: invalid cases", tag)
    indices := deduplicate(constructors.map(maybeConstructorIndex).prune)
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)

    constructor := safeHead(constructors) ??
        throwError("Type error: invalid cases", tag)
    getConstructionTypeAST(constructor)


def buildCaseAnnotation(tag, constructorNames, context)
    if constructorNames.map(getLexeme).map(`lookup(context)).sequence is
            Just(constructorPairs)
        constructors := constructorPairs.map(first).map(first)
        Just(constructCaseAnnotation(tag, constructors))
    Void


def bind(getBuiltin, level, stack, context, node)
    bind' := bind(getBuiltin)
    match node
        case Reference(tag, debruijn)
            if debruijn = 0
                bindName(getBuiltin, level, stack, context, tag)
            Variable(tag, debruijn)
        case Arrow(tag, arrowType, constructorNames,
                   parameter, annotation, body)
            if arrowType is Double
                parameterTerm := parameter.bind'(level, stack, context)
                # todo: add support for names on left side of double arrows
                stack' := stack.pushParameter(Name(veil(tag)), level, Void)
                bodyTerm := body.bind'(up level, stack', context)
                Implication(tag, parameterTerm, bodyTerm)

            if arrowType is Squiggle
                stack' := stack.pushParameter(parameter, level, Void)
                bodyTerm := body.bind'(up level, stack', context)
                Implicit(tag, Top(tag), bodyTerm)

            stack' := stack.pushParameter(parameter, level, Void)
            (bodyTerm, codomain) := (
                if body is ColonPair(_, body', type)
                    (body'.bind'(up level, stack', context),
                        type.bind'(up level, stack', context))
                (body.bind'(up level, stack', context),
                    MetaVariable(veil(tag), 0))
            )
            if isNil(constructorNames)
                domain := annotation.mapJust(bind'(level, stack, context)) ??
                    MetaVariable(veil(tag), 0)
                Function(getTag(parameter), False, domain, codomain, bodyTerm)
            if not isVoid(annotation)
                astSyntaxError("parameter annotation not permitted on case", node)
            if buildCaseAnnotation(tag, constructorNames, context) is
                    Just(typeAST)
                domain := typeAST.bind'(level, stack, context)
                CaseFunction(getTag(parameter), domain, codomain, bodyTerm)
            astSyntaxError("invalid constructors", node)
        case Juxtaposition(tag, left, right)
            Application(tag, left.bind'(level, stack, context),
                right.bind'(level, stack, context))
        case Let(tag, isTypeConstructor, name, value, scope)
            if isTypeConstructor
                astSyntaxError("type constructors must be at the top level", node)
            valueTerm := value.bind'(level, stack, context)
            stack' := stack.pushParameter(name, level, Just((value, valueTerm)))
            scopeTerm := scope.bind'(up level, stack', context)
            abstraction := FreeFunction(getTag(name), scopeTerm)
            Application(tag, abstraction, valueTerm)
        case Number(tag, value)
            Numeral(tag, getNaturalType(context), value)
        case Definition(_, _, _, _)
            astSyntaxError("missing scope for definition", node)
        case AsPattern(_, _, _)
            astSyntaxError("as pattern not in parameter position", node)
        case CommaPair(_, _, _)
            astSyntaxError("comma not inside brackets", node)
        case ColonPair(_, _, _)
            astSyntaxError("colon not in valid location", node)
        case SetBuilder(_, _)
            astSyntaxError("must appear on the right side of '::='", node)
        case ADT(tag, parameters, objectType, signatures)
            Construction(tag, parameters.map(bind'(level, stack, context)),
                objectType.bind'(level, stack, context),
                signatures.map(bind'(level, stack, context)))
        case Constructor(tag, type, adtType, function, count, index)
            type' := type.bind'(level, stack, context)
            if function is Number(_, value)
                Numeral(tag, type', value)
            Element(tag, type', function.bind'(level, stack, context))
        case TypedNode(tag, typeAST, node)
            type := typeAST.bind'(level, stack, context)
            Element(tag, type, node.bind'(level, stack, context))


def bindGlobal(getBuiltin, context, node)
    stack := [newDictionary([])]
    bind(getBuiltin, 0, stack, context, node)


def bindDefinition(getBuiltin, state, (tag, node))
    (tags, context, environment) := state
    term := bindGlobal(getBuiltin, context, node)
    # note: operations can only be defined at the top level
    definiens := bindOperation(getBuiltin, context, tag, Just(term)) ?? term
    (index, environment') := environment.append(Closure(definiens, environment))
    constant := Constant(tag, index)
    context' := context.insert(getTagLexeme(tag), ((node, definiens), constant))
    (tag :: tags, context', environment')


def getDefinitions(node)
    if node is Let(tag, isTypeConstructor, name, value, scope)
        (getTag(name), value) :: getDefinitions(scope)
    [(veil(getTag(node)), node)]


def bindAST(getBuiltin, node)
    # TODO: make state a parameter so we can bind with an existing state
    state := ([], newDictionary([]), newArray([]))
    state' := getDefinitions(node).cascade(bindDefinition(getBuiltin), state)
    (tags, context, environment) := state'
    (reverse(tags), context, environment)

#*
