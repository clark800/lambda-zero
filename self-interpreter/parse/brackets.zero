#* brackets.zero

def applyToCommaList(tag, base, arguments)
    with arguments as CommaPair(_, left, right)
        Juxtaposition(tag, applyToCommaList(tag, base, left), right)
    Juxtaposition(tag, base, arguments)


def getCommaListSize(commaList)
    with commaList as CommaPair(_, left, _)
        getCommaListSize(left) + 1
    1


def newTuple(tag, commaList)
    n := getCommaListSize(commaList)
    lexeme := repeat(',').take(n -- 1)
    constructor := FixedName(tag, lexeme)
    applyToCommaList(tag, constructor, commaList)


def getCommaListElements(commaList)
    with commaList as CommaPair(_, left, right)
        getCommaListElements(left) ++ [right]
    [commaList]


def reduceParentheses(open, left, right)
    tag := getOperatorTag(open)
    with right as Just(contents)
        if isDefinition(contents)
            syntaxError("missing scope for definition", contents)
        with left as Just(function)
            applyToCommaList(tag, function, contents)
        if isCommaPair(contents)
            newTuple(tag, contents)
        if isArrow(contents)
            lockArrow(contents)
        with contents as Juxtaposition(_, left, right)
            Juxtaposition(tag, left, right)
        contents
    unit := FixedName(tag, "()")
    with left as Just(function)
        Juxtaposition(tag, function, unit)
    unit


def isPlaceholder(node)
    isThisName(node, "*.") or isThisName(node, ".*")


def reduceOpenSection(open, left, right)
    if not isVoid(left)
        oppSyntaxError("invalid operand before section", open)
    with right as Just(contents)
        with contents as Juxtaposition(_, left', right')
            # check for parenthesized adfix operator
            if isName(left') and isPlaceholder(right')
                left'
            # check for parenthesized infix operator
            with left' as Juxtaposition(_, left'', right'')
                if isThisName(right', "*.") and isThisName(right'', ".*") and
                    isName(left'') then left'' else pass
            LockedArrow(FixedName(getOperatorTag(open), ".*"), contents)
        if isCommaPair(contents)
            oppSyntaxError("comma invalid in section", open)
        pass
    oppSyntaxError("invalid section", open)


def reduceCloseSection(close, left, contents)
    # force evaluation of contents first in case it has an error
    if isTuple(contents)
        oppSyntaxError("comma invalid in section", close)
    if not isVoid(left)
        oppSyntaxError("invalid operand before section", close)
    # check for parenthesized operator
    if isName(contents)
        contents
    with contents as Juxtaposition(_, left', right')
        # check for parenthesized adfix operator
        if isName(left') and isPlaceholder(right')
            left'
        LockedArrow(FixedName(getOperatorTag(close), "*."), contents)
    oppSyntaxError("invalid section", close)


def createList(tag, commaList, list)
    with commaList as CommaPair(_, left, right)
        createList(tag, left, prependList(tag, right, list))
    prependList(tag, commaList, list)


def reduceSquare(open, left, right)
    tag := getOperatorTag(open)
    with right as Just(contents)
        with left as Just(before)
            n := getCommaListSize(contents)
            constructor := FixedName(tag, repeat('[').take(n))
            base := Juxtaposition(tag, constructor, before)
            applyToCommaList(tag, base, contents)
        createList(tag, contents, newNil(tag))
    if isVoid(left)
        newNil(tag)
    oppSyntaxError("missing argument to", open)


def reduceCurly(open, left, right)
    if not isVoid(left)
        oppSyntaxError("invalid operand before", open)
    with right as Just(patterns)
        SetBuilder(getOperatorTag(open), getCommaListElements(patterns))
    SetBuilder(getOperatorTag(open), [])


def reduceOpenFile(open, left, right)
    if not isVoid(left)
        oppSyntaxError("invalid operand before", open)
    with right as Just(contents)
        contents
    oppSyntaxError("no input", open)

#*
