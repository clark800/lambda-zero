#* define.zero

def isTupleConstructor(node)
    isName(node) and getLexeme(node).startsWith(",")


def isTuple(node)
    if node is Juxtaposition(_, left, _)
        isTuple(left)
    isTupleConstructor(node)


def applyPlainDefinition(tag, name, value, scope)
    if isName(name)
        Let(tag, False, name, value, scope)
    Juxtaposition(tag, newPatternArrow(name, scope), value)


def applyMaybeDefinition(tag, name, value, scope)
    Juxtaposition(tag, Juxtaposition(tag, FixedName(tag, "onJust"),
        newPatternArrow(name, scope)), value)


def applyTryDefinition(tag, name, value, scope)
    Juxtaposition(tag, Juxtaposition(tag, FixedName(tag, "onRight"),
        newPatternArrow(name, scope)), value)


def applyFix(name, value)
    tag := getTag(name)
    Juxtaposition(tag, FixedName(tag, "fix"), LockedArrow(name, value))


def transformRecursion(name, value)
    if not isName(name) or not isArrow(value) or not containsName(name, value)
        value
    applyFix(name, value)


def isValidPattern(node)
    if isName(node)
        True
    if node is ColonPair(_, left, _)
        isValidPattern(left)
    if node is Juxtaposition(_, left, right)
        isValidPattern(left) and isValidPattern(right)
    if node is Arrow(_, arrowType, _, left, _, right)
        if arrowType is Double
            isValidPattern(left) and isValidPattern(right)
        False
    False


def isValidConstructorParameter(parameter)
    if parameter is ColonPair(_, left, right)
        isName(left) and isValidPattern(right)
    False


def readParameterTypes(form)
    if form is Juxtaposition(_, left, right)
        if right is ColonPair(_, _, type)
            readParameterTypes(left) ++ [type]
        astSyntaxError("invalid form", form)
    []


def newReconstructorAST'(parameterTypeASTs, returnTypeAST)
    if parameterTypeASTs is parameterTypeAST :: parameterTypeASTs'
        bodyTypeAST := newReconstructorAST'(parameterTypeASTs', returnTypeAST)
        DoubleArrow(parameterTypeAST, bodyTypeAST)
    returnTypeAST


def newReconstructorAST(parameterTypeASTs, adtTypeAST, returnTypeAST)
    typeAST := newReconstructorAST'(parameterTypeASTs, returnTypeAST)
    parameters := getArguments(adtTypeAST)
    parameters.fold(ImplicitArrow, typeAST)


def getConstructorBody(name, n, m, j)
    tag := getTag(name)
    if name is Number(tag, value)
        if value =/= 0
            astSyntaxError("invalid constructor name", name)
        Number(tag, 0)
    if not isName(name)
        astSyntaxError("invalid constructor name", name)
    arguments := reverse(n + 1 .. n + m).map(Underscore(tag))
    base := arguments.cascade(Juxtaposition(tag), Underscore(tag, n -- j))
    (UnderscoreArrow(tag)^<>(n + m))(base)


def newConstructorDefinition(tag, adtType, dataType, n, (form, j), scope)
    parameters := getArguments(form)
    m := length(parameters)
    name := getHead(form)
    body := getConstructorBody(name, n, m, j)
    if not isPreterm(body)
        astSyntaxError("invalid constructor", name)   # force errors
    parameterTypes := readParameterTypes(form)
    constructor := Constructor(getTag(name), parameterTypes,
        adtType, dataType, body, n, j + 1)
    invalidParameters := parameters.filter((not) <> isValidConstructorParameter)
    if invalidParameters is parameter :: _
        astSyntaxError("invalid constructor parameter", parameter)
    applyPlainDefinition(tag, Name(getTag(name)), constructor, scope)


def newFallbackCase(tag, m)
    fallback := Underscore(tag, m + 2)
    instance := Underscore(tag, m + 1)
    body := Juxtaposition(tag, fallback, instance)
    (1 .. m).cascade(b -> _ -> UnderscoreArrow(tag, b), body)


def newDeconstructorType(tag, parameterTypeASTs, adtTypeAST)
    # todo: change name from "r" so it can't clash with user's names
    returnType := FixedName(tag, "r")
    reconstructorType := newReconstructorAST'(parameterTypeASTs, returnType)
    syntax(>->) := syntax(++)
    (>->) := DoubleArrow
    fallbackType := adtTypeAST >-> returnType
    typeAST := reconstructorType >-> fallbackType >-> adtTypeAST >-> returnType
    parameters := getArguments(adtTypeAST)
    ImplicitArrow(returnType, parameters.fold(ImplicitArrow, typeAST))


def newDeconstructorDefinition(tag, adtType, n, ms, (form, j), scope)
    reconstructor := Underscore(tag, 3)
    arguments := (1 .. n).map(k -> if k -- 1 = j then reconstructor else
        newFallbackCase(tag, ms.at(k -- 1) ?? 0))
    body := arguments.cascade(Juxtaposition(tag), Underscore(tag, 1))
    function := UnderscoreArrow(tag, UnderscoreArrow(tag,
        UnderscoreArrow(tag, body)))
    parameterTypes := readParameterTypes(form)
    name := Name(addPrefix(getTag(getHead(form)), '@'))
    type := newDeconstructorType(getTag(name), parameterTypes, adtType)
    deconstructor := TypedNode(getTag(name), type, function)
    applyPlainDefinition(tag, name, deconstructor, scope)


def isValidConstructorAnnotation(dataType, annotation)
    length(getArguments(annotation)) = length(getArguments(dataType)) and
        isThisName(getHead(annotation), getLexeme(getHead(dataType)))


def newConstructorDefinitions'(tag, adtType, dataType, n, ms, formj, scope)
    # define deconstructor first in case the constructor name is the same
    # as the ADT name: this ensures that we always bind the ADT name
    scope' := newConstructorDefinition(tag, adtType, dataType, n, formj, scope)
    newDeconstructorDefinition(tag, adtType, n, ms, formj, scope')


def newConstructorDefinitions(tag, adtType, n, ms, formj, scope)
    if first(formj) is ColonPair(_, form', dataType)
        if not isValidConstructorAnnotation(adtType, dataType)
            astSyntaxError("inconsistent annotation form", dataType)
        newConstructorDefinitions'(tag, adtType, dataType, n, ms,
            (form', second(formj)), scope)
    newConstructorDefinitions'(tag, adtType, adtType, n, ms, formj, scope)


def getAnnotation(node)
    if node is ColonPair(_, _, right)
        right
    astSyntaxError("missing annotation", node)


def newADT(tag, parameters, forms)
    # todo: change name from "r" so it can't clash with user's names
    returnType := FixedName(tag, "r")
    annotations := forms.map(getArguments).map(map(getAnnotation))
    argumentTypes := annotations.map(fold(DoubleArrow, returnType))
    bodyType := argumentTypes.fold(DoubleArrow, returnType)
    objectType := ImplicitArrow(returnType, bodyType)
    ADT(tag, parameters, objectType)


def applyADTDefinition(tag, left, right, scope)
    if right is SetBuilder(_, forms)
        n := length(forms)
        ms := forms.map(length <> getArguments)
        scope' := zip(forms, 0...).fold(
            newConstructorDefinitions(tag, left, n, ms), scope)
        name := getHead(left)
        if not isName(name)
            astSyntaxError("expected name", name)
        parameters := getArguments(left)
        # todo: use the same method for parameters as with normal functions
        if not parameters.all(isName)
            astSyntaxError("parameters to type constructor must be names", name)
        adt := newADT(getTag(name), parameters, forms)
        value := parameters.fold(LockedArrow, adt)
        value' := if forms.any(containsName(name)) then
            applyFix(name, value) else value
        Let(tag, True, name, value', scope')
    astSyntaxError("internal error", left)


def applyDefinition(definition, scope)
    if definition is Definition(tag, type, name, value)
        match type
            PlainDefinition -> applyPlainDefinition(tag, name, value, scope)
            MaybeDefinition -> applyMaybeDefinition(tag, name, value, scope)
            TryDefinition -> applyTryDefinition(tag, name, value, scope)
            SyntaxDefinition -> scope
            ADTDefinition -> applyADTDefinition(tag, name, value, scope)
    astSyntaxError("internal error", definition)


def reduceDefine'(tag, definitionType, left, right)
    if left is ColonPair(tag', left', codomain)
        reduceDefine'(tag, definitionType, left',
            ColonPair(tag', right, codomain))
    if isTuple(left) or isAsPattern(left)
        Definition(tag, definitionType, left, right)
    (name, value) := getNameAndValue(newPatternArrow, left, right)
    if not isName(name)
        syntaxError("invalid left hand side", tag)
    if isThisName(name, "main")
        applyPlainDefinition(tag, name, value, name)
    Definition(tag, definitionType, name, transformRecursion(name, value))


def reduceDefine(tag, left, right)
    if isDefinition(right)   # todo: remove after converting exceptions
        astSyntaxError("missing scope for definition", right)
    if left is Juxtaposition(_, left', right')
        if isThisName(left', "maybe")
            reduceDefine'(tag, MaybeDefinition, right', right)
        if isThisName(left', "try")
            reduceDefine'(tag, TryDefinition, right', right)
        if isThisName(left', "syntax")
            reduceDefine'(tag, SyntaxDefinition, right', right)
        reduceDefine'(tag, PlainDefinition, left, right)
    reduceDefine'(tag, PlainDefinition, left, right)


def reduceADTDefine(tag, left, right)
    if not isValidPattern(left)
        syntaxError("invalid left hand side", tag)
    if not isSetBuilder(right)
        syntaxError("ADT required to right of", tag)
    Definition(tag, ADTDefinition, left, right)

#*
