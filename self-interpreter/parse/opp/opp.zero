#* symbols.zero

LEFT := 0
RIGHT := 1
NEITHER := 2


def reduce(operator, left, right)
    getReduce(getSyntax(operator))(operator, left, right)


def reduceBracket(open, close, before, contents)
    if getBracketType(getSyntax(open)) =/= getBracketType(getSyntax(close))
        if getBracketType(getSyntax(close)) = '\0'
            syntaxError("missing close for", open)
        syntaxError("missing open for", close)
    reduced := reduce(open, before, contents)
    if isNull(reduced)
        abort("internal error: null")  # force evaluation of reduced
    reduce(close, before, reduced)


def shift(state @ State(stack, operators), node)
    with node as Operator(_, _, syntax')
        getShift(syntax')(state, node)
    with stack as top :: _
        if not isOperator(top)
            syntaxError("missing operator before", node)
        State(node :: stack, operators)
    syntaxError("missing operator before", node)


def reduceTop'(operator, right, stack, operators)
    with operator as Operator(tag, _, syntax')
        if getFixity(syntax') = PREFIX
            shift(State(stack, operators),
                reduce(operator, Null(tag), right))
        with stack as left :: stack'
            state' := State(stack', if isSyntaxDefinition(left) then
                operators.drop(1) else operators)
            shift(state', reduce(operator, left, right))
        State(stack, operators)
    syntaxError("internal error", operator)


def reduceTop(state @ State(stack, operators))
    with stack as right :: stack'
        with stack' as operator :: stack''
            if isOperator(operator)
                reduceTop'(operator, right, stack'', operators)
            state
        state
    state


def isHigherPrecedence(left, right)
    if isEOF(left)
        False

    with left as Operator(_, leftRank, leftSyntax)
        with right as Operator(_, rightRank, rightSyntax)
            if leftSyntax.getRightPrecedence = rightSyntax.getLeftPrecedence
                if leftSyntax.getAssociativity = NEITHER
                    syntaxError("operator is non-associative", left)

                if rightSyntax.getAssociativity = NEITHER
                    syntaxError("operator is non-associative", right)

                if leftSyntax.getAssociativity =/= rightSyntax.getAssociativity
                    syntaxError("incompatible associativity", right)

                if leftSyntax.getAssociativity = RIGHT
                    leftRank > rightRank
                leftRank >= rightRank

            leftSyntax.getRightPrecedence > rightSyntax.getLeftPrecedence
        False
    False


def shouldReduceTop(operator, State(stack, _operators))
    with stack as x :: stack'
        if isOperator(x)
            False
        with stack' as x' :: _
            isHigherPrecedence(x', operator)
        False
    False


def reduceLeft(state, operator)
    while(shouldReduceTop(operator), reduceTop, state)


def parseOperator(tag, value, syntax')
    tag' := renameTag(tag, getAlias(syntax'), getFixity(syntax'))
    Operator(tag', value, syntax')


def lookupSyntax(lexeme, operators)
    with operators as top :: _
        top.lookup(lexeme)
    Void

#*
