#* opp.zero

LEFT := 0
RIGHT := 1
NEITHER := 2

def getSyntax(operator)
    with operator as Operator(_, _, syntax')
        syntax'
    abort("internal error: getSyntax of non-operator")

isSpecialOperator(op) := isOperator(op) and isSpecial(getSyntax(op))

def reduce(operator, left, right)
    getReduce(getSyntax(operator))(operator, left, right)


def reduceBracket(open, close, before, contents)
    if getBracketType(getSyntax(open)) =/= getBracketType(getSyntax(close))
        if getBracketType(getSyntax(close)) = '\0'
            syntaxError("missing close for", open)
        syntaxError("missing open for", close)
    reduced := reduce(open, before, contents)
    if isNull(reduced)
        abort("internal error: null")  # force evaluation of reduced
    reduce(close, before, reduced)


def shift(state @ State(stack, operators, onReduce), node)
    with node as Operator(_, _, syntax')
        getShift(syntax')(state, node)
    with stack as top :: _
        if not isOperator(top)
            syntaxError("missing operator before", node)
        State(node :: stack, operators, onReduce)
    syntaxError("missing operator before", node)


def reduceTop'(state @ State(stack, operators, onReduce), operator, right)
    with operator as Operator(tag, _, syntax')
        if getFixity(syntax') = PREFIX
            reduction := reduce(operator, Null(tag), right)
            state' := State(reduction :: stack, operators, onReduce)
            onReduce(state', operator, Null(tag), right, reduction)
        with stack as left :: stack'
            reduction := reduce(operator, left, right)
            state' := State(reduction :: stack', operators, onReduce)
            onReduce(state', operator, left, right, reduction)
        state
    syntaxError("internal error", operator)


def reduceTop(state @ State(stack, operators, onReduce))
    with stack as right :: stack'
        with stack' as operator :: stack''
            if isOperator(operator)
                reduceTop'(State(stack'', operators, onReduce), operator, right)
            state
        state
    state


def isHigherPrecedence(left, right)
    with left as Operator(_, leftRank, leftSyntax)
        with right as Operator(_, rightRank, rightSyntax)
            if leftSyntax.getRightPrecedence = rightSyntax.getLeftPrecedence
                if leftSyntax.getAssociativity = NEITHER
                    syntaxError("operator is non-associative", left)

                if rightSyntax.getAssociativity = NEITHER
                    syntaxError("operator is non-associative", right)

                if leftSyntax.getAssociativity =/= rightSyntax.getAssociativity
                    syntaxError("incompatible associativity", right)

                if leftSyntax.getAssociativity = RIGHT
                    leftRank > rightRank
                leftRank >= rightRank

            leftSyntax.getRightPrecedence > rightSyntax.getLeftPrecedence
        False
    False


def shouldReduceTop(operator, state)
    with getStack(state) as x :: stack'
        if isOperator(x)
            False
        with stack' as x' :: _
            isHigherPrecedence(x', operator)
        False
    False


def reduceLeft(state, operator)
    while(shouldReduceTop(operator), reduceTop, state)


def parseOperator(tag, value, syntax')
    tag' := renameTag(tag, getAlias(syntax'), getFixity(syntax'))
    Operator(tag', value, syntax')


def lookupSyntax(lexeme, operators)
    with operators as top :: _
        top.lookup(lexeme)
    Void

#*
