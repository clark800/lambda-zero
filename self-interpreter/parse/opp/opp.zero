#* opp.zero

LEFT := 0
RIGHT := 1
NEITHER := 2


def getSyntax(operator)
    with operator as Operator(_, _, syntax')
        syntax'
    abort("internal error: getSyntax of non-operator")


isSpecialOperator(op) := isOperator(op) and isSpecial(getSyntax(op))


def reduceTop'(state @ State(stack, operators, onReduce), operator, right)
    with operator as Operator(tag, _, syntax')
        match getFixity(syntax')
            case Prefix(reduce)
                reduction := reduce(operator, right)
                state' := State(reduction :: stack, operators, onReduce)
                onReduce(state', operator, Void, Just(right), reduction)
            case Infix(reduce)
                with stack as left :: stack'
                    reduction := reduce(operator, left, right)
                    state' := State(reduction :: stack', operators, onReduce)
                    onReduce(state', operator, Just(left), Just(right),
                        reduction)
                syntaxError("missing left operand", operator)
            case Postfix(reduce)
                syntaxError("internal error: reduceTop'", operator)
            case Openfix(reduce)
                syntaxError("internal error: reduceTop'", operator)
            case Closefix(reduce)
                syntaxError("internal error: reduceTop'", operator)
    syntaxError("internal error: reduceTop'", operator)


def reduceTop(state @ State(stack, operators, onReduce))
    with stack as right :: stack'
        with stack' as operator :: stack''
            if isOperator(operator)
                reduceTop'(State(stack'', operators, onReduce), operator, right)
            state
        state
    state


def isHigherPrecedence(left, right)
    with left as Operator(_, leftRank, leftSyntax)
        with right as Operator(_, rightRank, rightSyntax)
            if leftSyntax.getRightPrecedence = rightSyntax.getLeftPrecedence
                if leftSyntax.getAssociativity = NEITHER
                    syntaxError("operator is non-associative", left)

                if rightSyntax.getAssociativity = NEITHER
                    syntaxError("operator is non-associative", right)

                if leftSyntax.getAssociativity =/= rightSyntax.getAssociativity
                    syntaxError("incompatible associativity", right)

                if leftSyntax.getAssociativity = RIGHT
                    leftRank > rightRank
                leftRank >= rightRank

            leftSyntax.getRightPrecedence > rightSyntax.getLeftPrecedence
        False
    False


def shouldReduceTop(operator, state)
    with getStack(state) as x :: stack'
        if isOperator(x)
            False
        with stack' as x' :: _
            isHigherPrecedence(x', operator)
        False
    False


def reduceLeft(state, operator)
    while(shouldReduceTop(operator), reduceTop, state)


def parseOperator(tag, value, syntax')
    tag' := renameTag(tag, getAlias(syntax'), getFixityCode(getFixity(syntax')))
    Operator(tag', value, syntax')


def pushSyntax(lexeme, syntax', operators)
    with operators as top :: _
        top.insert(lexeme, syntax') :: operators
    [newDictionary([(lexeme, syntax')])]


def lookupSyntax(lexeme, operators)
    with operators as top :: _
        top.lookup(lexeme)
    Void


def shiftPrefix(State(stack, operators, onReduce), operator)
    State(operator :: stack, operators, onReduce)


def shiftPostfix(reduce, State(stack, operators, onReduce), operator)
    with stack as operand :: stack'
        if isOperator(operand)
            syntaxError("missing left operand for", operator)
        reduction := reduce(operator, operand)
        state' := State(reduction :: stack', operators, onReduce)
        onReduce(state', operator, Just(operand), Void, reduction)
    syntaxError("missing left operand for", operator)


def shiftInfix(State(stack, operators, onReduce), operator)
    with stack as top :: _
        if not isOperator(top)
            State(operator :: stack, operators, onReduce)
        syntaxError("missing left operand for", operator)
    syntaxError("missing left operand for", operator)


def shiftOpenfix(State(stack, operators, onReduce), open)
    State(open :: stack, operators, onReduce)


def reduceBracket(reduceOpen, reduceClose, open, close, before, contents)
    if getBracketType(getSyntax(open)) =/= getBracketType(getSyntax(close))
        if getBracketType(getSyntax(close)) = '\0'
            syntaxError("missing close for", open)
        syntaxError("missing open for", close)
    reduceClose(close, before, reduceOpen(open, before, contents))


def shiftBracket'(reduceOpen, reduceClose, state, open, close, left, right)
    _ @ State(stack, operators, onReduce) := state
    reduction := reduceBracket(
        reduceOpen, reduceClose, open, close, left, right)
    state' := State(reduction :: stack, operators, onReduce)
    onReduce(state', open, left, right, reduction)


def shiftBracket(reduceOpen, reduceClose, state, open, close, right)
    _ @ State(stack, operators, onReduce) := state
    with stack as left :: stack'
        if isOperator(left)
            pass
        state' := State(stack', operators, onReduce)
        shiftBracket'(reduceOpen, reduceClose, state', open, close,
            Just(left), right)
    shiftBracket'(reduceOpen, reduceClose, state, open, close, Void, right)


def shiftClosefix(reduceClose, State(stack, operators, onReduce), close)
    with stack as top :: stack'
        with top as Operator(_, _, syntax')
            with getFixity(syntax') as Openfix(reduceOpen)
                state' := State(stack', operators, onReduce)
                shiftBracket(reduceOpen, reduceClose, state', top, close, Void)
            syntaxError("missing right operand for", top)
        with stack' as open :: stack''
            with open as Operator(_, _, syntax')
                with getFixity(syntax') as Openfix(reduceOpen)
                    state' := State(stack'', operators, onReduce)
                    shiftBracket(reduceOpen, reduceClose,
                        state', open, close, Just(top))
                pass
            pass
        pass
    syntaxError("missing open for", close)


def getShifter(fixity)
    match fixity
        Prefix(reduce) -> shiftPrefix
        Infix(reduce) -> shiftInfix
        Postfix(reduce) -> shiftPostfix(reduce)
        Openfix(reduce) -> shiftOpenfix
        Closefix(reduce) -> shiftClosefix(reduce)


def shift(state, node)
    state' @ State(stack, operators, onReduce) := reduceLeft(state, node)
    with node as Operator(_, _, syntax')
        getShifter(getFixity(syntax'))(state', node)
    with stack as top :: _
        if not isOperator(top)
            syntaxError("missing operator before", node)
        State(node :: stack, operators, onReduce)
    syntaxError("missing operator before", node)

#*
