#* parse.zero

def getItemTag(item)
    match item
        OperatorItem(Operator(tag, _, _)) -> tag
        OperandItem(operand) -> getTag(operand)


def shift'(state, item)
    shift(state, getItemTag(item), item)


def isLeftSectionOperator(operator)
    syntax' := getSyntax(operator)
    if isSpecial(syntax')
        False
    fixity := getFixityCode(getFixity(syntax'))
    fixity = INFIX or fixity = PREFIX


def isRightSectionOperator(operator)
    syntax' := getSyntax(operator)
    if isSpecial(syntax')
        False
    fixity := getFixityCode(getFixity(syntax'))
    fixity = INFIX or fixity = POSTFIX


def shiftOperator''(state, operator)
    # handle section syntax
    _ @ State(stack, operators, onReduce) := state
    with stack as topItem :: stack'
        with topItem as OperatorItem(top)
            if isThisOperator(top, "(") and isRightSectionOperator(operator)
                openTag := renameTag(getOperatorTag(top), "( ", OPENFIX)
                open := operators.parseSymbol(openTag, 0)
                placeholder := OperandItem(FixedName(getOperatorTag(top), ".*"))
                state' := State(stack', operators, onReduce)
                shift'(shift'(shift'(state', open), placeholder),
                    OperatorItem(operator))
            if isThisOperator(operator, ")") and isLeftSectionOperator(top)
                closeTag := renameTag(getOperatorTag(operator), " )", CLOSEFIX)
                close := operators.parseSymbol(closeTag, 0)
                placeholder := OperandItem(
                    FixedName(getOperatorTag(operator), "*."))
                shift'(shift'(state, placeholder), close)
            shift'(state, OperatorItem(operator))
        shift'(state, OperatorItem(operator))
    shift'(state, OperatorItem(operator))


def isThisOperatorItem(item, lexeme)
    with item as OperatorItem(operator)
        isThisOperator(operator, lexeme)
    False


def erase(state @ State(stack, operators, onReduce), lexeme)
    State(stack.dropIf(`isThisOperatorItem(lexeme)), operators, onReduce)


def shiftOperator'(state, operator)
    # handle erasure of newlines and semicolons

    if getFixityCode(getFixity(getSyntax(operator))) = CLOSEFIX
        state' := erase(state, "\n")
        state'' := if isThisOperator(operator, ")") then
            erase(state', ";") else state'
        shiftOperator''(state'', operator)

    if isThisOperator(operator, "\n")
        with getStack(state) as topItem :: _
            if isOperator(topItem)
                state  # ignore newlines after operators
            if getSubprecedence(operator) % 2 =/= 0
                oppSyntaxError("odd-width indent after", operator)
            shiftOperator''(state, operator)
        if getSubprecedence(operator) =/= 0
            oppSyntaxError("indent on first line", operator)
        state  # ignore newlines at beginning of input

    shiftOperator''(state, operator)


def shiftItem(state, item)
    match item
        OperatorItem(operator) -> shiftOperator'(state, operator)
        OperandItem(_) -> shift'(state, item)


def shiftToken(state, token)
    shiftItem(state, parseToken(getOperators(state), token))


def onReduceHandler(state, operator, left, right, reduction)
    _ @ State(stack, operators, onReduce) := state
    with left as Just(left')
        with left' as Definition(_, type, _, _)
            with type as SyntaxDefinition
                State(stack, operators.drop(1), onReduce)
            pass
        pass
    with reduction as Definition(_, type, definiendum, definiens)
        with type as SyntaxDefinition
            operators' := addSyntax(operators,
                defineSyntax(operators, reduction, definiendum, definiens))
            State(stack, operators', onReduce)
        pass
    state


def parse(getBuiltin, code)
    tokens := lex(code ++ [0]) |: (not) <> isElided
    stack := [parseToken(OPERATORS, START)]
    state := State(stack, OPERATORS, onReduceHandler)
    stack' := getStack(tokens.cascade(shiftToken, state))
    with stack' as item :: remaining
        with item as OperandItem(result)
            if isNull(result) or not isNil(remaining)
                syntaxError("parser error", result)
            bindAST(getBuiltin, result)
        pass
    abort "parser error"

#*
