#* parse.zero

def isLeftSectionOperator(op)
    if not isOperator(op) or isSpecialOperator(op)
        False
    fixity := getFixity(getSyntax(op))
    fixity = INFIX or fixity = PREFIX


def isRightSectionOperator(op)
    if not isOperator(op) or isSpecialOperator(op)
        False
    fixity := getFixity(getSyntax(op))
    fixity = INFIX or fixity = POSTFIX


def shiftNode'(state, node)
    if isOperator(node)
        _ @ State(stack, operators, onReduce) := state
        with stack as top :: stack'
            if isThisOperator(top, "(") and isRightSectionOperator(node)
                openTag := renameTag(getTag(top), "( ", OPENFIX)
                open := operators.parseSymbol(openTag, 0)
                placeholder := FixedName(getTag(top), ".*")
                state' := State(stack', operators, onReduce)
                shift(shift(shift(state', open), placeholder), node)
            if isThisOperator(node, ")") and isLeftSectionOperator(top)
                closeTag := renameTag(getTag(node), " )", CLOSEFIX)
                close := operators.parseSymbol(closeTag, 0)
                placeholder := FixedName(getTag(node), "*.")
                shift(shift(state, placeholder), close)
            shift(state, node)
        shift(state, node)
    shift(state, node)


def erase(state @ State(stack, operators, onReduce), lexeme)
    State(stack.dropIf(`isThisOperator(lexeme)), operators, onReduce)


def shiftNode(state, node)
    if isOperator(node) and getFixity(getSyntax(node)) = CLOSEFIX
        state' := erase(state, "\n")
        state'' := if isThisOperator(node, ")") then
            erase(state', ";") else state'
        shiftNode'(state'', node)

    if isThisOperator(node, "\n")
        with getStack(state) as top :: _
            if not isOperator(top) and getRank(node) % 2 =/= 0
                syntaxError("odd-width indent after", node)
            pass
        shiftNode'(state, node)

    shiftNode'(state, node)


def shiftToken(state, token)
    shiftNode(state, parseToken(getOperators(state), token))


def onReduceHandler(state @ State(stack, operators, onReduce))
    with stack as top :: _
        with top as Definition(tag, type, definiendum, definiens)
            with type as SyntaxDefinition
                operator := defineSyntax(operators, top, definiendum, definiens)
                operators' := addSyntax(operators, operator)
                State(stack, operators', onReduce)
            state
        state
    state


def parse(getBuiltin, code)
    tokens := lex(code ++ [0]) |: (not) <> isElided
    state := State([parseToken(OPERATORS, START)], OPERATORS, onReduceHandler)
    stack := getStack(tokens.cascade(shiftToken, state))
    # use "count" to force any syntaxErrors in the stack
    if stack.count((not) <> isNull) = 0
        abort "parser error"
    with stack as result :: remaining
        if not isNil(remaining)
            syntaxError("parser error", result)
        bindAST(getBuiltin, result)
    abort "parser error"

#*
