#* parse.zero

def getItemTag(item)
    match item
        OperatorItem(Operator(tag, _, _)) -> tag
        OperandItem(operand) -> getTag(operand)


def shift'(state, item)
    shift(state, getItemTag(item), item)


def isLeftSectionOperator(operator)
    syntax' := getSyntax(operator)
    if isSpecial(syntax')
        False
    fixity := getFixityCode(getFixity(syntax'))
    fixity = INFIX or fixity = PREFIX


def isRightSectionOperator(operator)
    syntax' := getSyntax(operator)
    if isSpecial(syntax')
        False
    fixity := getFixityCode(getFixity(syntax'))
    fixity = INFIX or fixity = POSTFIX


def shiftOperator''(state, operator)
    # handle section syntax
    (maybeTopItem, state') := unshift(state)
    with maybeTopItem as Just(topItem)
        with topItem as OperatorItem(top)
            if isThisOperator(top, "(") and isRightSectionOperator(operator)
                openTag := renameTag(getOperatorTag(top), "( ", OPENFIX)
                open := state'.parseSymbol(openTag, 0)
                placeholder := OperandItem(FixedName(getOperatorTag(top), ".*"))
                shift'(shift'(shift'(state', open), placeholder),
                    OperatorItem(operator))
            if isThisOperator(operator, ")") and isLeftSectionOperator(top)
                closeTag := renameTag(getOperatorTag(operator), " )", CLOSEFIX)
                close := state.parseSymbol(closeTag, 0)
                placeholder := OperandItem(
                    FixedName(getOperatorTag(operator), "*."))
                shift'(shift'(state, placeholder), close)
            shift'(state, OperatorItem(operator))
        shift'(state, OperatorItem(operator))
    shift'(state, OperatorItem(operator))


def shiftOperator'(state, operator)
    # handle erasure of newlines and semicolons

    if getFixityCode(getFixity(getSyntax(operator))) = CLOSEFIX
        state' := state.erase("\n")
        state'' := if isThisOperator(operator, ")") then
            state'.erase(";") else state'
        shiftOperator''(state'', operator)

    if isThisOperator(operator, "\n")
        with getStack(state) as topItem :: _
            if isOperator(topItem)
                state  # ignore newlines after operators
            if getSubprecedence(operator) % 2 =/= 0
                oppSyntaxError("odd-width indent after", operator)
            shiftOperator''(state, operator)
        if getSubprecedence(operator) =/= 0
            oppSyntaxError("indent on first line", operator)
        state  # ignore newlines at beginning of input

    shiftOperator''(state, operator)


def shiftItem(state, item)
    match item
        OperatorItem(operator) -> shiftOperator'(state, operator)
        OperandItem(_) -> shift'(state, item)


def shiftToken(state, token)
    shiftItem(state, parseToken(state, token))


def onReduceHandler(state, operator, left, right, reduction)
    with left as Just(left')
        with left' as Definition(_, type, _, _)
            with type as SyntaxDefinition
                popSyntax(state)
            pass
        pass
    with reduction as Definition(_, type, definiendum, definiens)
        with type as SyntaxDefinition
            addSyntax(state,
                defineSyntax(state, reduction, definiendum, definiens))
        pass
    state


def parse(getBuiltin, code)
    tokens := lex(code ++ [0]) |: (not) <> isElided
    state := shiftToken(State([], OPERATORS, onReduceHandler), START)
    stack := getStack(tokens.cascade(shiftToken, state))
    with stack as item :: remaining
        with item as OperandItem(result)
            if not isPreterm(result) and False
                # currently bind has special case errors for non-preterms
                syntaxError("parser error", result)  # force syntax errors
            if not isNil(remaining)
                syntaxError("parser error", result)
            bindAST(getBuiltin, result)
        pass
    abort "parser error"

#*
