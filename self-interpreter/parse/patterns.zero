#* patterns.zero

def getHead(node)
    if node is Juxtaposition(_, left, _)
        getHead(left)
    node


def getArguments(pattern)
    if pattern is Juxtaposition(_, left, right)
        getArguments(left) ++ [right]
    []


def newProjector(tag, arity, index)
    (UnderscoreArrow(tag)^<>(arity))(Underscore(tag, arity -- index))


def newPatternArrow(pattern, body)
    if pattern is ColonPair(tag, left, right)
        newPatternArrow(left, body).setAnnotation(right)
    if isName(pattern)
        LockedArrow(pattern, body)
    if pattern is AsPattern(tag, left, right)
        newPatternArrow(left, Juxtaposition(tag,
            newPatternArrow(right, body), Underscore(tag, 1)))
    if isJuxtaposition(pattern)
        constructor := getHead(pattern)
        tag := getTag(constructor)
        arguments := getArguments(pattern)
        arity := length(arguments)
        underscore := NegativeUnderscore(tag)
        function := arguments.fold(newPatternArrow, body)
        projectors := (0 .. arity -- 1).map(newProjector(tag, arity))
        projections := projectors.map(Juxtaposition(tag, underscore))
        lockArrow(StrictArrow(tag, [(constructor, arity)], Underscore(tag, 0),
            projections.cascade(Juxtaposition(tag), function)))
    astSyntaxError("invalid parameter", pattern)


def getNameAndValue(f, left, right)
    if not isPreterm(right)
        astSyntaxError("invalid parameter", right)  # force syntax errors
    if left is Juxtaposition(_, left', right')
        getNameAndValue(f, left', f(right', right))
    (left, right)


def newCaseArrow(left, right)
    if isUnderscore(left)
        SimpleArrow(left, right)
    if isAsPattern(left)
        astSyntaxError("invalid '@' in case", left)
    arity := length(getArguments(left))
    (name, reconstructor) := getNameAndValue(newPatternArrow, left, right)
    tag := getTag(name)
    constructor := Name(tag)  # name could be a number
    thisName := This(tag)
    body := Juxtaposition(tag, thisName, reconstructor)
    StrictArrow(tag, [(constructor, arity)], thisName, body)


def addCases(tag, base, extension)
    if extension is Juxtaposition(_, left, right)
        Juxtaposition(tag, addCases(tag, base, left), right)
    base


def newCaseBody(tag, thisName, left, right)
    if left is Arrow(_, type, _, _, _, body)
        base := if type is Simple; Juxtaposition(tag, thisName, body) <| body
        if right is Arrow(_, type', _, _, _, body')
            if type' is Simple
                Juxtaposition(tag, base, body')
            addCases(tag, base, body')
        astSyntaxError("internal error", left)
    astSyntaxError("internal error", left)


def getCases(arrow)
    if arrow is Arrow(_, type, cases, parameter, _, _)
        if type is Simple
            [(parameter, 0)]
        cases
    []


def isDefaultCase(arrow)
    if arrow is Arrow(_, type, _, parameter, _, _)
        if type is Simple
            isUnderscore(parameter) or isThisName(parameter, "this")
        False
    False


def getReconstructor(caseArrow)
    if caseArrow is Arrow(_, type, _, _, _, body)
        if type is Simple
            body
        if body is Juxtaposition(_, _, right)
            right
        pass
    astSyntaxError("Internal error: expected case arrow", caseArrow)


def attachDefaultCase(tag, caseArrow, fallback)
    constructorTag := getTag(caseArrow)
    deconstructor := Name(addPrefix(constructorTag, '@'))
    reconstructor := getReconstructor(caseArrow)
    # note: "this" is a positive variable here because we aren't using it
    # as a function as we are in the strict case
    thisName := FixedName(tag, "this")
    body := Juxtaposition(tag, Juxtaposition(tag, Juxtaposition(tag,
        deconstructor, reconstructor), fallback), thisName)
    SimpleArrow(thisName, body)


def combineCases(tag, left, right)
    if isDefaultCase(right)
        attachDefaultCase(tag, left, right)
    thisName := This(tag)
    cases := getCases(left) ++ getCases(right)
    body := newCaseBody(tag, thisName, left, right)
    StrictArrow(tag, cases, thisName, body)

#*
