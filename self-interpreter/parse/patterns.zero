#* patterns.zero

def getHead(node)
    if node is Juxtaposition(_, left, _)
        getHead(left)
    node


def getArguments(pattern)
    if pattern is Juxtaposition(_, left, right)
        getArguments(left) ++ [right]
    []


def newProjector(tag, size, index)
    (UnderscoreArrow(tag)^<>(size))(Underscore(tag, size -- index))


def newPatternArrow(pattern, body)
    if pattern is ColonPair(tag, left, right)
        newPatternArrow(left, body).setAnnotation(right)
    if isName(pattern)
        LockedArrow(pattern, body)
    if pattern is AsPattern(tag, left, right)
        newPatternArrow(left, Juxtaposition(tag,
            newPatternArrow(right, body), Underscore(tag, 1)))
    if isJuxtaposition(pattern)
        constructor := getHead(pattern)
        tag := getTag(constructor)
        arguments := getArguments(pattern)
        size := length(arguments)
        underscore := Underscore(tag, 1)
        function := arguments.fold(newPatternArrow, body)
        projectors := (0 .. size -- 1).map(newProjector(tag, size))
        projections := projectors.map(Juxtaposition(tag, underscore))
        lockArrow(StrictArrow(tag, [constructor],
            projections.cascade(Juxtaposition(tag), function)))
    astSyntaxError("invalid parameter", pattern)


def getNameAndValue(f, left, right)
    if not isPreterm(right)
        astSyntaxError("invalid parameter", right)  # force syntax errors
    if left is Juxtaposition(_, left', right')
        getNameAndValue(f, left', f(right', right))
    (left, right)


def newCaseArrow(left, right)
    if isUnderscore(left)
        SimpleArrow(left, right)
    pattern := if left is AsPattern(_, _, pattern'); pattern' <| left
    (name, reconstructor) :=
        getNameAndValue(newPatternArrow, pattern, right)
    constructor := Name(getTag(name))  # name could be a number
    tag := getTag(constructor)
    underscore := Underscore(tag, 1)
    if left is AsPattern(tag, asLeft, _)
        wrapper := newPatternArrow(asLeft, reconstructor)
        argument := Juxtaposition(tag, wrapper, underscore)
        StrictArrow(tag, [constructor],
            Juxtaposition(tag, underscore, argument))
    StrictArrow(tag, [constructor],
        Juxtaposition(tag, underscore, reconstructor))


def addCases(tag, base, extension)
    if extension is Juxtaposition(_, left, right)
        Juxtaposition(tag, addCases(tag, base, left), right)
    base


def newCaseBody(tag, left, right)
    if left is Arrow(_, type, _, _, _, body)
        base := if type is Simple;
            Juxtaposition(tag, Underscore(tag, 1), body) <| body
        if right is Arrow(_, type', _, _, _, body')
            if type' is Simple
                Juxtaposition(tag, base, body')
            addCases(tag, base, body')
        astSyntaxError("internal error", left)
    astSyntaxError("internal error", left)


def getCaseConstructors(arrow)
    if arrow is Arrow(_, type, constructors, parameter, _, _)
        if type is Simple
            [parameter]
        constructors
    []


def isDefaultCase(arrow)
    if arrow is Arrow(_, type, _, parameter, _, _)
        if type is Simple
            isUnderscore(parameter)
        False
    False


def getReconstructor(arrow)
    if arrow is Arrow(_, type, _, _, _, body)
        if type is Simple
            body
        if body is Juxtaposition(_, _, right)
            right
        astSyntaxError("internal error", arrow)
    astSyntaxError("internal error", arrow)


def chainCases(tag, arrow, fallback)
    deconstructor := Name(addPrefix(getTag(arrow), '@'))
    reconstructor := getReconstructor(arrow)
    body := Juxtaposition(tag, Juxtaposition(tag, Juxtaposition(tag,
        deconstructor, reconstructor), fallback), Underscore(tag, 1))
    SimpleArrow(Name(veil(tag)), body)


def combineCases(tag, left, right)
    if isDefaultCase(right)
        chainCases(tag, left, right)
    constructors := getCaseConstructors(left) ++ getCaseConstructors(right)
    StrictArrow(tag, constructors, newCaseBody(tag, left, right))

#*
