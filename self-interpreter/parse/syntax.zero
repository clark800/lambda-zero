#* syntax.zero

def isOperatorTop(stack)
    stack |> [] -> True; top :: _ -> isOperator(top)


def isValidPrior(operator, node)
    with operator as Operator(_, _, syntax')
        prior := getPrior(syntax')
        isNil(prior) or (isJuxtaposition(node) and getLexeme(node) =*= prior)
    False


def reduceApply(operator, left, right)
    Juxtaposition(getTag(operator), left, right)


def reducePrefix(operator, _left, right)
    if not isValidPrior(operator, right)
        syntaxError("operator syntax error", operator)
    reduceApply(operator, Name(getTag(operator)), right)


def reducePostfix(operator, left, _right)
    if not isValidPrior(operator, left)
        syntaxError("operator syntax error", operator)
    reduceApply(operator, Name(getTag(operator)), left)


def reduceInfix(operator, left, right)
    reduceApply(operator, reduceApply(operator,
        Name(getTag(operator)), left), right)


def reduceInfixL(operator, left, right)
    if not isValidPrior(operator, left)
        syntaxError("operator syntax error", operator)
    reduceInfix(operator, left, right)


def reduceInfixR(operator, left, right)
    if not isValidPrior(operator, right)
        syntaxError("operator syntax error", operator)
    reduceInfix(operator, left, right)


def reduceArrow(operator, left, right)
    if isName(left)
        SimpleArrow(left, right)  # might be a case or might not be a case
    if isColonPair(left)
        newPatternArrow(left, right)
    newCaseArrow(left, right)


def reduceDoubleArrow(operator, left, right)
    Arrow(getTag(operator), Double, [], left, Null(noTag), right)


def reducePipeline(operator, left, right)
    reduceApply(operator, right, left)


def reduceCommaPair(operator, left, right)
    CommaPair(getTag(operator), left, right)


def reduceColonPair(operator, left, right)
    if isColonPair(left) or not isValidPattern(left)
        syntaxError("invalid left side of colon", left)
    if isColonPair(right) or not isValidPattern(right)
        syntaxError("invalid right side of colon", right)
    ColonPair(getTag(operator), left, right)


def reduceAsPattern(operator, left, right)
    AsPattern(getTag(operator), left, right)


def reduceWhere(operator, left, right)
    if not isDefinition(right)
        syntaxError("expected definition to right of", operator)
    applyDefinition(right, left)


def reduceWith(operator, asPattern, withBlock)
    with asPattern as AsPattern(_, expression, pattern)
        tag := getTag(operator)
        elseBlock := Underscore(tag, 3)
        caseArrow := newCaseArrow(pattern, withBlock)
        fallback := SimpleArrow(Underscore(tag, 0), elseBlock)
        function := combineCases(tag, caseArrow, fallback)
        LockedArrow(FixedName(tag, "pass"),
            Juxtaposition(tag, function, expression))
    syntaxError("expected as pattern to right of", operator)


def reduceNewline(operator, left, right)
    with left as Juxtaposition(_, left', right')
        if isThisName(left', "def")
            reduceDefine(left', right', right)
        if isThisName(left', "case")
            newCaseArrow(right', right)
        if isThisName(left', "with")
            reduceWith(left', right', right)
        reduceApply(operator, left, right)
    if isDefinition(left)
        applyDefinition(left, right)
    if isCase(left) and isCase(right)
        combineCases(getTag(operator), left, right)
    reduceApply(operator, left, right)


def reduceInterfix(operator, left, right)
    if not isValidPrior(operator, left)
        syntaxError("operator syntax error", operator)
    reduceNewline(operator, left, right)


def reduceInvalid(operator, _left, _right)
    syntaxError("missing operator", operator)


def reduceReserved(operator, _left, _right)
    syntaxError("reserved operator", operator)


def reduceClose(_operator, _left, right)
    right


def shiftPrefix(state, operator)
    _ @ State(stack, operators, onReduce) := reduceLeft(state, operator)
    State(operator :: stack, operators, onReduce)


def shiftPostfix(state, operator)
    _ @ State(stack, operators, onReduce) := reduceLeft(state, operator)
    with stack as operand :: stack'
        if isOperator(operand)
            syntaxError("missing left operand for", operator)
        right := Null(getTag(operator))
        reduction := reduce(operator, operand, right)
        state' := State(reduction :: stack', operators, onReduce)
        onReduce(state', operator, operand, right, reduction)
    syntaxError("missing left operand for", operator)


def shiftInfix(state, operator)
    _ @ State(stack, operators, onReduce) := reduceLeft(state, operator)
    with stack as top :: _
        if not isOperator(top)
            State(operator :: stack, operators, onReduce)
        syntaxError("missing left operand for", operator)
    syntaxError("missing left operand for", operator)


def newOperator'(tag, prior, precedence, fixity, associativity,
        shifter, reducer)
    special := not isNil(prior)
    if special and associativity = NEITHER
        parseError("expected numeric precedence", tag)
    Operator(tag, 0, Syntax(getTagLexeme(tag), precedence, precedence, fixity,
        associativity, special, '_', shifter, reducer, prior))


def newSyntaxOperator(tag, precedence, fixity, prior)
    p := precedence
    if getLexeme(fixity) =*= "infix"
        newOperator'(tag, prior, p, INFIX, NEITHER, shiftInfix, reduceInfix)
    if getLexeme(fixity) =*= "infixL"
        newOperator'(tag, prior, p, INFIX, LEFT, shiftInfix, reduceInfixL)
    if getLexeme(fixity) =*= "infixR"
        newOperator'(tag, prior, p, INFIX, RIGHT, shiftInfix, reduceInfixR)
    if getLexeme(fixity) =*= "interfix"
        newOperator'(tag, prior, p, INFIX, LEFT, shiftInfix, reduceInterfix)
    if getLexeme(fixity) =*= "prefix"
        newOperator'(tag, prior, p, PREFIX, LEFT, shiftPrefix, reducePrefix)
    if getLexeme(fixity) =*= "postfix"
        newOperator'(tag, prior, p, POSTFIX, LEFT, shiftPostfix, reducePostfix)
    syntaxError("invalid fixity", fixity)


def getAliasSyntax(operators, name)
    if not isName(name)
        syntaxError("expected operator name", name)
    operators.lookupSyntax(getLexeme(name)) ??
        syntaxError("syntax not defined", name)


def newAlias(operators, tag, name)
    Operator(tag, 0, getAliasSyntax(operators, name))


def copySyntax(operators, tag, name)
    lexeme := getTagLexeme(tag)
    match getAliasSyntax(operators, name)
        Syntax(_, l, r, f, a, s, b, sh, rd, p) ->
            Operator(tag, 0, Syntax(lexeme, l, r, f, a, s, b, sh, rd, p))


def findPrecedence(operators, node)
    syntax' := operators.lookupSyntax(getLexeme(node)) ??
        syntaxError("syntax not defined", node)
    if getLeftPrecedence(syntax') =/= getRightPrecedence(syntax')
        syntaxError("operator not supported", node)
    getLeftPrecedence(syntax')


def parsePrecedence(operators, node)
    with node as Number(_, precedence)
        if precedence > 99
            syntaxError("invalid precedence", node)
        precedence
    findPrecedence(operators, node)


def defineSyntax(operators, definition, name, right)
    tag := getTag(definition)
    if not isName(name)
        syntaxError("expected name operand to", definition)
    with right as Juxtaposition(_, fixity, argument)
        if isThisName(fixity, "alias")
            newAlias(operators, getTag(name), argument)
        if isThisName(fixity, "syntax")
            copySyntax(operators, getTag(name), argument)
        precedence := parsePrecedence(operators, argument)
        prior := if isNumber(argument) then "" else getLexeme(argument)
        newSyntaxOperator(getTag(name), precedence, fixity, prior)
    syntaxError("invalid syntax definition", definition)


def pushSyntax(lexeme, syntax', operators)
    with operators as top :: _
        top.insert(lexeme, syntax') :: operators
    [newDictionary([(lexeme, syntax')])]


def addSyntax(operators, operator)
    if not isVoid(operators.lookupSyntax(getLexeme(operator)))
        syntaxError("syntax already defined", operator)
    operators.pushSyntax(getLexeme(operator), getSyntax(operator))


def shiftNewline(state, operator)
    # ignore newlines after operators for line continuations
    if isOperatorTop(getStack(state))
        state
    if getRank(operator) % 2 =/= 0
        syntaxError("odd-width indent after", operator)
    shiftInfix(state, operator)


def coreAlias(lexeme, aliasName, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)
    (lexeme, Syntax(aliasName, leftPrecedence, rightPrecedence, fixity,
        associativity, True, '_', shifter, reducer, ""))


def coreSyntax(lexeme, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)
    coreAlias(lexeme, lexeme, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)


def bracketSyntax(lexeme, bracketType, outerPrecedence, fixity, shifter,
        reducer)
    leftPrecedence := if fixity = OPENFIX then outerPrecedence else 0
    rightPrecedence := if fixity = OPENFIX then 0 else outerPrecedence
    (lexeme, Syntax(lexeme, leftPrecedence, rightPrecedence, fixity,
        RIGHT, True, bracketType, shifter, reducer, ""))


OPERATORS := [newDictionary([
    bracketSyntax("", '\0', 0, OPENFIX, shiftOpen, reduceOpenFile),
    bracketSyntax("\0", '\0', 0, CLOSEFIX, shiftClose, reduceClose),
    bracketSyntax("(", '(', 95, OPENFIX, shiftOpen, reduceParentheses),
    bracketSyntax(")", '(', 95, CLOSEFIX, shiftClose, reduceClose),
    bracketSyntax("( ", '(', 95, OPENFIX, shiftOpen, reduceOpenSection),
    bracketSyntax(" )", '(', 95, CLOSEFIX, shiftClose, reduceCloseSection),
    bracketSyntax("[", '[', 95, OPENFIX, shiftOpen, reduceSquare),
    bracketSyntax("]", '[', 95, CLOSEFIX, shiftClose, reduceClose),
    bracketSyntax("{", '{', 95, OPENFIX, shiftOpen, reduceCurly),
    bracketSyntax("}", '{', 95, CLOSEFIX, shiftClose, reduceClose),
    coreSyntax("|", 1, 1, INFIX, NEITHER, shiftInfix, reduceReserved),
    coreSyntax(",", 2, 2, INFIX, LEFT, shiftInfix, reduceCommaPair),
    coreSyntax("\n", 3, 3, INFIX, RIGHT, shiftNewline, reduceNewline),
    coreSyntax(";;", 4, 4, INFIX, RIGHT, shiftInfix, reduceNewline),
    coreSyntax("def", 5, 5, PREFIX, LEFT, shiftPrefix, reducePrefix),
    coreSyntax(":=", 5, 5, INFIX, RIGHT, shiftInfix, reduceDefine),
    coreAlias("≔", ":=", 5, 5, INFIX, RIGHT, shiftInfix, reduceDefine),
    coreSyntax("::=", 5, 5, INFIX, RIGHT, shiftInfix, reduceADTDefine),
    coreAlias("⩴", "::=", 5, 5, INFIX, RIGHT, shiftInfix, reduceADTDefine),
    coreSyntax("where", 5, 5, INFIX, RIGHT, shiftInfix, reduceWhere),
    coreSyntax("|>", 6, 6, INFIX, LEFT, shiftInfix, reducePipeline),
    coreAlias("⦊", "|>", 6, 6, INFIX, LEFT, shiftInfix, reducePipeline),
    coreSyntax("<|", 6, 6, INFIX, RIGHT, shiftInfix, reduceApply),
    coreAlias("⦉","<|", 6, 6, INFIX, RIGHT, shiftInfix, reduceApply),
    coreSyntax(";", 8, 8, INFIX, RIGHT, shiftInfix, reduceNewline),
    coreSyntax(":", 9, 9, INFIX, NEITHER, shiftInfix, reduceColonPair),
    coreSyntax("->", 10, 10, INFIX, RIGHT, shiftInfix, reduceArrow),
    coreAlias("↦", "->", 10, 10, INFIX, RIGHT, shiftInfix, reduceArrow),
    coreSyntax("=>", 10, 10, INFIX, RIGHT, shiftInfix, reduceDoubleArrow),
    coreAlias("⇒", "=>", 10, 10, INFIX, RIGHT, shiftInfix, reduceDoubleArrow),
    coreSyntax("case", 11, 11, PREFIX, NEITHER, shiftPrefix, reducePrefix),
    coreSyntax("with", 11, 11, PREFIX, NEITHER, shiftPrefix, reducePrefix),
    coreSyntax("@", 12, 12, INFIX, NEITHER, shiftInfix, reduceAsPattern),
    coreSyntax("as", 12, 12, INFIX, NEITHER, shiftInfix, reduceAsPattern),
    coreSyntax("abort", 15, 15, PREFIX, LEFT, shiftPrefix, reducePrefix),
    coreSyntax(".", 92, 92, INFIX, LEFT, shiftInfix, reducePipeline),
    coreSyntax("$", 99, 99, PREFIX, LEFT, shiftPrefix, reduceReserved),
    coreSyntax("syntax", 99, 99, PREFIX, LEFT, shiftPrefix, reducePrefix),
    coreSyntax("alias", 99, 99, PREFIX, LEFT, shiftPrefix, reducePrefix)
])]

#*
