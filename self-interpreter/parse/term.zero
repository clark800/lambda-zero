#* term.zero

ClosureT(term) ::= {Closure(
    term : term,
    environment : ArrayT(ClosureT(term))
)}

getTerm(Closure(term, _)) := term
getEnvironment(Closure(_, environment)) := environment

OptimizationT(term) ::= {Optimization(
    arity : â„•,
    operator : ((ClosureT(term) => ClosureT(term)) =>
        List(ClosureT(term)) => ClosureT(term)?)
)}

# Wildcard is a MetaVariable that is only referred to once, so it will only be
# unified once, and thus can never cause a type error and does not need to be
# stored in the metacontext
Term ::= {
    Wildcard(tag : TagT),
    Top(tag : TagT),
    Constant(tag : TagT, id : â„•),
    Variable(tag : TagT, debruijn : â„•),
    MetaVariable(tag : TagT, id : â„•),
    Function(tag : TagT, isCase : ð”¹,
        domain : Term, codomain : Term, body : Term),
    Implication(tag : TagT, type : Term, body : Term),
    Application(tag : TagT, applicand : Term, argument : Term),
    Construction(tag : TagT, parameters : List(Term), type : Term,
        signatures : List(Term)),
    Element(tag : TagT, type : Term, term : Term),
    Numeral(tag : TagT, type : Term, value : â„•),
    Operation(tag : TagT, type : Term, term : Term, op : OptimizationT(Term))
}

MetaClosureT ::= {MetaClosure(
    # first is value, second is annotated type
    #metacontext : ArrayT((ClosureT(Term))? && (ClosureT(Term))?),
    metacontext : ArrayT((ClosureT(Term))?),
    closure : ClosureT(Term)
)}

def getTermTag
    Wildcard(tag) -> tag
    Top(tag) -> tag
    Constant(tag, _) -> tag
    Variable(tag, _) -> tag
    MetaVariable(tag, _) -> tag
    Function(tag, _, _, _, _) -> tag
    Implication(tag, _, _) -> tag
    Application(tag, _, _) -> tag
    Construction(tag, _, _, _) -> tag
    Element(tag, _, _) -> tag
    Numeral(tag, _, _) -> tag
    Operation(tag, _, _, _) -> tag


isWildcard := Wildcard(_) -> True; _ -> False
isTop := Top(_) -> True; _ -> False
isConstant := Constant(_, _) -> True; _ -> False
isVariable := Variable(_, _) -> True; _ -> False
isMetaVariable := MetaVariable(_, _) -> True; _ -> False
isFunction := Function(_, _, _, _, _) -> True; _ -> False
isImplication := Implication(_, _, _) -> True; _ -> False
isApplication := Application(_, _, _) -> True; _ -> False
isConstruction := Construction(_, _, _, _) -> True; _ -> False
isElement := Element(_, _, _) -> True; _ -> False
isNumeral := Numeral(_, _, _) -> True; _ -> False
isOperation := Operation(_, _, _, _) -> True; _ -> False


def CaseFunction(tag, domain, codomain, body)
    Function(tag, True, domain, codomain, body)


def FreeFunction(tag, body)
    wildcard := Wildcard(veil(tag))
    Function(tag, False, wildcard, wildcard, body)


def splitSpine(term)
    if term is Application(_, left, right)
        (applicand, arguments) := splitSpine(left)
        (applicand, arguments ++ [right])
    (term, [])


def getTermHead(term)
    first(splitSpine(term))


def maybeAscription(node)
    if node is Element(_, type, _)
        Just(type)
    if node is Numeral(_, type, _)
        Just(type)
    if node is Operation(_, type, _, _)
        Just(type)
    Void


def maybeDebruijnIndex(term)
    if term is Variable(_, debruijn)
        Just(debruijn)
    Void


def maybeBody(term)
    if term is Function(_, _, _, _, body)
        Just(body)
    Void


def maybeApplicand(term)
    if term is Application(_, applicand, _)
        Just(applicand)
    Void


def maybeArgument(term)
    if term is Application(_, _, argument)
        Just(argument)
    Void


def maybeNatural(term)
    if term is Numeral(_, _, value)
        Just(value)
    Void


def maybeAddress(type)
    if type is MetaVariable(_, address)
        Just(address)
    Void


def maybeHead(term)
    maybe body := maybeBody(term)
    maybe body' := maybeBody(body)
    maybe applicand := maybeApplicand(body')
    maybeArgument(applicand)


def maybeTail(term)
    maybe body := maybeBody(term)
    maybe body' := maybeBody(body)
    maybeArgument(body')


def maybeIsNil(term)
    # returns True for [], False for non-nil list, Void for non-list
    # term should be (n -> p -> n) or (n -> p -> ((p c) cs))

    def ifNil(result)
        maybe body := maybeBody(term)
        maybe body' := maybeBody(body)
        maybe debruijn := maybeDebruijnIndex(body')
        if debruijn = 2 then Just(result) else Void

    def ifPush(result)
        maybe body := maybeBody(term)
        maybe body' := maybeBody(body)
        maybe applicand := maybeApplicand(body')
        maybe applicand' := maybeApplicand(applicand)
        maybe debruijn := maybeDebruijnIndex(applicand')
        if debruijn = 1 then Just(result) else Void

    ifNil(Just(True)) ?? ifPush(Just(False)) ?? Void


def setTag(tag)
    Wildcard(_) -> Wildcard(tag)
    Top(_) -> Top(tag)
    Constant(_, index) -> Constant(tag, index)
    Variable(_, debruijn) -> Variable(tag, debruijn)
    MetaVariable(_, index) -> MetaVariable(tag, index)
    Function(_, isCase, domain, codomain, body) ->
        Function(tag, isCase, domain, codomain, body)
    Implication(_, type, body) -> Implication(tag, type, body)
    Application(_, left, right) -> Application(tag, left, right)
    Construction(_, parameters, type, signatures) ->
        Construction(tag, parameters, type, signatures)
    Element(_, type, term) -> Element(tag, type, term)
    Numeral(_, type, value) -> Numeral(tag, type, value)
    Operation(_, type, term, op) -> Operation(tag, type, term, op)


def setLocation(Tag(_, _, location), term)
    term.setTag(getTermTag(term).setTagLocation(location))


def sameConstant(a, b)
    if a is Constant(_, indexA)
        if b is Constant(_, indexB)
            indexA = indexB
        False
    False


def isSameTerm(a, b)
    match a
        case Wildcard(_)
            False
        case Top(_)
            isTop(b)
        case Constant(_, index)
            if b is Constant(_, index')
                index = index'
            False
        case Variable(_, debruijn)
            if b is Variable(_, debruijn')
                # debruijn = 0 represents an unknown value
                debruijn =/= 0 and debruijn = debruijn'
            False
        case MetaVariable(_, index)
            if b is MetaVariable(_, index')
                index = index'
            False
        case Function(_, _, domain, codomain, body)
            if b is Function(_, _, domain', codomain', body')
                isSameTerm(domain, domain') and
                isSameTerm(codomain, codomain') and
                isSameTerm(body, body')
            False
        case Implication(_, type, body)
            if b is Implication(_, type', body')
                isSameTerm(type, type') and isSameTerm(body, body')
            False
        case Application(_, type, body)
            if b is Application(_, type', body')
                isSameTerm(type, type') and isSameTerm(body, body')
            False
        case Construction(_, parameters, type, _)
            if b is Construction(_, parameters', type', _)
                isSameTerm(type, type') and zip(parameters, parameters').all(
                    uncurry(isSameTerm))
            False
        case Element(_, type, term)
            if b is Element(_, type', term')
                isSameTerm(type, type') and isSameTerm(term, term')
            False
        case Numeral(_, _, value)
            if b is Numeral(_, _, value')
                value = value'
            False
        case Operation(tag, _, _, _)
            if b is Operation(tag', _, _, _)
                getTagLexeme(tag) =*= getTagLexeme(tag')
            False


def sameHead(term)
    case Wildcard(_)
        False
    case Top(_)
        isTop(term)
    case Constant(_, index)
        if term is Constant(_, index')
            index = index'
        False
    case Variable(tag, _)
        False
    case MetaVariable(_, address)
        if term is MetaVariable(_, address')
            address = address'
        False
    case Function(_, _, _, _, _)
        isFunction(term)
    case Implication(_, _, _)
        isImplication(term)
    case Application(_, _, _)
        isApplication(term)
    case Construction(tag, _, _, _)
        isConstruction(term) and
            getTagLexeme(tag) =*= getTagLexeme(getTermTag(term))
    case Element(_, _, _)
        isElement(term)
    case Numeral(_, _, value)
        if term is Numeral(_, _, value')
            value = value'
        False
    case Operation(tag, _, _, _)
        if term is Operation(tag', _, _, _)
            getTagLexeme(tag) =*= getTagLexeme(tag')
        False


def getComponents
    Wildcard(_) -> []
    Top(_) -> []
    Constant(_, _) -> []
    Variable(_, _) -> []
    MetaVariable(_, _) -> []
    Function(_, _, domain, codomain, body) -> [domain, codomain, body]
    Implication(_, type, body) -> [type, body]
    Application(_, left, right) -> [left, right]
    Construction(_, parameters, _, _) -> parameters
    Element(_, type, term) -> [type, term]
    Numeral(_, _, _) -> []
    Operation(_, _, _, _) -> []


def mapComponents(f, term)
    match term
        Wildcard(_) -> term
        Top(_) -> term
        Constant(_, _) -> term
        Variable(_, _) -> term
        MetaVariable(_, _) -> term
        Function(tag, isCase, domain, codomain, body) ->
            Function(tag, isCase, f(domain), f(codomain), f(body))
        Implication(tag, type, body) -> Implication(tag, f(type), f(body))
        Application(tag, left, right) ->
            Application(tag, mapComponents(f, left), f(right))
        Construction(tag, parameters, type, signatures) ->
            Construction(tag, parameters.map(f), type, signatures)
        Element(tag, type, term) -> Element(tag, f(type), f(term))
        Numeral(_, _, _) -> term
        Operation(_, _, _, _) -> term


def getSuffix(count, index)
    if count <= 1 or index = 0 then ""
    subscripts := ["â‚€", "â‚", "â‚‚", "â‚ƒ", "â‚„", "â‚…", "â‚†", "â‚‡", "â‚ˆ", "â‚‰"]
    showNatural(index).map(x -> subscripts.at(x -- '0') ?? "").join


def showConstruction(showTerm, headTag, arguments)
    argumentStrings := arguments.map(showTerm)
    if argumentStrings is argumentString :: argumentStrings'
        fixity := getTagFixity(headTag)
        lexeme := getTagLexeme(headTag)
        if fixity = INFIX and length(arguments) = 2
            items := argumentString :: lexeme :: argumentStrings'
            "(" ++ items.joinWith(" ") ++ ")"
        if fixity = PREFIX and length(arguments) = 1
            lexeme ++ "(" ++ argumentString ++ ")"
        if fixity = POSTFIX and length(arguments) = 1
            "(" ++ argumentString ++ ")" ++ lexeme
        showTag(headTag) ++ "(" ++ argumentStrings.joinWith(", ") ++ ")"
    showTag(headTag)


def showApplication(showTerm, applicand, argument)
    (headTerm, applicandArguments) := splitSpine(applicand)
    arguments := applicandArguments ++ [argument]
    if isConstant(headTerm)
        showConstruction(showTerm, getTermTag(headTerm), arguments)
    showTerm(headTerm) ++ "(" ++ arguments.map(showTerm).joinWith(", ") ++ ")"


def showMetaVariable(n)
    characters := ['a', 'b', 'c', 'd']
    if n < 4
        [characters.at(n) ?? '#']
    showMetaVariable((n // 4) -- 1) ++ [characters.at(n % 4) ?? '#']


def showTerm
    Wildcard(_) -> "â˜†"
    Top(_) -> "âŠ¤"
    Constant(tag, n) -> showTag(tag) # ++ "$" ++ showNatural(n)
    Variable(tag, n) -> showTag(tag) # ++ "#" ++ showNatural(n)
    MetaVariable(tag, n) -> showMetaVariable(n)
    Function(tag, _, domain, _, body) ->
        "(" ++ showTag(tag) ++ " : " ++
            showTerm(domain) ++ " â†¦ " ++ showTerm(body) ++ ")"
    Implication(tag, type, body) ->
        if isImplication(type) then
            "(" ++ showTerm(type) ++ ")" ++ " â‡’ " ++ showTerm(body) else
                showTerm(type) ++ " â‡’ " ++ showTerm(body)
    Application(_, applicand, argument) ->
        showApplication(showTerm, applicand, argument)
    Construction(tag, parameters, _, _) ->
        showConstruction(showTerm, tag, parameters)
    Element(tag, _, term) -> showTerm(term)
    Numeral(_, _, n) -> showNatural(n)
    Operation(tag, _, _, _) -> showTag(tag)


def showTermLocation(term)
    showLocation(getTagLocation(getTermTag(term)))


def showTermAndLocation(term)
    showTerm(term) ++ " at " ++ showTermLocation(term)

#*
