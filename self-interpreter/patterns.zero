#* patterns.zero

define isCase(node)
    isArrow(node) and isThisLexeme(node, "case")


define getArguments(pattern)
    if not isJuxtaposition(pattern)
        []
    getArguments(getLeft(pattern)) ++ [getRight(pattern)]


define newProjector(tag, size, index)
    reference := newUnderscore(tag, size - index)
    ((Arrow(tag, Name(renameTag(tag, "_")))) ^^ size)(reference)


define newPatternArrow(tag, pattern, body)
    match pattern
        case Name(_) -> Arrow(tag, pattern, body)
        case Arrow(_, _, _) -> syntaxError("invalid parameter", pattern)
        case Juxtaposition(_, left, right)
            if isThisLexeme(pattern, "@")
                newPatternArrow(tag, left,
                    Juxtaposition(tag, newPatternArrow(tag, right, body), left))
            arguments := getArguments(pattern)
            size := length(arguments)
            underscore := newUnderscore(tag, 1)
            function := arguments.fold(newPatternArrow(tag), body)
            projectors := (0 .. size - 1).map(newProjector(tag, size))
            projections := projectors.map(Juxtaposition(tag, underscore))
            Arrow(tag, Name(renameTag(tag, "_")),
                projections.cascade(Juxtaposition(tag), function))
        case Number(_, _) -> Arrow(tag, pattern, body)
        case Reference(_, _) -> syntaxError("invalid parameter", pattern)
        case Operator(_, _) -> syntaxError("invalid parameter", pattern)
        case Definition(_, _, _) -> syntaxError("invalid parameter", pattern)


define isAsPattern(node)
    isJuxtaposition(node) and isThisLexeme(node, "@")


define getNameAndValue(f, left, right)
    if isNull(right)
        undefined                   # force syntax errors
    if not isJuxtaposition(left)
        (left, right)
    getNameAndValue(f, getLeft(left), f(getRight(left), right))


define newCasePatternArrow(tag, left, right)
    if isThisName(left, "()")
        Arrow(tag, Name(renameTag(tag, "_")), right)
    newPatternArrow(tag, left, right)


define newCaseArgument(tag, left, right)
    pattern := if isAsPattern(left) then getRight(left) else left
    (_, right') := getNameAndValue(newCasePatternArrow(tag), pattern, right)
    if not isAsPattern(left)
        right'
    wrapper := newPatternArrow(tag, getLeft(left), right')
    Juxtaposition(tag, wrapper, newUnderscore(tag, 1))


define newCase(tag, left, right)
    argument := newCaseArgument(tag, left, right)
    parameter := Name(renameTag(tag, "_"))
    reference := newUnderscore(tag, 1)
    Arrow(tag, parameter, Juxtaposition(tag, reference, argument))


define mergeCaseBodies(tag, left, right)
    if not isJuxtaposition(right)
        left
    merged := mergeCaseBodies(tag, left, getLeft(right))
    Juxtaposition(tag, merged, getRight(right))


define combineCases(tag, left, right)
    body := mergeCaseBodies(tag, getArrowRight(left), getArrowRight(right))
    Arrow(tag, Name(renameTag(tag, "_")), body)

#*
