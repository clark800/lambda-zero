#* patterns.zero

define getHead(node)
    if isJuxtaposition(node) then getHead(getLeft(node)) else node


define getArguments(pattern)
    if not isJuxtaposition(pattern)
        []
    getArguments(getLeft(pattern)) ++ [getRight(pattern)]


define newProjector(tag, size, index)
    (UnderscoreArrow(tag)^<>(size))(Underscore(tag, size - index))


define newPatternArrow(pattern, body)
    if isName(pattern)
        LockedArrow(pattern, body)
    if isAsPattern(pattern)
        label := getLabel(pattern)
        LockedArrow(label, Juxtaposition(getTag(pattern),
            newPatternArrow(getPattern(pattern), body),
            Reference(getTag(label), 1, 0, getReferenceFixity(label))))
    if isJuxtaposition(pattern)
        constructor := getHead(pattern)
        tag := getTag(constructor)
        arguments := getArguments(pattern)
        size := length(arguments)
        underscore := Underscore(tag, 1)
        function := arguments.fold(newPatternArrow, body)
        projectors := (0 .. size - 1).map(newProjector(tag, size))
        projections := projectors.map(Juxtaposition(tag, underscore))
        lockArrow(StrictArrow(tag, [constructor],
            projections.cascade(Juxtaposition(tag), function)))
    syntaxError("invalid parameter", pattern)


define getNameAndValue(f, left, right)
    if isNull(right)
        undefined                   # force syntax errors
    if not isJuxtaposition(left)
        (left, right)
    getNameAndValue(f, getLeft(left), f(getRight(left), right))


define newCaseArrow(left, right)
    pattern := if isAsPattern(left) then getPattern(left) else left
    (name, reconstructor) :=
        getNameAndValue(newPatternArrow, pattern, right)
    constructor := Name(getTag(name))  # name could be a number
    tag := getTag(constructor)
    underscore := Underscore(tag, 1)
    if not isAsPattern(left)
        StrictArrow(tag, [constructor],
            Juxtaposition(tag, underscore, reconstructor))
    wrapper := newPatternArrow(getLabel(left), reconstructor)
    argument := Juxtaposition(tag, wrapper, underscore)
    StrictArrow(tag, [constructor], Juxtaposition(tag, underscore, argument))


define addCases(tag, base, extension)
    if not isJuxtaposition(extension)
        base
    merged := addCases(tag, base, getLeft(extension))
    Juxtaposition(tag, merged, getRight(extension))


define newCaseBody(tag, left, right)
    base := if isSimpleArrow(left) then
        Juxtaposition(tag, Underscore(tag, 1), getArrowRight(left)) else
        getArrowRight(left)
    if isSimpleArrow(right)
        Juxtaposition(tag, base, getArrowRight(right))
    addCases(tag, base, getArrowRight(right))


define getCaseConstructors(arrow)
    if isSimpleArrow(arrow)
        [getArrowLeft(arrow)]
    getConstructors(arrow)


define isDefaultCase(arrow)
    isSimpleArrow(arrow) and isUnderscore(getTag(getArrowLeft(arrow)))


define getReconstructor(arrow)
    if isSimpleArrow(arrow)
        getArrowRight(arrow)
    getRight(getArrowRight(arrow))


define chainCases(tag, arrow, fallback)
    deconstructor := Name(addPrefix(getTag(arrow), '@'))
    reconstructor := getReconstructor(arrow)
    body := Juxtaposition(tag, Juxtaposition(tag, Juxtaposition(tag,
        deconstructor, reconstructor), fallback), Underscore(tag, 1))
    SimpleArrow(Name(renameTag(tag, "_")), body)


define combineCases(tag, left, right)
    if isDefaultCase(right)
        chainCases(tag, left, right)
    constructors := getCaseConstructors(left) ++ getCaseConstructors(right)
    StrictArrow(tag, constructors, newCaseBody(tag, left, right))

#*
