#* patterns.zero

define isCase(node)
    isLambda(node) and isThisLexeme(node, "case")


define getArguments(pattern)
    if not isApplication(pattern)
        []
    getArguments(getLeft(pattern)) ++ [getRight(pattern)]


define newProjector(tag, size, index)
    reference := newUnderscore(tag, size - index)
    ((newLambda(tag, newUnderscore(tag, 0))) ^^ size)(reference)


define newPatternLambda(tag, pattern, body)
    match getNodeType(pattern)
        case SYMBOL -> newLambda(tag, pattern, body)
        case LAMBDA -> syntaxError("invalid parameter", pattern)
        case APPLICATION
            if isThisLexeme(pattern, "@")
                newPatternLambda(tag, getLeft(pattern),
                    newApplication(tag, newPatternLambda(tag,
                        getRight(pattern), body), getLeft(pattern)))
            arguments := getArguments(pattern)
            size := length(arguments)
            underscore := newUnderscore(tag, 1)
            function := arguments.fold(newPatternLambda(tag), body)
            projectors := (0 .. size - 1).map(newProjector(tag, size))
            projections := projectors.map(newApplication(tag, underscore))
            application := projections.cascade(newApplication(tag), function)
            newLambda(tag, newUnderscore(tag, 0), application)
        case DEFINITION -> syntaxError("invalid parameter", pattern)
        case NATURAL -> newLambda(tag, pattern, body)
        case BUILTIN -> syntaxError("invalid parameter", pattern)


define isAsPattern(node)
    isApplication(node) and isThisLexeme(node, "@")


define getNameAndValue(tag, left, right)
    if isNull(right)
        undefined                   # force syntax errors
    if not isApplication(left)
        (left, right)
    getNameAndValue(tag, getLeft(left),
        newPatternLambda(tag, getRight(left), right))


define newCaseArgument(tag, left, right)
    pattern := isAsPattern(left) ? getRight(left) || left
    (_, right') := getNameAndValue(tag, pattern, right)
    if not isAsPattern(left)
        right'
    wrapper := newPatternLambda(tag, getLeft(left), right')
    newApplication(tag, wrapper, newUnderscore(tag, 1))


define newCase(tag, left, right)
    argument := newCaseArgument(tag, left, right)
    parameter := newUnderscore(tag, 0)
    reference := newUnderscore(tag, 1)
    newLambda(tag, parameter, newApplication(tag, reference, argument))


define mergeCaseBodies(tag, left, right)
    if not isApplication(right)
        left
    merged := mergeCaseBodies(tag, left, getLeft(right))
    newApplication(tag, merged, getRight(right))


define combineCases(tag, left, right)
    body := mergeCaseBodies(tag, getBody(left), getBody(right))
    newLambda(tag, newUnderscore(tag, 0), body)

#*
