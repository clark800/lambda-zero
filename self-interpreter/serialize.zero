#* serialize.zero

def serialize(closure)
    def serialize'(Closure(term, environment), depth)
        match term
            case Unknown(tag)
                "■"
            case MetaVariable(tag, index)
                showMetaVariable(index)
            case Type(tag, index)
                "⊤" ++ showIntegerSubscript(index)
            case Variable(tag, index)
                match index
                    case +_ n
                        showTag(tag)
                    case -_ n
                        if n <= depth
                            showTag(tag)
                        if environment.peek(n -- depth -- 1) is Just(closure)
                            serialize'(closure, 0)
                        showTag(tag)
            case Singleton(tag, type, index)
                "(" ++ serialize'(Closure(type, environment), depth) ++ ")" ++
                    showIntegerSubscript(index)
            case Function(tag, _, body)
                "(" ++ showTag(tag) ++ " ↦ " ++
                    serialize'(Closure(body, environment), depth + 1) ++ ")"
            case Implication(tag, domain, body)
                "(" ++ serialize'(Closure(domain, environment), depth) ++
                " ⇒ " ++ serialize'(Closure(body, environment), depth + 1) ++
                ")"
            case Intersection(tag, domain, body)
                if domain is Singleton(_, type, _)
                    parameters := getSingletonParameters(type)
                    showTag(tag) ++ "(" ++ parameters.map(x -> serialize'(
                        Closure(x, environment), depth)).joinWith(", ") ++ ")"
                "(" ++ showTag(tag) ++ " ↣ " ++
                    serialize'(Closure(body, environment), depth + 1) ++ ")"
            case Application(_, applicand, argument)
                "(" ++ serialize'(Closure(applicand, environment), depth) ++
                " " ++ serialize'(Closure(argument, environment), depth) ++ ")"
            case Numeral(_, _, n)
                showNatural(n)
            case Operation(tag, _, _)
                showTag(tag)

    result := serialize'(closure, 0)
    # ensure that full serialization succeeds before returning anything
    # or else lazy output will show part of the serailization even if
    # an error occurs during parsing
    if result.length = 0 then "" else result


def maybeDebruijnIndex(term)
    if term is Variable(_, index)
        if index is -_ n
            Just(n)
        Void
    Void


def maybeBody(term)
    if term is Function(_, _, body)
        Just(body)
    Void


def maybeApplicand(term)
    if term is Application(_, applicand, _)
        Just(applicand)
    Void


def maybeArgument(term)
    if term is Application(_, _, argument)
        Just(argument)
    Void


def maybeNatural(term)
    if term is Numeral(_, _, value)
        Just(value)
    Void


def maybeHead(term)
    maybe body := maybeBody(term)
    maybe body' := maybeBody(body)
    maybe applicand := maybeApplicand(body')
    maybeArgument(applicand)


def maybeTail(term)
    maybe body := maybeBody(term)
    maybe body' := maybeBody(body)
    maybeArgument(body')


def maybeIsNil(term)
    # returns True for [], False for non-nil list, Void for non-list
    # term should be (n -> p -> n) or (n -> p -> ((p c) cs))

    def ifNil(result)
        maybe body := maybeBody(term)
        maybe body' := maybeBody(body)
        maybe debruijn := maybeDebruijnIndex(body')
        if debruijn = 2 then Just(result) else Void

    def ifPush(result)
        maybe body := maybeBody(term)
        maybe body' := maybeBody(body)
        maybe applicand := maybeApplicand(body')
        maybe applicand' := maybeApplicand(applicand)
        maybe debruijn := maybeDebruijnIndex(applicand')
        if debruijn = 1 then Just(result) else Void

    ifNil(Just(True)) ?? ifPush(Just(False)) ?? Void


def serializeString(evaluateClosure, closure)
    closure' := evaluateClosure(closure)
    term := getTerm(closure')
    maybe nil := maybeIsNil(term)
    if nil
        Just([])

    unknown := enclose(Unknown(getTermTag(term)))
    environment' := getEnvironment(closure').push(unknown).push(unknown)

    maybe headTerm := maybeHead(term)
    closure' := Closure(headTerm, environment')
    maybe character := maybeNatural(getTerm(evaluateClosure(closure')))

    maybe tailTerm := maybeTail(term)
    closure'' := Closure(tailTerm, environment')
    maybe remaining := serializeString(evaluateClosure, closure'')

    Just(character :: remaining)

#*
