#* serialize.zero

define serialize(closure)
    define serialize'(Closure(term, environment), depth)
        match term
            case Variable(tag, debruijn)
                if debruijn <= depth then showTag(tag) else
                    serialize'(environment[debruijn - depth - 1], 0)
            case Abstraction(tag, _, body)
                "(" ++ showTag(tag) ++ " -> " ++
                    serialize'(Closure(body, environment), depth + 1) ++ ")"
            case Application(_, applicand, argument) -> "(" ++
                serialize'(Closure(applicand, environment), depth) ++ " " ++
                serialize'(Closure(argument, environment), depth) ++ ")"
            case Numeral(_, n)
                showNatural(n)
            case Operation(tag, _, _)
                showTag(tag)

    result := serialize'(closure, 0)
    # ensure that full serialization succeeds before returning anything
    # or else lazy output will show part of the serailization even if
    # an error occurs during parsing
    if result.length = 0 then "" else result


define serializeString(evaluateClosure, closure)
    closure' := evaluateClosure(closure)
    term := getTerm(closure')
    try nil := maybeIsNil(term)
    if nil
        just []

    dummy := Closure(Numeral(noTag, 0), [])
    enclose := `Closure(dummy :: dummy :: getEnvironment(closure'))

    try headTerm := maybeHead(term)
    try character := maybeNatural(getTerm(evaluateClosure(enclose(headTerm))))

    try tailTerm := maybeTail(term)
    try remaining := serializeString(evaluateClosure, enclose(tailTerm))

    just character :: remaining


#*
