#* serialize.zero

def serialize(closure)
    def serialize'(Closure(term, environment), depth)
        match term
            case Top(tag)
                "⊤"
            case Constant(tag, _)
                showTag(tag)
            case Variable(tag, debruijn)
                if debruijn <= depth
                    showTag(tag)
                if environment.peek(debruijn -- depth -- 1) is Just(closure)
                    serialize'(closure, 0)
                showTag(tag)
            case MetaVariable(tag, n)
                showTag(tag)
            case Function(tag, _, _, _, body)
                "(" ++ showTag(tag) ++ " ↦ " ++
                    serialize'(Closure(body, environment), depth + 1) ++ ")"
            case Implication(tag, type, body)
                "(" ++ serialize'(Closure(type, environment), depth) ++ " ⇒ " ++
                    serialize'(Closure(body, environment), depth + 1) ++ ")"
            case Implicit(tag, type, body)
                "(" ++ serialize'(Closure(type, environment), depth) ++ " ⇝ " ++
                    serialize'(Closure(body, environment), depth + 1) ++ ")"
            case Application(_, applicand, argument)
                "(" ++ serialize'(Closure(applicand, environment), depth) ++
                " " ++ serialize'(Closure(argument, environment), depth) ++ ")"
            case Construction(tag, parameters, _)
                showTag(tag) ++ "(" ++ parameters.map(x -> serialize'(
                    Closure(x, environment), depth)).joinWith(", ") ++ ")"
            case Element(tag, _, term)
                serialize'(Closure(term, environment), depth)
            case Numeral(_, _, n)
                showNatural(n)
            case Operation(tag, _, _, _, _)
                showTag(tag)

    result := serialize'(closure, 0)
    # ensure that full serialization succeeds before returning anything
    # or else lazy output will show part of the serailization even if
    # an error occurs during parsing
    if result.length = 0 then "" else result


def serializeString(evaluateClosure, closure)
    closure' := evaluateClosure(closure)
    term := getTerm(closure')
    maybe nil := maybeIsNil(term)
    if nil
        Just([])

    dummy := Closure(Variable(noTag, 0), newArray([]))
    environment' := getEnvironment(closure').push(dummy).push(dummy)
    enclose := `Closure(environment')

    maybe headTerm := maybeHead(term)
    maybe character := maybeNatural(getTerm(evaluateClosure(enclose(headTerm))))

    maybe tailTerm := maybeTail(term)
    maybe remaining := serializeString(evaluateClosure, enclose(tailTerm))

    Just(character :: remaining)


#*
