#* serialize.zero

define showAST(node)
    match getNodeType(node)
        case SYMBOL -> showLexeme(node)
        case LAMBDA -> "(" ++ showLexeme(getParameter(node)) ++ " -> " ++
                   showAST(getBody(node)) ++ ")"
        case APPLICATION -> "(" ++ showAST(getLeft(node)) ++ " " ++
                   showAST(getRight(node)) ++ ")"
        case DEFINITION -> "(" ++ showAST(getLeft(node)) ++ " := " ++
                   showAST(getRight(node)) ++ ")"
        case NATURAL -> showNatural(getValue(node))
        case BUILTIN -> "[" ++ showLexeme(node) ++ "]"


define serialize(closure)
    define serialize'(closure', depth)
        term := getTerm(closure')
        environment := getEnvironment(closure')
        match getNodeType(term)
            case SYMBOL
                debruijn := getDebruijnIndex(term)
                if debruijn > depth
                    serialize'(environment[debruijn - depth - 1], 0)
                showLexeme(term)
            case LAMBDA -> "(" ++ showLexeme(getParameter(term)) ++ " -> " ++
                serialize'(Closure(getBody(term), environment), depth + 1) ++
                ")"
            case APPLICATION -> "(" ++
                serialize'(Closure(getLeft(term), environment), depth) ++ " " ++
                serialize'(Closure(getRight(term), environment), depth) ++ ")"
            case DEFINITION -> "(" ++
                serialize'(Closure(getLeft(term), environment), depth) ++
                " := " ++
                serialize'(Closure(getRight(term), environment), depth) ++ ")"
            case NATURAL -> showNatural(getValue(term))
            case BUILTIN -> showLexeme(term)

    result := serialize'(closure, 0)
    # ensure that full serialization succeeds before returning anything
    # or else lazy output will show part of the serailization even if
    # an error occurs during parsing
    if result.length = 0 then "" else result

#*
