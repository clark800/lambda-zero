#* symbols.zero

LEFT := 0
RIGHT := 1
RIGHTVALUE := 2
NEITHER := 3

define isSpecial(node)
    getSpecial(getSyntax(node))

define propagateSection(operator, side, body)
    if isSpecial(operator) or not isJuxtaposition(body)
        syntaxError("operator does not support sections", operator)
    Section(getTag(operator), side, body)

define reduceOperator(operator, left, right)
    left' := if isSection(left) then getSectionBody(left) else left
    right' := if isSection(right) then getSectionBody(right) else right
    result := getReduce(getSyntax(operator))(operator, left', right')
    if isSection(left)
        side := if isSection(right) then LeftRightSection else RightSection
        propagateSection(operator, side, result)
    if isSection(right)
        propagateSection(operator, LeftSection, result)
    result

define reduceBracket(open, close, left, right)
    getReduce(getSyntax(close))(open, left, right)

define shift(state @ State(stack, operators), node)
    if isOperator(node)
        getShift(getSyntax(node))(state, node)
    if isNil(stack) or not isOperator(head(stack))
        syntaxError("missing operator before", node)
    State(node :: stack, operators)

define erase(stack, lexeme)
    stack.dropIf(`isThisOperator(lexeme))


define reduceTop'(operator, right, stack, operators)
    if getFixity(getSyntax(operator)) = PREFIX
        shift(State(stack, operators),
            reduceOperator(operator, Null(getTag(operator)), right))
    match stack
        case []; State(stack, operators)
        case left :: stack'
            state' := State(stack', if isSyntaxDefinition(left) then
                operators.drop(1) else operators)
            shift(state', reduceOperator(operator, left, right))


define reduceTop(state @ State(stack, operators))
    match stack
        case []; state
        case right :: stack'
            match stack'
                case []; state
                case operator :: stack''
                    if not isOperator(operator)
                        state
                    reduceTop'(operator, right, stack'', operators)


define isHigherPrecedence(left, right)
    if isEOF(left)
        False

    leftSyntax := getSyntax(left)
    rightSyntax := getSyntax(right)

    if leftSyntax.getRightPrecedence = rightSyntax.getLeftPrecedence
        if leftSyntax.getAssociativity = NEITHER
            syntaxError("operator is non-associative", left)

        if rightSyntax.getAssociativity = NEITHER
            syntaxError("operator is non-associative", right)

        if leftSyntax.getAssociativity =/= rightSyntax.getAssociativity
            syntaxError("incompatible associativity", right)

        if leftSyntax.getAssociativity = RIGHTVALUE
            getRank(left) > getRank(right)

        leftSyntax.getAssociativity = LEFT

    leftSyntax.getRightPrecedence > rightSyntax.getLeftPrecedence


define shouldReduceTop(operator, State(stack, _operators))
    match stack
        case []; False
        case x :: stack'
            if isOperator(x)
                False
            match stack'
                case []; False
                case x' :: _; isHigherPrecedence(x', operator)


define reduceLeft(state, operator)
    while(shouldReduceTop(operator), reduceTop, state)

define parseOperator(tag, value, operatorSyntax)
    Operator(renameTag(tag, getAlias(operatorSyntax)), value, operatorSyntax)

define parseSymbol(tag, value, operators)
    lexeme := getTagLexeme(tag)
    head(operators).lookup(lexeme).mapJust(parseOperator(tag, value)) ??
        (if lexeme =*= " " then (head(operators).lookup("( )").
            mapJust(Operator(tag, value)) ?? Name(tag)) else Name(tag))

#*
