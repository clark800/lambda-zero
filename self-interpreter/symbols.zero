#* symbols.zero

LEFT := 0
RIGHT := 1
RIGHTVALUE := 2
NEITHER := 3


define isSpecial(node)
    with node as Operator(_, _, syntax')
        getSpecial(syntax')
    False


define propagateSection(operator, side, body)
    if isSpecial(operator) or not isJuxtaposition(body)
        syntaxError("operator does not support sections", operator)
    Section(getTag(operator), side, body)


define reduceOperator(operator, left, right)
    left' := with left as Section(_, _, body); body <| left
    right' := with right as Section(_, _, body); body <| right
    with operator as Operator(_, _, syntax')
        result := getReduce(syntax')(operator, left', right')
        if isSection(left)
            side := if isSection(right) then LeftRightSection else RightSection
            propagateSection(operator, side, result)
        if isSection(right)
            propagateSection(operator, LeftSection, result)
        result
    syntaxError("internal error", operator)


define reduceBracket(open, close, left, right)
    with close as Operator(_, _, syntax')
        getReduce(syntax')(open, left, right)
    syntaxError("internal error", close)


define shift(state @ State(stack, operators), node)
    with node as Operator(_, _, syntax')
        getShift(syntax')(state, node)
    with stack as top :: _
        if not isOperator(top)
            syntaxError("missing operator before", node)
        State(node :: stack, operators)
    syntaxError("missing operator before", node)


define erase(stack, lexeme)
    stack.dropIf(`isThisOperator(lexeme))


define reduceTop'(operator, right, stack, operators)
    with operator as Operator(tag, _, syntax')
        if getFixity(syntax') = PREFIX
            shift(State(stack, operators),
                reduceOperator(operator, Null(tag), right))
        with stack as left :: stack'
            state' := State(stack', if isSyntaxDefinition(left) then
                operators.drop(1) else operators)
            shift(state', reduceOperator(operator, left, right))
        State(stack, operators)
    syntaxError("internal error", operator)


define reduceTop(state @ State(stack, operators))
    with stack as right :: stack'
        with stack' as operator :: stack''
            if isOperator(operator)
                reduceTop'(operator, right, stack'', operators)
            state
        state
    state


define isHigherPrecedence(left, right)
    if isEOF(left)
        False

    with left as Operator(_, leftRank, leftSyntax)
        with right as Operator(_, rightRank, rightSyntax)
            if leftSyntax.getRightPrecedence = rightSyntax.getLeftPrecedence
                if leftSyntax.getAssociativity = NEITHER
                    syntaxError("operator is non-associative", left)

                if rightSyntax.getAssociativity = NEITHER
                    syntaxError("operator is non-associative", right)

                if leftSyntax.getAssociativity =/= rightSyntax.getAssociativity
                    syntaxError("incompatible associativity", right)

                if leftSyntax.getAssociativity = RIGHTVALUE
                    leftRank > rightRank

                leftSyntax.getAssociativity = LEFT

            leftSyntax.getRightPrecedence > rightSyntax.getLeftPrecedence
        False
    False


define shouldReduceTop(operator, State(stack, _operators))
    with stack as x :: stack'
        if isOperator(x)
            False
        with stack' as x' :: _
            isHigherPrecedence(x', operator)
        False
    False


define reduceLeft(state, operator)
    while(shouldReduceTop(operator), reduceTop, state)


define parseOperator(tag, value, syntax')
    tag' := renameTag(tag, getAlias(syntax'), getFixity(syntax'))
    Operator(tag', value, syntax')


define lookupSyntax(lexeme, operators)
    with operators as top :: _
        top.lookup(lexeme)
    Void


define parseSymbol(tag, value, operators)
    lexeme := getTagLexeme(tag)
    operators.lookupSyntax(lexeme).mapJust(parseOperator(tag, value)) ??
        (if lexeme =*= " " then (operators.lookupSyntax("( )").
            mapJust(Operator(tag, value)) ?? Name(tag)) else Name(tag))

#*
