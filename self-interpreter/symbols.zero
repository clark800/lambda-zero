#* symbols.zero

LEFT := 0
RIGHT := 1
RIGHTVALUE := 2
NEITHER := 3


define isSpecial(node)
    getSpecial(getSyntax(node))


define propagateSection(operator, side, body)
    if isSpecial(operator) or not isJuxtaposition(body)
        syntaxError("operator does not support sections", operator)
    Section(getTag(operator), side, body)


define reduceOperator(operator, left, right)
    left' := if isSection(left) then getSectionBody(left) else left
    right' := if isSection(right) then getSectionBody(right) else right
    result := getReduce(getSyntax(operator))(operator, left', right')
    if isSection(left)
        side := if isSection(right) then LeftRightSection else RightSection
        propagateSection(operator, side, result)
    if isSection(right)
        propagateSection(operator, LeftSection, result)
    result


define reduceBracket(open, close, left, right)
    getReduce(getSyntax(close))(open, left, right)


define shift(state @ State(stack, operators), node)
    if isOperator(node)
        getShift(getSyntax(node))(state, node)
    with stack as top :: _
        if not isOperator(top)
            syntaxError("missing operator before", node)
        State(node :: stack, operators)
    syntaxError("missing operator before", node)


define erase(stack, lexeme)
    stack.dropIf(`isThisOperator(lexeme))


define reduceTop'(operator, right, stack, operators)
    if getFixity(getSyntax(operator)) = PREFIX
        shift(State(stack, operators),
            reduceOperator(operator, Null(getTag(operator)), right))
    with stack as left :: stack'
        state' := State(stack', if isSyntaxDefinition(left) then
            operators.drop(1) else operators)
        shift(state', reduceOperator(operator, left, right))
    State(stack, operators)


define reduceTop(state @ State(stack, operators))
    with stack as right :: stack'
        with stack' as operator :: stack''
            if isOperator(operator)
                reduceTop'(operator, right, stack'', operators)
            state
        state
    state


define isHigherPrecedence(left, right)
    if isEOF(left)
        False

    leftSyntax := getSyntax(left)
    rightSyntax := getSyntax(right)

    if leftSyntax.getRightPrecedence = rightSyntax.getLeftPrecedence
        if leftSyntax.getAssociativity = NEITHER
            syntaxError("operator is non-associative", left)

        if rightSyntax.getAssociativity = NEITHER
            syntaxError("operator is non-associative", right)

        if leftSyntax.getAssociativity =/= rightSyntax.getAssociativity
            syntaxError("incompatible associativity", right)

        if leftSyntax.getAssociativity = RIGHTVALUE
            getRank(left) > getRank(right)

        leftSyntax.getAssociativity = LEFT

    leftSyntax.getRightPrecedence > rightSyntax.getLeftPrecedence


define shouldReduceTop(operator, State(stack, _operators))
    with stack as x :: stack'
        if isOperator(x)
            False
        with stack' as x' :: _
            isHigherPrecedence(x', operator)
        False
    False


define reduceLeft(state, operator)
    while(shouldReduceTop(operator), reduceTop, state)


define parseOperator(tag, value, operatorSyntax)
    Operator(renameTag(tag, getAlias(operatorSyntax)), value, operatorSyntax)


define lookupSyntax(lexeme, operators)
    with operators as top :: _
        top.lookup(lexeme)
    Void


define parseSymbol(tag, value, operators)
    lexeme := getTagLexeme(tag)
    operators.lookupSyntax(lexeme).mapJust(parseOperator(tag, value)) ??
        (if lexeme =*= " " then (operators.lookupSyntax("( )").
            mapJust(Operator(tag, value)) ?? Name(tag)) else Name(tag))

#*
