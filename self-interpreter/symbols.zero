#* symbols.zero

NOFIX := 0
PREFIX := 1
INFIX := 2
POSTFIX := 3
OPENFIX := 4
CLOSEFIX := 5

LEFT := 0
RIGHT := 1
RIGHTVALUE := 2
NEITHER := 3

SyntaxType ::= {Syntax(
    getAlias : List(Natural),
    getLeftPrecedence : Natural,
    getRightPrecedence : Natural,
    getFixity : Natural,
    getAssociativity : Natural,
    getSpecial : Boolean,
    getShift : _,
    getReduce : _,
    getPrior : List(Natural)
)}

StateType ::= {State(
    getStack : List(Node(ASTData)),
    getOperators : List(Pair(List(N), SyntaxType))
)}

define isSpecial(node)
    getSpecial(getSyntax(node))

define propagateSection(operator, side, body)
    if isSpecial(operator) or not isJuxtaposition(body)
        syntaxError("operator does not support sections", operator)
    Section(getTag(operator), side, body)

define reduceOperator(operator, left, right)
    left' := if isSection(left) then getSectionBody(left) else left
    right' := if isSection(right) then getSectionBody(right) else right
    result := getReduce(getSyntax(operator))(operator, left', right')
    if isSection(left)
        side := if isSection(right) then LeftRightSection else RightSection
        propagateSection(operator, side, result)
    if isSection(right)
        propagateSection(operator, LeftSection, result)
    result

define reduceBracket(open, close, left, right)
    getReduce(getSyntax(close))(open, left, right)

define shift(state @ State(stack, operators), node)
    if isOperator(node)
        getShift(getSyntax(node))(state, node)
    if isNil(stack) or not isOperator(head(stack))
        syntaxError("missing operator before", node)
    State(node :: stack, operators)

define erase(stack, lexeme)
    stack.dropIf(`isThisOperator(lexeme))

define reduceTop(State(stack, operators))
    if isOperator(stack[1]) and getFixity(getSyntax(stack[1])) = PREFIX
        shift(State(stack.drop(2), operators),
            reduceOperator(stack[1], Null(getTag(stack[1])), stack[0]))
    operators' := if isSyntaxDefinition(stack[2]) then
        tail(operators) else operators
    shift(State(stack.drop(3), operators'),
        reduceOperator(stack[1], stack[2], stack[0]))

define isHigherPrecedence(left, right)
    if isEOF(left)
        false

    leftSyntax := getSyntax(left)
    rightSyntax := getSyntax(right)

    if leftSyntax.getRightPrecedence = rightSyntax.getLeftPrecedence
        if leftSyntax.getAssociativity = NEITHER
            syntaxError("operator is non-associative", left)

        if rightSyntax.getAssociativity = NEITHER
            syntaxError("operator is non-associative", right)

        if leftSyntax.getAssociativity =/= rightSyntax.getAssociativity
            syntaxError("incompatible associativity", right)

        if leftSyntax.getAssociativity = RIGHTVALUE
            getRank(left) > getRank(right)

        leftSyntax.getAssociativity = LEFT

    leftSyntax.getRightPrecedence > rightSyntax.getLeftPrecedence

define shouldReduceTop(operator, State(stack, _operators))
    not isOperator(stack[0]) and isHigherPrecedence(stack[1], operator)

define reduceLeft(state, operator)
    reduceTop.while(shouldReduceTop(operator), state)

define lookupSyntax(operators, lexeme)
    if isNil(operators)
        void
    (lexeme', syntax') := head(operators)
    if lexeme =*= lexeme'
        just(syntax')
    lookupSyntax(tail(operators), lexeme)

define parseOperator(tag, value, operatorSyntax)
    Operator(renameTag(tag, getAlias(operatorSyntax)), value, operatorSyntax)

define parseSymbol(operators, tag, value)
    lexeme := getTagLexeme(tag)
    operators.lookupSyntax(lexeme).mapJust(parseOperator(tag, value)) ??
        (if lexeme =*= " " then (operators.lookupSyntax("( )").
            mapJust(Operator(tag, value)) ?? Name(tag, 0)) else
            Name(tag, 0))

#*
