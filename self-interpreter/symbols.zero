#* symbols.zero

NOFIX := 0
PREFIX := 1
INFIX := 2
POSTFIX := 3
OPENFIX := 4
CLOSEFIX := 5

LEFT := 0
RIGHT := 1
RIGHTVALUE := 2
NEITHER := 3

SyntaxType ::= {Syntax(
    getLeftPrecedence : Natural,
    getRightPrecedence : Natural,
    getFixity : Natural,
    getAssociativity : Natural,
    getSpecial : Boolean,
    getShift : _,
    getReduce : _,
    getPrior : List(Natural)
)}

StateType ::= {State(
    getStack : List(Node(ASTData)),
    getOperators : List(Pair(List(N), SyntaxType))
)}

define isOperator(node)
    isRight(getMaybeData(node))

define reduceOperand(node, _left, _right)
    node

define shiftOperand(State(stack, operators), node)
    if isNil(stack) or not isOperator(head(stack))
        syntaxError("missing operator before", node)
    State(node :: stack, operators)

define getSyntax(node)
    getMaybeData(node) ?
        Syntax(0, 0, NOFIX, NEITHER, false, shiftOperand, reduceOperand, "")

define isSpecial(node)
    getSpecial(getSyntax(node))

define propagateSection(operator, node, lexeme)
    if isSpecial(operator) or not isApplication(node)
        syntaxError("operator does not support sections", operator)
    newApplication(renameTag(getTag(node), lexeme),
        getLeft(node), getRight(node))

define reduceOperator(operator, left, right)
    result := getReduce(getSyntax(operator))(operator, left, right)
    if not isNull(left) and isSection(left)
        propagateSection(operator, result,
            if not isNull(right) and isSection(right) then ".*." else ".*")
    if not isNull(right) and isSection(right)
        propagateSection(operator, result, "*.")
    result

define reduceBracket(open, close, left, right)
    getReduce(getSyntax(close))(open, left, right)

define shift(state, node)
    getShift(getSyntax(node))(state, node)

define erase(stack, lexeme)
    stack.dropIf(`isThisSymbol(lexeme))

define isSyntaxDeclarationMarker(node)
    isLambda(node) and isThisLexeme(node, "syntax")

define reduceTop(State(stack, operators))
    if getFixity(getSyntax(stack[1])) = PREFIX
        shift(State(stack.drop(2), operators),
            reduceOperator(stack[1], NULL, stack[0]))
    operators' := if isSyntaxDeclarationMarker(stack[2]) then
        tail(operators) else operators
    shift(State(stack.drop(3), operators'),
        reduceOperator(stack[1], stack[2], stack[0]))

define isHigherPrecedence(left, right)
    if isEOF(left)
        false

    leftSyntax := getSyntax(left)
    rightSyntax := getSyntax(right)

    if leftSyntax.getRightPrecedence = rightSyntax.getLeftPrecedence
        if leftSyntax.getAssociativity = NEITHER
            syntaxError("operator is non-associative", left)

        if rightSyntax.getAssociativity = NEITHER
            syntaxError("operator is non-associative", right)

        if leftSyntax.getAssociativity =/= rightSyntax.getAssociativity
            syntaxError("incompatible associativity", right)

        if leftSyntax.getAssociativity = RIGHTVALUE
            getValue(left) > getValue(right)

        leftSyntax.getAssociativity = LEFT

    leftSyntax.getRightPrecedence > rightSyntax.getLeftPrecedence

define shouldReduceTop(operator, State(stack, _operators))
    not isOperator(stack[0]) and isHigherPrecedence(stack[1], operator)

define reduceLeft(state, operator)
    reduceTop.while(shouldReduceTop(operator), state)

define lookupSyntax(operators, lexeme)
    if isNil(operators)
        Left()
    (lexeme', syntax') := head(operators)
    if lexeme =*= lexeme'
        Right(syntax')
    lookupSyntax(tail(operators), lexeme)

define parseSymbol(operators, tag, value)
    lexeme := getTagLexeme(tag)
    operators.lookupSyntax(lexeme).mapRight(newOperator(tag, value)) ?
        (if lexeme =*= " " then (operators.lookupSyntax("( )").
            mapRight(newOperator(tag, value)) ? newName(tag)) else
            newName(tag))

#*
