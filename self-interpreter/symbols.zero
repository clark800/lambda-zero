#* symbols.zero

NOFIX := 0
PREFIX := 1
INFIX := 2
POSTFIX := 3
OPENFIX := 4
CLOSEFIX := 5

LEFT := 0
RIGHT := 1
RIGHTVALUE := 2
NEITHER := 3

SyntaxType ::= {Syntax(
    getLeftPrecedence : Natural,
    getRightPrecedence : Natural,
    getFixity : Natural,
    getAssociativity : Natural,
    getSpecial : B,
    getShift : _,
    getReduce : _
)}

StateType ::= {State(
    getStack : List(Node(ASTData)),
    getOperators : List(Pair(List(N), SyntaxType))
)}

define isOperator(node)
    isJust(getMaybeData(node))

define reduceOperand(node, _left, _right)
    node

define shiftOperand(State(stack, operators), node)
    if isNil(stack) or not isOperator(head(stack))
        syntaxError("missing operator before", node)
    State(node :: stack, operators)

define getSyntax(node)
    getMaybeData(node) ?!
        Syntax(0, 0, NOFIX, NEITHER, false, shiftOperand, reduceOperand)

define isSpecial(node)
    getSpecial(getSyntax(node))

define propagateSection(operator, node, lexeme)
    if isSpecial(operator) or not isApplication(node)
        syntaxError("operator does not support sections", operator)
    newApplication(renameTag(getTag(node), lexeme),
        getLeft(node), getRight(node))

define reduceOperator(operator, left, right)
    result := getReduce(getSyntax(operator))(operator, left, right)
    if not isNull(left) and isSection(left)
        propagateSection(operator, result,
            not isNull(right) and isSection(right) ? ".*." || ".*")
    if not isNull(right) and isSection(right)
        propagateSection(operator, result, "*.")
    result

define reduceBracket(open, close, left, right)
    getReduce(getSyntax(close))(open, left, right)

define shift(state, node)
    getShift(getSyntax(node))(state, node)

define erase(stack, lexeme)
    stack.dropIf(`isThisSymbol(lexeme))

define isSyntaxDeclarationMarker(node)
    isLambda(node) and isThisLexeme(node, "syntax")

define reduceTop(State(stack, operators))
    if getFixity(getSyntax(stack[1])) = PREFIX
        shift(State(stack.drop(2), operators),
            reduceOperator(stack[1], NULL, stack[0]))
    operators' := isSyntaxDeclarationMarker(stack[2]) ?
        tail(operators) || operators
    shift(State(stack.drop(3), operators'),
        reduceOperator(stack[1], stack[2], stack[0]))

define isHigherPrecedence(left, right)
    if isEOF(left)
        false

    leftSyntax := getSyntax(left)
    rightSyntax := getSyntax(right)

    if leftSyntax.getRightPrecedence = rightSyntax.getLeftPrecedence
        if leftSyntax.getAssociativity = NEITHER
            syntaxError("operator is non-associative", left)

        if rightSyntax.getAssociativity = NEITHER
            syntaxError("operator is non-associative", right)

        if leftSyntax.getAssociativity =/= rightSyntax.getAssociativity
            syntaxError("incompatible associativity", right)

        if leftSyntax.getAssociativity = RIGHTVALUE
            getValue(left) > getValue(right)

        leftSyntax.getAssociativity = LEFT

    leftSyntax.getRightPrecedence > rightSyntax.getLeftPrecedence

define shouldReduceTop(operator, State(stack, _operators))
    not isOperator(stack[0]) and isHigherPrecedence(stack[1], operator)

define reduceLeft(state, operator)
    reduceTop.while(shouldReduceTop(operator), state)

define lookupSyntax(operators, lexeme)
    if isNil(operators)
        nothing
    (lexeme', syntax') := head(operators)
    if lexeme =*= lexeme'
        just(syntax')
    lookupSyntax(tail(operators), lexeme)

define parseSymbol(operators, tag, value)
    lexeme := getTagLexeme(tag)
    operators.lookupSyntax(lexeme) ?? just <> newOperator(tag, value) ?!
        (lexeme =*= " " ? (operators.lookupSyntax("( )") ??
            just <> newOperator(tag, value) ?! newName(tag)) || newName(tag))

#*
