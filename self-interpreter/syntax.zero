#* syntax.zero

define reduceApply(operator, left, right)
    Juxtaposition(getTag(operator), left, right)


define reduceInfix(operator, left, right)
    reduceApply(operator, reduceApply(operator,
        Name(getTag(operator), 0), left), right)


define reducePrefix(operator, _left, right)
    reduceApply(operator, Name(getTag(operator), 0), right)


define reducePostfix(operator, left, _right)
    reduceApply(operator, Name(getTag(operator), 0), left)


define reduceArrow(operator, left, right)
    if isKeyphrase(left, "case")
        newCase(getTag(left), getRight(left), right)
    newPatternArrow(getTag(operator), left, right)


define reduceAsPattern(operator, left, right)
    if not isName(left)
        syntaxError("expected name to left of", operator)
    AsPattern(getTag(operator), left, right)


define reduceCommaPair(operator, left, right)
    CommaPair(getTag(operator), left, right)


define reduceNewline(operator, left, right)
    if isDefinition(left)
        applyDefinition(left, right)
    if isKeyphrase(left, "define")
        reduceDefine(getLeft(left), getRight(left), right)
    if isCase(left) and isCase(right)
        combineCases(left, right)
    if isKeyphrase(left, "case")
        reduceArrow(operator, left, right)
    reduceApply(operator, left, right)


define shiftPrefix(state, operator)
    state' := reduceLeft(state, operator)
    State(operator :: getStack(state'), getOperators(state'))


define shiftPostfix(state, operator)
    stack := erase(getStack(state), " ")
    state' := reduceLeft(State(stack, getOperators(state)), operator)
    stack' := getStack(state')
    if not isSpecial(operator) and isOpenOperator(head(stack'))
        placeholder := newLeftPlaceholder(getTag(head(stack')))
        body := reduceOperator(operator, placeholder, Null(getTag(placeholder)))
        State(body :: stack', getOperators(state))
    operand := stack'[0]
    if isOperator(operand)
        syntaxError("missing left operand for", operator)
    reduced := reduceOperator(operator, operand, Null(getTag(operator)))
    State(reduced :: tail(stack'), getOperators(state))


define shiftInfix(state, operator)
    stack := erase(getStack(state), " ")
    state' := reduceLeft(State(stack, getOperators(state)), operator)
    stack' := getStack(state')
    operators := getOperators(state')
    top := head(stack')
    tag := getTag(operator)
    if isOperator(top)
        if isThisOperator(operator, "+")
            operator' := operators.parseSymbol(renameTag(tag, "(+)"), 0)
            State(operator' :: stack', operators)
        if isThisOperator(operator, "-")
            operator' := operators.parseSymbol(renameTag(tag, "(-)"), 0)
            State(operator' :: stack', operators)
        if not isSpecial(operator) and isOpenOperator(top)
            placeholder := newLeftPlaceholder(tag)
            State(operator :: placeholder :: stack', operators)
        syntaxError("missing left operand for", operator)
    State(operator :: stack', operators)


define shiftSpace(state, operator)
    state' := reduceLeft(state, operator)
    if isOperator(head(getStack(state')))
        state'
    State(operator :: getStack(state'), getOperators(state'))


define reduceReserved(operator, _left, _right)
    syntaxError("reserved operator", operator)


define reduceInvalid(operator, _left, _right)
    syntaxError("operator syntax undeclared", operator)


define newOperator'(tag, precedence, fixity, associativity, shifter, reducer)
    Operator(tag, 0, Syntax(getTagLexeme(tag), precedence, precedence, fixity,
        associativity, false, shifter, reducer, ""))


define newSyntaxOperator(tag, precedence, fixity)
    if getTagLexeme(tag) =*= "()"
        if not(getLexeme(fixity) =*= "infixL")
            syntaxError("syntax must be infixL", fixity)
        tag' := renameTag(tag, " ")
        newOperator'(tag', precedence, INFIX, LEFT, shiftSpace, reduceInfix)
    if getLexeme(fixity) =*= "infix"
        newOperator'(tag, precedence, INFIX, NEITHER, shiftInfix, reduceInfix)
    if getLexeme(fixity) =*= "infixL"
        newOperator'(tag, precedence, INFIX, LEFT, shiftInfix, reduceInfix)
    if getLexeme(fixity) =*= "infixR"
        newOperator'(tag, precedence, INFIX, RIGHT, shiftInfix, reduceInfix)
    if getLexeme(fixity) =*= "prefix"
        newOperator'(tag, precedence, PREFIX, LEFT, shiftPrefix, reducePrefix)
    if getLexeme(fixity) =*= "postfix"
        newOperator'(tag, precedence, POSTFIX, LEFT,
            shiftPostfix, reducePostfix)
    syntaxError("invalid fixity", fixity)


define reduceMixfix(operator, left, right)
    prior := getPrior(getSyntax(operator))
    if not isJuxtaposition(left) or not getLexeme(left) =*= prior
        syntaxError("mixfix syntax error", operator)
    reduceInfix(operator, left, right)


define newMixfixOperator(operators, tag, prior)
    precedence := getRightPrecedence(
        lookupSyntax(operators, getLexeme(prior)) ?
            syntaxError("syntax not defined", prior))
    Operator(tag, 0, Syntax(getTagLexeme(tag), precedence, precedence, INFIX,
        LEFT, false, shiftInfix, reduceMixfix, getLexeme(prior)))


define newAlias(operators, tag, name)
    if not isName(name)
        syntaxError("expected operator name", name)
    rules := lookupSyntax(operators, getLexeme(name)) ?
        syntaxError("syntax not defined", name)
    Operator(tag, 0, rules)


define defineSyntax(operators, node, name, right)
    tag := getTag(node)
    if not isName(name)
        syntaxError("expected name operand to", node)
    if getLexeme(name).any(= '_')
        syntaxError("invalid underscore in operator name", name)
    if not isJuxtaposition(right)
        syntaxError("invalid syntax definition", node)
    fixity := getLeft(right)
    if isThisName(fixity, "mixfix")
        operator := newMixfixOperator(operators, getTag(name), getRight(right))
        Definition(tag, SyntaxDefinition, name, operator)
    if isThisName(fixity, "alias")
        operator := newAlias(operators, getTag(name), getRight(right))
        Definition(tag, SyntaxDefinition, name, operator)
    if not isNumber(getRight(right))
        syntaxError("invalid syntax definition", node)
    precedence := getNumericValue(getRight(right))
    if precedence < 0 or precedence > 99
        syntaxError("invalid precedence", getRight(right))
    operator := newSyntaxOperator(getTag(name), precedence, fixity)
    Definition(tag, SyntaxDefinition, name, operator)


define addSyntax(operators, operator)
    if operators.map(first).any(=*= getLexeme(operator))
        syntaxError("syntax already defined", operator)
    operators' := (getLexeme(operator), getSyntax(operator)) :: operators
    p := getLeftPrecedence(getSyntax(operator))
    if isThisOperator(operator, "+")
        s := Syntax("(+)", p, p, PREFIX, LEFT, false, shiftPrefix, reducePrefix,
            "")
        ("(+)", s) :: operators'
    if isThisOperator(operator, "-")
        s := Syntax("(-)", p, p, PREFIX, LEFT, false, shiftPrefix, reducePrefix,
            "")
        ("(-)", s) :: operators'
    operators'


define reduceLeftErase(State(stack, operators), operator)
    reduceLeft(State(erase(stack, " "), operators), operator)


define shiftNewline(state, operator)
    state' @ State(stack', operators') := reduceLeftErase(state, operator)
    top := head(stack')
    if isSyntaxDefinition(top)
        definition := defineSyntax(operators', top,
            getDefinee(top), getDefinedValue(top))
        operators'' := addSyntax(operators', getDefinedValue(definition))
        State(operator :: definition :: tail(stack'), operators'')
    if isOperator(top)
        state'
    State(operator :: stack', operators')


define coreAlias(lexeme, alias, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)
    (lexeme, Syntax(alias, leftPrecedence, rightPrecedence, fixity,
        associativity, true, shifter, reducer, ""))


define coreSyntax(lexeme, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)
    coreAlias(lexeme, lexeme, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)


OPERATORS := [
    coreSyntax("\0", 0, 0, CLOSEFIX, RIGHT, shiftClose, reduceEOF),
    coreSyntax("(", 90, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched),
    coreSyntax(")", 0, 90, CLOSEFIX, RIGHT, shiftClose, reduceParentheses),
    coreSyntax("[", 90, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched),
    coreSyntax("]", 0, 90, CLOSEFIX, RIGHT, shiftClose, reduceSquare),
    coreSyntax("{", 90, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched),
    coreSyntax("}", 0, 90, CLOSEFIX, RIGHT, shiftClose, reduceCurly),
    coreSyntax("|", 1, 1, INFIX, NEITHER, shiftInfix, reduceReserved),
    coreSyntax(",", 2, 2, INFIX, LEFT, shiftInfix, reduceCommaPair),
    coreSyntax("\n", 3, 3, INFIX, RIGHTVALUE, shiftNewline, reduceNewline),
    coreSyntax(";", 4, 4, INFIX, RIGHT, shiftInfix, reduceNewline),
    coreSyntax("define", 5, 5, PREFIX, NEITHER, shiftPrefix, reducePrefix),
    coreSyntax(":=", 5, 5, INFIX, NEITHER, shiftInfix, reduceDefine),
    coreAlias("≔", ":=", 5, 5, INFIX, NEITHER, shiftInfix, reduceDefine),
    coreSyntax("::=", 5, 5, INFIX, NEITHER, shiftInfix, reduceADTDefine),
    coreAlias("⩴", "::=", 5, 5, INFIX, NEITHER, shiftInfix, reduceADTDefine),
    # reserve precedence 6 for "try"
    coreSyntax("->", 7, 7, INFIX, RIGHT, shiftInfix, reduceArrow),
    coreAlias("↦", "->", 7, 7, INFIX, RIGHT, shiftInfix, reduceArrow),
    coreSyntax("case", 8, 8, PREFIX, NEITHER, shiftPrefix, reducePrefix),
    coreSyntax("@", 9, 9, INFIX, NEITHER, shiftInfix, reduceAsPattern),
    coreSyntax("syntax", 90, 90, PREFIX, LEFT, shiftPrefix, reducePrefix),
    coreSyntax("error", 90, 90, PREFIX, LEFT, shiftPrefix, reducePrefix),
    coreSyntax("( )", 99, 99, INFIX, LEFT, shiftSpace, reduceInvalid),
    coreSyntax("$", 99, 99, PREFIX, LEFT, shiftPrefix, reduceReserved)
]

#*
