#* syntax.zero

define reduceApply(operator, left, right)
    newApplication(getTag(operator), left, right)


define reduceInfix(operator, left, right)
    reduceApply(operator, reduceApply(operator,
        convertOperator(getTag(operator)), left), right)


define reducePrefix(operator, _left, right)
    reduceApply(operator, convertOperator(getTag(operator)), right)


define reducePostfix(operator, left, _right)
    reduceApply(operator, convertOperator(getTag(operator)), left)


define reduceArrow(operator, left, right)
    if isApplication(left) and isThisLexeme(left, "case")
        newCase(getTag(left), getRight(left), right)
    newPatternLambda(getTag(operator), left, right)


define reduceNewline(operator, left, right)
    tag := getTag(left)
    if isDefinition(left) and isThisLexeme(left, ":=")
        applyDefinition(tag, getLeft(left), getRight(left), right)
    if isDefinition(left) and isThisLexeme(left, "try")
        applyTryDefinition(tag, getLeft(left), getRight(left), right)
    if isDefinition(left) and isThisLexeme(left, "::=")
        applyADTDefinition(tag, getLeft(left), getRight(left), right)
    if isApplication(left) and isThisLexeme(left, "define")
        reduceDefine(getLeft(left), getRight(left), right)
    if isCase(left) and isCase(right)
        combineCases(tag, left, right)
    if isApplication(left) and isThisLexeme(left, "case")
        reduceArrow(operator, left, right)
    reduceApply(operator, left, right)


define shiftPrefix(state, operator)
    state' := reduceLeft(state, operator)
    State(operator :: getStack(state'), getOperators(state'))


define shiftPostfix(state, operator)
    stack := erase(getStack(state), " ")
    state' := reduceLeft(State(stack, getOperators(state)), operator)
    stack' := getStack(state')
    stack'' := if not isSpecial(operator) and isOpenOperator(stack'[0]) then
        newName(renameTag(getTag(operator), ".*")) :: stack' else stack'
    operand := stack''[0]
    if isOperator(operand)
        syntaxError("missing left operand for", operator)
    State(reduceOperator(operator, operand, NULL) :: tail(stack''),
        getOperators(state))


define shiftInfix(state, operator)
    stack := erase(getStack(state), " ")
    state' := reduceLeft(State(stack, getOperators(state)), operator)
    stack' := getStack(state')
    operators := getOperators(state')
    top := head(stack')
    tag := getTag(operator)
    if isOperator(top)
        if isThisSymbol(operator, "+")
            operator' := operators.parseSymbol(renameTag(tag, "(+)"), 0)
            State(operator' :: stack', operators)
        if isThisSymbol(operator, "-")
            operator' := operators.parseSymbol(renameTag(tag, "(-)"), 0)
            State(operator' :: stack', operators)
        if not isSpecial(operator) and isOpenOperator(top)
            State(operator :: renameNode(operator, ".*") :: stack', operators)
        syntaxError("missing left operand for", operator)
    State(operator :: stack', operators)


define shiftSpace(state, operator)
    state' := reduceLeft(state, operator)
    if isOperator(head(getStack(state')))
        state'
    State(operator :: getStack(state'), getOperators(state'))


define reduceReserved(operator, _left, _right)
    syntaxError("reserved operator", operator)


define reduceInvalid(operator, _left, _right)
    syntaxError("operator syntax undeclared", operator)


define reduceError(operator, _left, right)
    tag := getTag(operator)
    if isThisSymbol(right, "[]")
        newBuiltin(renameTag(tag, "(undefined)"))
    newApplication(tag, convertOperator(tag), right)


define newOperator'(tag, precedence, fixity, associativity, shifter, reducer)
    newOperator(tag, 0, Syntax(precedence, precedence, fixity, associativity,
        false, shifter, reducer, ""))


define newSyntaxOperator(tag, precedence, fixity)
    if getTagLexeme(tag) =*= "()"
        if not(getLexeme(fixity) =*= "infixL")
            syntaxError("syntax must be infixL", fixity)
        tag' := renameTag(tag, " ")
        newOperator'(tag', precedence, INFIX, LEFT, shiftSpace, reduceInfix)
    if getLexeme(fixity) =*= "infix"
        newOperator'(tag, precedence, INFIX, NEITHER, shiftInfix, reduceInfix)
    if getLexeme(fixity) =*= "infixL"
        newOperator'(tag, precedence, INFIX, LEFT, shiftInfix, reduceInfix)
    if getLexeme(fixity) =*= "infixR"
        newOperator'(tag, precedence, INFIX, RIGHT, shiftInfix, reduceInfix)
    if getLexeme(fixity) =*= "prefix"
        newOperator'(tag, precedence, PREFIX, LEFT, shiftPrefix, reducePrefix)
    if getLexeme(fixity) =*= "postfix"
        newOperator'(tag, precedence, POSTFIX, LEFT,
            shiftPostfix, reducePostfix)
    syntaxError("invalid fixity", fixity)


define reduceMixfix(operator, left, right)
    prior := getPrior(getSyntax(operator))
    if not isApplication(left) or not getLexeme(left) =*= prior
        syntaxError("mixfix syntax error", operator)
    reduceApply(operator, left, right)


define newMixfixOperator(operators, tag, prior)
    precedence := getRightPrecedence(
        try lookupSyntax(operators, getLexeme(prior)) except
            syntaxError("syntax not defined", prior))
    newOperator(tag, 0, Syntax(precedence, precedence, INFIX, LEFT, true,
        shiftInfix, reduceMixfix, getLexeme(prior)))


define defineSyntax(operators, node, left, right)
    if not isApplication(left)
        syntaxError("invalid left operand", left)
    name := getRight(left)
    if not isSymbol(name)
        syntaxError("expected symbol operand to", getLeft(left))
    if getLexeme(name).any(= '_')
        syntaxError("invalid underscore in operator name", name)
    if not isApplication(right)
        syntaxError("invalid syntax definition", node)
    fixity := getLeft(right)
    if isThisSymbol(fixity, "mixfix")
        operator := newMixfixOperator(operators, getTag(name), getRight(right))
        newLambda(getTag(left), operator, operator)
    if not isNatural(getRight(right))
        syntaxError("invalid syntax definition", node)
    precedence := getValue(getRight(right))
    if precedence < 0 or precedence > 99
        syntaxError("invalid precedence", getRight(right))
    operator := newSyntaxOperator(getTag(name), precedence, fixity)
    newLambda(getTag(left), operator, operator)


define addSyntax(operators, operator)
    if operators.map(first).any(=*= getLexeme(operator))
        syntaxError("syntax already defined", operator)
    operators' := (getLexeme(operator), getSyntax(operator)) :: operators
    p := getLeftPrecedence(getSyntax(operator))
    if isThisSymbol(operator, "+")
        s := Syntax(p, p, PREFIX, LEFT, false, shiftPrefix, reducePrefix, "")
        ("(+)", s) :: operators'
    if isThisSymbol(operator, "-")
        s := Syntax(p, p, PREFIX, LEFT, false, shiftPrefix, reducePrefix, "")
        ("(-)", s) :: operators'
    operators'


define reduceLeftErase(State(stack, operators), operator)
    reduceLeft(State(erase(stack, " "), operators), operator)


define shiftNewline(state, operator)
    state' @ State(stack', operators') := reduceLeftErase(state, operator)
    top := head(stack')
    if isDefinition(top) and isThisLexeme(getLeft(top), "syntax")
        marker := defineSyntax(operators', top, getLeft(top), getRight(top))
        operators'' := addSyntax(operators', getParameter(marker))
        State(operator :: marker :: tail(stack'), operators'')
    if isOperator(top)
        state'
    State(operator :: stack', operators')


define reduceTry(operator, _left, right)
    reduceApply(operator, newName(renameTag(getTag(operator), "??")), right)


define coreSyntax(leftPrecedence, rightPrecedence, fixity, associativity,
        shifter, reducer)
    Syntax(leftPrecedence, rightPrecedence, fixity, associativity, true,
        shifter, reducer, "")


OPERATORS := [
    ("\0", coreSyntax(0, 0, CLOSEFIX, RIGHT, shiftClose, reduceEOF)),
    ("(", coreSyntax(90, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched)),
    (")", coreSyntax(0, 90, CLOSEFIX, RIGHT, shiftClose, reduceParentheses)),
    ("[", coreSyntax(90, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched)),
    ("]", coreSyntax(0, 90, CLOSEFIX, RIGHT, shiftClose, reduceSquare)),
    ("{", coreSyntax(90, 0, OPENFIX, RIGHT, shiftOpenCurly, reduceUnmatched)),
    ("}", coreSyntax(0, 90, CLOSEFIX, RIGHT, shiftClose, reduceCurly)),
    ("|", coreSyntax(1, 1, INFIX, NEITHER, shiftInfix, reduceReserved)),
    (",", coreSyntax(2, 2, INFIX, LEFT, shiftInfix, reduceApply)),
    ("\n", coreSyntax(3, 3, INFIX, RIGHTVALUE, shiftNewline, reduceNewline)),
    (";", coreSyntax(4, 4, INFIX, RIGHT, shiftInfix, reduceNewline)),
    ("define", coreSyntax(5, 5, PREFIX, NEITHER, shiftPrefix, reducePrefix)),
    (":=", coreSyntax(5, 5, INFIX, NEITHER, shiftInfix, reduceDefine)),
    ("≔", coreSyntax(5, 5, INFIX, NEITHER, shiftInfix, reduceDefine)),
    ("::=", coreSyntax(5, 5, INFIX, NEITHER, shiftInfix, reduceADT)),
    ("⩴", coreSyntax(5, 5, INFIX, NEITHER, shiftInfix, reduceADT)),
    ("->", coreSyntax(6, 6, INFIX, RIGHT, shiftInfix, reduceArrow)),
    ("↦", coreSyntax(6, 6, INFIX, RIGHT, shiftInfix, reduceArrow)),
    ("case", coreSyntax(7, 7, PREFIX, NEITHER, shiftPrefix, reducePrefix)),
    ("try", coreSyntax(7, 7, PREFIX, LEFT, shiftPrefix, reduceTry)),
    ("@", coreSyntax(8, 8, INFIX, NEITHER, shiftInfix, reduceApply)),
    ("syntax", coreSyntax(90, 90, PREFIX, LEFT, shiftPrefix, reducePrefix)),
    ("error", coreSyntax(90, 90, PREFIX, LEFT, shiftPrefix, reduceError)),
    ("( )", coreSyntax(99, 99, INFIX, LEFT, shiftSpace, reduceInvalid)),
    ("$", coreSyntax(99, 99, PREFIX, LEFT, shiftPrefix, reduceReserved))
]

#*
