#* syntax.zero

define reduceApply(operator, left, right)
    Juxtaposition(getTag(operator), left, right)


define isValidPrior(operator, node)
    prior := getPrior(getSyntax(operator))
    isNil(prior) or (isJuxtaposition(node) and getLexeme(node) =*= prior)


define reduceInfix(operator, left, right)
    reduceApply(operator, reduceApply(operator,
        OperatorName(getTag(operator), INFIX), left), right)


define reduceInfixL(operator, left, right)
    if not isValidPrior(operator, left)
        syntaxError("operator syntax error", operator)
    reduceInfix(operator, left, right)


define reduceInfixR(operator, left, right)
    if not isValidPrior(operator, right)
        syntaxError("operator syntax error", operator)
    reduceInfix(operator, left, right)


define reducePrefix(operator, _left, right)
    if not isValidPrior(operator, right)
        syntaxError("operator syntax error", operator)
    reduceApply(operator, OperatorName(getTag(operator), PREFIX), right)


define reducePostfix(operator, left, _right)
    if not isValidPrior(operator, left)
        syntaxError("operator syntax error", operator)
    reduceApply(operator, OperatorName(getTag(operator), POSTFIX), left)


define reduceArrow(operator, left, right)
    newStrictArrow(getTag(operator), left, right)


define reduceNewline(operator, left, right)
    if isDefinition(left)
        applyDefinition(left, right)
    if isKeyphrase(left, "define")
        reduceDefine(getLeft(left), getRight(left), right)
    if isCase(left) and isCase(right)
        combineCases(getTag(operator), left, right)
    if isKeyphrase(left, "case")
        reduceArrow(operator, getRight(left), right)
    reduceApply(operator, left, right)


define reduceInterfix(operator, left, right)
    if not isValidPrior(operator, left)
        syntaxError("operator syntax error", operator)
    reduceNewline(operator, left, right)


define reducePipeline(operator, left, right)
    reduceApply(operator, right, left)


define reduceAsPattern(operator, left, right)
    if not isName(left)
        syntaxError("expected name to left of", operator)
    AsPattern(getTag(operator), left, right)


define reduceCommaPair(operator, left, right)
    CommaPair(getTag(operator), left, right)


define reduceWhere(operator, left, right)
    if not isDefinition(right)
        syntaxError("expected definition to right of", operator)
    applyDefinition(right, left)


define shiftPrefix(state, operator)
    state' := reduceLeft(state, operator)
    State(operator :: getStack(state'), getOperators(state'))


define shiftPostfix(state, operator)
    stack := erase(getStack(state), " ")
    state' := reduceLeft(State(stack, getOperators(state)), operator)
    stack' := getStack(state')
    if not isSpecial(operator) and isOpenOperator(head(stack'))
        placeholder := newLeftPlaceholder(getTag(head(stack')))
        body := reduceOperator(operator, placeholder, Null(getTag(placeholder)))
        State(body :: stack', getOperators(state))
    operand := stack'[0]
    if isOperator(operand)
        syntaxError("missing left operand for", operator)
    reduced := reduceOperator(operator, operand, Null(getTag(operator)))
    State(reduced :: tail(stack'), getOperators(state))


define shiftInfix(state, operator)
    stack := erase(getStack(state), " ")
    state' := reduceLeft(State(stack, getOperators(state)), operator)
    stack' := getStack(state')
    operators := getOperators(state')
    top := head(stack')
    tag := getTag(operator)
    if isOperator(top)
        if isThisOperator(operator, "+")
            operator' := operators.parseSymbol(renameTag(tag, "(+)"), 0)
            State(operator' :: stack', operators)
        if isThisOperator(operator, "-")
            operator' := operators.parseSymbol(renameTag(tag, "(-)"), 0)
            State(operator' :: stack', operators)
        if not isSpecial(operator) and isOpenOperator(top)
            placeholder := newLeftPlaceholder(tag)
            State(operator :: placeholder :: stack', operators)
        syntaxError("missing left operand for", operator)
    State(operator :: stack', operators)


define shiftSpace(state, operator)
    state' := reduceLeft(state, operator)
    if isOperator(head(getStack(state')))
        state'
    State(operator :: getStack(state'), getOperators(state'))


define reduceReserved(operator, _left, _right)
    syntaxError("reserved operator", operator)


define reduceInvalid(operator, _left, _right)
    syntaxError("missing operator", operator)


define newOperator'(tag, prior, precedence, fixity, associativity,
        shifter, reducer)
    special := not isNil(prior)
    if special and associativity = NEITHER
        parseError("expected numeric precedence", tag)
    Operator(tag, 0, Syntax(getTagLexeme(tag), precedence, precedence, fixity,
        associativity, special, shifter, reducer, prior))


define newSyntaxOperator(tag, precedence, fixity, prior)
    p := precedence
    if getTagLexeme(tag) =*= "()"
        tag' := renameTag(tag, " ")
        if getLexeme(fixity) =*= "infixL"
            newOperator'(tag', prior, p, INFIX, LEFT, shiftSpace, reduceInfixL)
        if getLexeme(fixity) =*= "interfix"
            newOperator'(tag', prior, p, INFIX, LEFT,
                shiftSpace, reduceInterfix)
        syntaxError("syntax must be infixL or interfix", fixity)
    if getLexeme(fixity) =*= "infix"
        newOperator'(tag, prior, p, INFIX, NEITHER, shiftInfix, reduceInfix)
    if getLexeme(fixity) =*= "infixL"
        newOperator'(tag, prior, p, INFIX, LEFT, shiftInfix, reduceInfixL)
    if getLexeme(fixity) =*= "infixR"
        newOperator'(tag, prior, p, INFIX, RIGHT, shiftInfix, reduceInfixR)
    if getLexeme(fixity) =*= "interfix"
        newOperator'(tag, prior, p, INFIX, LEFT, shiftInfix, reduceInterfix)
    if getLexeme(fixity) =*= "prefix"
        newOperator'(tag, prior, p, PREFIX, LEFT, shiftPrefix, reducePrefix)
    if getLexeme(fixity) =*= "postfix"
        newOperator'(tag, prior, p, POSTFIX, LEFT, shiftPostfix, reducePostfix)
    syntaxError("invalid fixity", fixity)


define newAlias(operators, tag, name)
    if not isName(name)
        syntaxError("expected operator name", name)
    rules := head(operators).lookup(getLexeme(name)) ??
        syntaxError("syntax not defined", name)
    Operator(tag, 0, rules)


define copySyntax(operators, tag, name)
    lexeme := getTagLexeme(tag)
    match getSyntax(newAlias(operators, tag, name))
        Syntax(_, l, r, f, a, s, sh, rd, p) ->
            Operator(tag, 0, Syntax(lexeme, l, r, f, a, s, sh, rd, p))


define findPrecedence(operators, node)
    syntax := head(operators).lookup(getLexeme(node)) ??
        syntaxError("syntax not defined", node)
    if getLeftPrecedence(syntax) =/= getRightPrecedence(syntax)
        syntaxError("operator not supported", node)
    getLeftPrecedence(syntax)


define parsePrecedence(operators, node)
    precedence := if isNumber(node) then
        getNumericValue(node) else findPrecedence(operators, node)
    if precedence > 99
        syntaxError("invalid precedence", node)
    precedence


define defineSyntax(operators, node, name, right)
    tag := getTag(node)
    if not isName(name)
        syntaxError("expected name operand to", node)
    if not isJuxtaposition(right)
        syntaxError("invalid syntax definition", node)
    fixity := getLeft(right)
    if isThisName(fixity, "alias")
        operator := newAlias(operators, getTag(name), getRight(right))
        Definition(tag, SyntaxDefinition, name, operator)
    if isThisName(fixity, "syntax")
        operator := copySyntax(operators, getTag(name), getRight(right))
        Definition(tag, SyntaxDefinition, name, operator)
    argument := getRight(right)
    precedence := parsePrecedence(operators, argument)
    prior := if isNumber(argument) then "" else getLexeme(argument)
    operator := newSyntaxOperator(getTag(name), precedence, fixity, prior)
    Definition(tag, SyntaxDefinition, name, operator)


define addSyntax(operators, operator)
    if head(operators).hasKey(getLexeme(operator))
        syntaxError("syntax already defined", operator)
    dictionary' := head(operators).set(getLexeme(operator), getSyntax(operator))
    operators' :=  dictionary' :: operators
    p := getLeftPrecedence(getSyntax(operator))
    if isThisOperator(operator, "+")
        s := Syntax("(+)", p, p, PREFIX, LEFT, false, shiftPrefix, reducePrefix,
            "")
        head(operators').set("(+)", s) :: operators'
    if isThisOperator(operator, "-")
        s := Syntax("(-)", p, p, PREFIX, LEFT, false, shiftPrefix, reducePrefix,
            "")
        head(operators').set("(-)", s) :: operators'
    operators'


define reduceLeftErase(State(stack, operators), operator)
    reduceLeft(State(erase(stack, " "), operators), operator)


define shiftNewline(state, operator)
    state' @ State(stack', operators') := reduceLeftErase(state, operator)
    top := head(stack')
    if isSyntaxDefinition(top)
        definition := defineSyntax(operators', top,
            getDefiniendum(top), getDefiniens(top))
        operators'' := addSyntax(operators', getDefiniens(definition))
        State(operator :: definition :: tail(stack'), operators'')
    if isOperator(top)
        state'
    State(operator :: stack', operators')


define coreAlias(lexeme, alias, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)
    (lexeme, Syntax(alias, leftPrecedence, rightPrecedence, fixity,
        associativity, true, shifter, reducer, ""))


define coreSyntax(lexeme, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)
    coreAlias(lexeme, lexeme, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)


OPERATORS := [newDictionary([
    coreSyntax("\0", 0, 0, CLOSEFIX, RIGHT, shiftClose, reduceEOF),
    coreSyntax("(", 95, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched),
    coreSyntax(")", 0, 95, CLOSEFIX, RIGHT, shiftClose, reduceParentheses),
    coreSyntax("[", 95, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched),
    coreSyntax("]", 0, 95, CLOSEFIX, RIGHT, shiftClose, reduceSquare),
    coreSyntax("{", 95, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched),
    coreSyntax("}", 0, 95, CLOSEFIX, RIGHT, shiftClose, reduceCurly),
    coreSyntax("|", 1, 1, INFIX, NEITHER, shiftInfix, reduceReserved),
    coreSyntax(",", 2, 2, INFIX, LEFT, shiftInfix, reduceCommaPair),
    coreSyntax("\n", 3, 3, INFIX, RIGHTVALUE, shiftNewline, reduceNewline),
    coreSyntax(";;", 4, 4, INFIX, RIGHT, shiftInfix, reduceNewline),
    coreSyntax("define", 5, 5, PREFIX, LEFT, shiftPrefix, reducePrefix),
    coreSyntax(":=", 5, 5, INFIX, RIGHT, shiftInfix, reduceDefine),
    coreAlias("≔", ":=", 5, 5, INFIX, RIGHT, shiftInfix, reduceDefine),
    coreSyntax("::=", 5, 5, INFIX, RIGHT, shiftInfix, reduceADTDefine),
    coreAlias("⩴", "::=", 5, 5, INFIX, RIGHT, shiftInfix, reduceADTDefine),
    coreSyntax("where", 5, 5, INFIX, RIGHT, shiftInfix, reduceWhere),
    coreSyntax("|>", 6, 6, INFIX, LEFT, shiftInfix, reducePipeline),
    coreAlias("⦊", "|>", 6, 6, INFIX, LEFT, shiftInfix, reducePipeline),
    coreSyntax("<|", 6, 6, INFIX, RIGHT, shiftInfix, reduceApply),
    coreAlias("⦉","<|", 6, 6, INFIX, RIGHT, shiftInfix, reduceApply),
    coreSyntax(";", 8, 8, INFIX, RIGHT, shiftInfix, reduceNewline),
    coreSyntax("->", 9, 9, INFIX, RIGHT, shiftInfix, reduceArrow),
    coreAlias("↦", "->", 9, 9, INFIX, RIGHT, shiftInfix, reduceArrow),
    coreSyntax("=>", 9, 9, INFIX, RIGHT, shiftInfix, reduceInfix),
    coreAlias("⇒", "=>", 9, 9, INFIX, RIGHT, shiftInfix, reduceInfix),
    coreSyntax("case", 10, 10, PREFIX, NEITHER, shiftPrefix, reducePrefix),
    coreSyntax("@", 12, 12, INFIX, NEITHER, shiftInfix, reduceAsPattern),
    coreSyntax("abort", 15, 15, PREFIX, LEFT, shiftPrefix, reducePrefix),
    coreSyntax(".", 97, 97, INFIX, LEFT, shiftInfix, reducePipeline),
    coreSyntax("( )", 99, 99, INFIX, LEFT, shiftSpace, reduceInvalid),
    coreSyntax("$", 99, 99, PREFIX, LEFT, shiftPrefix, reduceReserved)
])]

#*
