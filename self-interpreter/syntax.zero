#* syntax.zero

define isOperatorTop(stack)
    stack |> [] -> True; top :: _ -> isOperator(top)


define isValidPrior(operator, node)
    with operator as Operator(_, _, syntax')
        prior := getPrior(syntax')
        isNil(prior) or (isJuxtaposition(node) and getLexeme(node) =*= prior)
    False


define reduceApply(operator, left, right)
    Juxtaposition(getTag(operator), left, right)


define reducePrefix(operator, _left, right)
    if not isValidPrior(operator, right)
        syntaxError("operator syntax error", operator)
    reduceApply(operator, Name(getTag(operator)), right)


define reducePostfix(operator, left, _right)
    if not isValidPrior(operator, left)
        syntaxError("operator syntax error", operator)
    reduceApply(operator, Name(getTag(operator)), left)


define reduceInfix(operator, left, right)
    reduceApply(operator, reduceApply(operator,
        Name(getTag(operator)), left), right)


define reduceInfixL(operator, left, right)
    if not isValidPrior(operator, left)
        syntaxError("operator syntax error", operator)
    reduceInfix(operator, left, right)


define reduceInfixR(operator, left, right)
    if not isValidPrior(operator, right)
        syntaxError("operator syntax error", operator)
    reduceInfix(operator, left, right)


define reduceArrow(operator, left, right)
    if isName(left)
        SimpleArrow(left, right)  # might be a case or might not be a case
    if isColonPair(left)
        newPatternArrow(left, right)
    newCaseArrow(left, right)


define reduceDoubleArrow(operator, left, right)
    Arrow(getTag(operator), Double, [], left, Null(noTag), right)


define reducePipeline(operator, left, right)
    reduceApply(operator, right, left)


define reduceCommaPair(operator, left, right)
    CommaPair(getTag(operator), left, right)


define reduceColonPair(operator, left, right)
    if isColonPair(left) or not isValidPattern(left)
        syntaxError("invalid left side of colon", left)
    if isColonPair(right) or not isValidPattern(right)
        syntaxError("invalid right side of colon", right)
    ColonPair(getTag(operator), left, right)


define reduceAsPattern(operator, left, right)
    AsPattern(getTag(operator), left, right)


define reduceWhere(operator, left, right)
    if not isDefinition(right)
        syntaxError("expected definition to right of", operator)
    applyDefinition(right, left)


define reduceWith(operator, asPattern, withBlock)
    with asPattern as AsPattern(_, expression, pattern)
        tag := getTag(operator)
        elseBlock := Underscore(tag, 3)
        caseArrow := newCaseArrow(pattern, withBlock)
        fallback := SimpleArrow(Underscore(tag, 0), elseBlock)
        function := combineCases(tag, caseArrow, fallback)
        LockedArrow(Name(renameTag(tag, "pass", NOFIX)),
            Juxtaposition(tag, function, expression))
    syntaxError("expected as pattern to right of", operator)


define reduceNewline(operator, left, right)
    with left as Juxtaposition(_, left', right')
        if isThisName(left', "define")
            reduceDefine(left', right', right)
        if isThisName(left', "case")
            newCaseArrow(right', right)
        if isThisName(left', "with")
            reduceWith(left', right', right)
        reduceApply(operator, left, right)
    if isDefinition(left)
        applyDefinition(left, right)
    if isCase(left) and isCase(right)
        combineCases(getTag(operator), left, right)
    reduceApply(operator, left, right)


define reduceInterfix(operator, left, right)
    if not isValidPrior(operator, left)
        syntaxError("operator syntax error", operator)
    reduceNewline(operator, left, right)


define reduceInvalid(operator, _left, _right)
    syntaxError("missing operator", operator)


define reduceReserved(operator, _left, _right)
    syntaxError("reserved operator", operator)


define shiftPrefix(state, operator)
    state' := reduceLeft(state, operator)
    State(operator :: getStack(state'), getOperators(state'))


define shiftPostfix(state, operator)
    stack := getStack(state)
    state' := reduceLeft(State(stack, getOperators(state)), operator)
    stack' := getStack(state')
    with stack' as operand :: stack''
        if not isSpecial(operator) and isOpenOperator(operand)
            placeholder := newLeftPlaceholder(getTag(operand))
            null := Null(getTag(placeholder))
            body := reduceOperator(operator, placeholder, null)
            State(body :: stack', getOperators(state))
        if isOperator(operand)
            syntaxError("missing left operand for", operator)
        reduced := reduceOperator(operator, operand, Null(getTag(operator)))
        State(reduced :: stack'', getOperators(state))
    syntaxError("missing left operand for", operator)


define shiftInfix(state, operator)
    stack := getStack(state)
    state' := reduceLeft(State(stack, getOperators(state)), operator)
    stack' := getStack(state')
    with stack' as top :: _
        tag := getTag(operator)
        operators := getOperators(state')
        if not isOperator(top)
            State(operator :: stack', operators)
        if isThisOperator(operator, "+")
            operator' := operators.parseSymbol(renameTag(tag, "(+)", PREFIX), 0)
            State(operator' :: stack', operators)
        if isThisOperator(operator, "-")
            operator' := operators.parseSymbol(renameTag(tag, "(-)", PREFIX), 0)
            State(operator' :: stack', operators)
        if not isSpecial(operator) and isOpenOperator(top)
            placeholder := newLeftPlaceholder(tag)
            State(operator :: placeholder :: stack', operators)
        syntaxError("missing left operand for", operator)
    syntaxError("missing left operand for", operator)


define newOperator'(tag, prior, precedence, fixity, associativity,
        shifter, reducer)
    special := not isNil(prior)
    if special and associativity = NEITHER
        parseError("expected numeric precedence", tag)
    Operator(tag, 0, Syntax(getTagLexeme(tag), precedence, precedence, fixity,
        associativity, special, shifter, reducer, prior))


define newSyntaxOperator(tag, precedence, fixity, prior)
    p := precedence
    if getLexeme(fixity) =*= "infix"
        newOperator'(tag, prior, p, INFIX, NEITHER, shiftInfix, reduceInfix)
    if getLexeme(fixity) =*= "infixL"
        newOperator'(tag, prior, p, INFIX, LEFT, shiftInfix, reduceInfixL)
    if getLexeme(fixity) =*= "infixR"
        newOperator'(tag, prior, p, INFIX, RIGHT, shiftInfix, reduceInfixR)
    if getLexeme(fixity) =*= "interfix"
        newOperator'(tag, prior, p, INFIX, LEFT, shiftInfix, reduceInterfix)
    if getLexeme(fixity) =*= "prefix"
        newOperator'(tag, prior, p, PREFIX, LEFT, shiftPrefix, reducePrefix)
    if getLexeme(fixity) =*= "postfix"
        newOperator'(tag, prior, p, POSTFIX, LEFT, shiftPostfix, reducePostfix)
    syntaxError("invalid fixity", fixity)


define getAliasSyntax(operators, name)
    if not isName(name)
        syntaxError("expected operator name", name)
    operators.lookupSyntax(getLexeme(name)) ??
        syntaxError("syntax not defined", name)


define newAlias(operators, tag, name)
    Operator(tag, 0, getAliasSyntax(operators, name))


define copySyntax(operators, tag, name)
    lexeme := getTagLexeme(tag)
    match getAliasSyntax(operators, name)
        Syntax(_, l, r, f, a, s, sh, rd, p) ->
            Operator(tag, 0, Syntax(lexeme, l, r, f, a, s, sh, rd, p))


define findPrecedence(operators, node)
    syntax' := operators.lookupSyntax(getLexeme(node)) ??
        syntaxError("syntax not defined", node)
    if getLeftPrecedence(syntax') =/= getRightPrecedence(syntax')
        syntaxError("operator not supported", node)
    getLeftPrecedence(syntax')


define parsePrecedence(operators, node)
    with node as Number(_, precedence)
        if precedence > 99
            syntaxError("invalid precedence", node)
        precedence
    findPrecedence(operators, node)


define defineSyntax(operators, definition, name, right)
    tag := getTag(definition)
    if not isName(name)
        syntaxError("expected name operand to", definition)
    with right as Juxtaposition(_, fixity, argument)
        if isThisName(fixity, "alias")
            newAlias(operators, getTag(name), argument)
        if isThisName(fixity, "syntax")
            copySyntax(operators, getTag(name), argument)
        precedence := parsePrecedence(operators, argument)
        prior := if isNumber(argument) then "" else getLexeme(argument)
        newSyntaxOperator(getTag(name), precedence, fixity, prior)
    syntaxError("invalid syntax definition", definition)


define pushSyntax(lexeme, syntax', operators)
    with operators as top :: _
        top.insert(lexeme, syntax') :: operators
    [newDictionary([(lexeme, syntax')])]


define addSyntax(operators, operator)
    if not isVoid(operators.lookupSyntax(getLexeme(operator)))
        syntaxError("syntax already defined", operator)
    with operator as Operator(_, _, syntax')
        operators' := operators.pushSyntax(getLexeme(operator), syntax')
        p := getLeftPrecedence(syntax')
        if isThisOperator(operator, "+")
            s := Syntax("(+)", p, p, PREFIX, LEFT, False,
                shiftPrefix, reducePrefix, "")
            operators'.pushSyntax("(+)", s)
        if isThisOperator(operator, "-")
            s := Syntax("(-)", p, p, PREFIX, LEFT, False,
                shiftPrefix, reducePrefix, "")
            operators'.pushSyntax("(-)", s)
        operators'
    syntaxError("internal error", operator)


define reduceLeftErase(State(stack, operators), operator)
    reduceLeft(State(stack, operators), operator)


define shiftSemicolon(state, operator)
    _ @ State(stack', operators') := reduceLeftErase(state, operator)
    with stack' as top :: stack''
        with top as Operator(_, _, _)
            syntaxError("missing left operand for", operator)
        with top as Definition(tag, type, definiendum, definiens)
            with type as SyntaxDefinition
                operator' := defineSyntax(operators', top,
                    definiendum, definiens)
                operators'' := addSyntax(operators', operator')
                definition := Definition(tag, type, definiendum, operator')
                State(operator :: definition :: stack'', operators'')
            State(operator :: stack', operators')
        State(operator :: stack', operators')
    syntaxError("missing left operand for", operator)


define shiftNewline(state @ State(stack, operators), operator)
    # ignore newlines after operators for line continuations
    if isOperatorTop(stack)
        State(stack, operators)
    if getRank(operator) % 2 =/= 0
        syntaxError("odd-width indent after", operator)
    shiftSemicolon(state, operator)


define coreAlias(lexeme, aliasName, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)
    (lexeme, Syntax(aliasName, leftPrecedence, rightPrecedence, fixity,
        associativity, True, shifter, reducer, ""))


define coreSyntax(lexeme, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)
    coreAlias(lexeme, lexeme, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)


OPERATORS := [newDictionary([
    coreSyntax("\0", 0, 0, CLOSEFIX, RIGHT, shiftClose, reduceEOF),
    coreSyntax("(", 95, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched),
    coreSyntax(")", 0, 95, CLOSEFIX, RIGHT, shiftClose, reduceParentheses),
    coreSyntax("[", 95, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched),
    coreSyntax("]", 0, 95, CLOSEFIX, RIGHT, shiftClose, reduceSquare),
    coreSyntax("{", 95, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched),
    coreSyntax("}", 0, 95, CLOSEFIX, RIGHT, shiftClose, reduceCurly),
    coreSyntax("|", 1, 1, INFIX, NEITHER, shiftInfix, reduceReserved),
    coreSyntax(",", 2, 2, INFIX, LEFT, shiftInfix, reduceCommaPair),
    coreSyntax("\n", 3, 3, INFIX, RIGHTVALUE, shiftNewline, reduceNewline),
    coreSyntax(";;", 4, 4, INFIX, RIGHT, shiftSemicolon, reduceNewline),
    coreSyntax("define", 5, 5, PREFIX, LEFT, shiftPrefix, reducePrefix),
    coreSyntax(":=", 5, 5, INFIX, RIGHT, shiftInfix, reduceDefine),
    coreAlias("≔", ":=", 5, 5, INFIX, RIGHT, shiftInfix, reduceDefine),
    coreSyntax("::=", 5, 5, INFIX, RIGHT, shiftInfix, reduceADTDefine),
    coreAlias("⩴", "::=", 5, 5, INFIX, RIGHT, shiftInfix, reduceADTDefine),
    coreSyntax("where", 5, 5, INFIX, RIGHT, shiftInfix, reduceWhere),
    coreSyntax("|>", 6, 6, INFIX, LEFT, shiftInfix, reducePipeline),
    coreAlias("⦊", "|>", 6, 6, INFIX, LEFT, shiftInfix, reducePipeline),
    coreSyntax("<|", 6, 6, INFIX, RIGHT, shiftInfix, reduceApply),
    coreAlias("⦉","<|", 6, 6, INFIX, RIGHT, shiftInfix, reduceApply),
    coreSyntax(";", 8, 8, INFIX, RIGHT, shiftSemicolon, reduceNewline),
    coreSyntax(":", 9, 9, INFIX, NEITHER, shiftInfix, reduceColonPair),
    coreAlias("∈", ":", 9, 9, INFIX, NEITHER, shiftInfix, reduceColonPair),
    coreSyntax("->", 10, 10, INFIX, RIGHT, shiftInfix, reduceArrow),
    coreAlias("↦", "->", 10, 10, INFIX, RIGHT, shiftInfix, reduceArrow),
    coreSyntax("=>", 10, 10, INFIX, RIGHT, shiftInfix, reduceDoubleArrow),
    coreAlias("⇒", "=>", 10, 10, INFIX, RIGHT, shiftInfix, reduceDoubleArrow),
    coreSyntax("case", 11, 11, PREFIX, NEITHER, shiftPrefix, reducePrefix),
    coreSyntax("with", 11, 11, PREFIX, NEITHER, shiftPrefix, reducePrefix),
    coreSyntax("@", 12, 12, INFIX, NEITHER, shiftInfix, reduceAsPattern),
    coreSyntax("as", 12, 12, INFIX, NEITHER, shiftInfix, reduceAsPattern),
    coreSyntax("abort", 15, 15, PREFIX, LEFT, shiftPrefix, reducePrefix),
    coreSyntax(".", 92, 92, INFIX, LEFT, shiftInfix, reducePipeline),
    coreSyntax("$", 99, 99, PREFIX, LEFT, shiftPrefix, reduceReserved)
])]

#*
