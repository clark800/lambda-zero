#* syntax.zero

define reduceApply(operator, left, right)
    Juxtaposition(getTag(operator), left, right)


define isValidPrior(operator, node)
    prior := getPrior(getSyntax(operator))
    isNil(prior) or (isJuxtaposition(node) and getLexeme(node) =*= prior)


define isValidInfixPrior(operator, left, right)
    syntax := getSyntax(operator)
    prior := getPrior(syntax)
    if isNil(prior)
        true
    associativity := getAssociativity(syntax)
    node := if associativity = LEFT then left else right
    isJuxtaposition(node) and getLexeme(node) =*= prior


define reduceInfix(operator, left, right)
    if not isValidInfixPrior(operator, left, right)
        syntaxError("operator syntax error", operator)
    reduceApply(operator, reduceApply(operator,
        OperatorName(getTag(operator), INFIX), left), right)


define reducePrefix(operator, _left, right)
    if not isValidPrior(operator, right)
        syntaxError("operator syntax error", operator)
    reduceApply(operator, OperatorName(getTag(operator), PREFIX), right)


define reducePostfix(operator, left, _right)
    if not isValidPrior(operator, left)
        syntaxError("operator syntax error", operator)
    reduceApply(operator, OperatorName(getTag(operator), POSTFIX), left)


define reduceArrow(operator, left, right)
    newStrictArrow(getTag(operator), left, right)


define reduceNewline(operator, left, right)
    if isDefinition(left)
        applyDefinition(left, right)
    if isKeyphrase(left, "define")
        reduceDefine(getLeft(left), getRight(left), right)
    if isCase(left) and isCase(right)
        combineCases(getTag(operator), left, right)
    if isKeyphrase(left, "case")
        reduceArrow(operator, getRight(left), right)
    reduceApply(operator, left, right)


define reduceAffix(operator, left, right)
    if not isValidInfixPrior(operator, left, right)
        syntaxError("operator syntax error", operator)
    reduceNewline(operator, left, right)


define reducePipeline(operator, left, right)
    reduceApply(operator, right, left)


define reduceAsPattern(operator, left, right)
    if not isName(left)
        syntaxError("expected name to left of", operator)
    AsPattern(getTag(operator), left, right)


define reduceCommaPair(operator, left, right)
    CommaPair(getTag(operator), left, right)


define reduceWhere(operator, left, right)
    if not isDefinition(right)
        syntaxError("expected definition to right of", operator)
    applyDefinition(right, left)


define shiftPrefix(state, operator)
    state' := reduceLeft(state, operator)
    State(operator :: getStack(state'), getOperators(state'))


define shiftPostfix(state, operator)
    stack := erase(getStack(state), " ")
    state' := reduceLeft(State(stack, getOperators(state)), operator)
    stack' := getStack(state')
    if not isSpecial(operator) and isOpenOperator(head(stack'))
        placeholder := newLeftPlaceholder(getTag(head(stack')))
        body := reduceOperator(operator, placeholder, Null(getTag(placeholder)))
        State(body :: stack', getOperators(state))
    operand := stack'[0]
    if isOperator(operand)
        syntaxError("missing left operand for", operator)
    reduced := reduceOperator(operator, operand, Null(getTag(operator)))
    State(reduced :: tail(stack'), getOperators(state))


define shiftInfix(state, operator)
    stack := erase(getStack(state), " ")
    state' := reduceLeft(State(stack, getOperators(state)), operator)
    stack' := getStack(state')
    operators := getOperators(state')
    top := head(stack')
    tag := getTag(operator)
    if isOperator(top)
        if isThisOperator(operator, "+")
            operator' := operators.parseSymbol(renameTag(tag, "(+)"), 0)
            State(operator' :: stack', operators)
        if isThisOperator(operator, "-")
            operator' := operators.parseSymbol(renameTag(tag, "(-)"), 0)
            State(operator' :: stack', operators)
        if not isSpecial(operator) and isOpenOperator(top)
            placeholder := newLeftPlaceholder(tag)
            State(operator :: placeholder :: stack', operators)
        syntaxError("missing left operand for", operator)
    State(operator :: stack', operators)


define shiftSpace(state, operator)
    state' := reduceLeft(state, operator)
    if isOperator(head(getStack(state')))
        state'
    State(operator :: getStack(state'), getOperators(state'))


define reduceReserved(operator, _left, _right)
    syntaxError("reserved operator", operator)


define reduceInvalid(operator, _left, _right)
    syntaxError("operator syntax undeclared", operator)


define newOperator'(tag, prior, precedence, fixity, associativity,
        shifter, reducer)
    special := not isNil(prior)
    Operator(tag, 0, Syntax(getTagLexeme(tag), precedence, precedence, fixity,
        associativity, special, shifter, reducer, prior))


define newSyntaxOperator(tag, precedence, fixity, prior)
    p := precedence
    if getTagLexeme(tag) =*= "()"
        tag' := renameTag(tag, " ")
        if getLexeme(fixity) =*= "infixL"
            newOperator'(tag', prior, p, INFIX, LEFT, shiftSpace, reduceInfix)
        if getLexeme(fixity) =*= "affix"
            newOperator'(tag', prior, p, INFIX, LEFT, shiftSpace, reduceAffix)
        syntaxError("syntax must be infixL or affix", fixity)
    if getLexeme(fixity) =*= "infix"
        newOperator'(tag, prior, p, INFIX, NEITHER, shiftInfix, reduceInfix)
    if getLexeme(fixity) =*= "infixL"
        newOperator'(tag, prior, p, INFIX, LEFT, shiftInfix, reduceInfix)
    if getLexeme(fixity) =*= "infixR"
        newOperator'(tag, prior, p, INFIX, RIGHT, shiftInfix, reduceInfix)
    if getLexeme(fixity) =*= "affix"
        newOperator'(tag, prior, p, INFIX, LEFT, shiftInfix, reduceAffix)
    if getLexeme(fixity) =*= "prefix"
        newOperator'(tag, prior, p, PREFIX, LEFT, shiftPrefix, reducePrefix)
    if getLexeme(fixity) =*= "postfix"
        newOperator'(tag, prior, p, POSTFIX, LEFT, shiftPostfix, reducePostfix)
    syntaxError("invalid fixity", fixity)


define newAlias(operators, tag, name)
    if not isName(name)
        syntaxError("expected operator name", name)
    rules := lookupSyntax(operators, getLexeme(name)) ??
        syntaxError("syntax not defined", name)
    Operator(tag, 0, rules)


define copySyntax(operators, tag, name)
    lexeme := getTagLexeme(tag)
    match getSyntax(newAlias(operators, tag, name))
        Syntax(_, l, r, f, a, s, sh, rd, p) ->
            Operator(tag, 0, Syntax(lexeme, l, r, f, a, s, sh, rd, p))


define findPrecedence(operators, node)
    syntax := lookupSyntax(operators, getLexeme(node)) ??
        syntaxError("syntax not defined", node)
    if getLeftPrecedence(syntax) =/= getRightPrecedence(syntax)
        syntaxError("operator not supported", node)
    getLeftPrecedence(syntax)


define parsePrecedence(operators, node)
    precedence := if isNumber(node) then
        getNumericValue(node) else findPrecedence(operators, node)
    if precedence > 99
        syntaxError("invalid precedence", node)
    precedence


define defineSyntax(operators, node, name, right)
    tag := getTag(node)
    if not isName(name)
        syntaxError("expected name operand to", node)
    if not isJuxtaposition(right)
        syntaxError("invalid syntax definition", node)
    fixity := getLeft(right)
    if isThisName(fixity, "alias")
        operator := newAlias(operators, getTag(name), getRight(right))
        Definition(tag, SyntaxDefinition, name, operator)
    if isThisName(fixity, "syntax")
        operator := copySyntax(operators, getTag(name), getRight(right))
        Definition(tag, SyntaxDefinition, name, operator)
    argument := getRight(right)
    precedence := parsePrecedence(operators, argument)
    prior := if isNumber(argument) then "" else getLexeme(argument)
    operator := newSyntaxOperator(getTag(name), precedence, fixity, prior)
    Definition(tag, SyntaxDefinition, name, operator)


define addSyntax(operators, operator)
    if operators.map(first).any(=*= getLexeme(operator))
        syntaxError("syntax already defined", operator)
    operators' := (getLexeme(operator), getSyntax(operator)) :: operators
    p := getLeftPrecedence(getSyntax(operator))
    if isThisOperator(operator, "+")
        s := Syntax("(+)", p, p, PREFIX, LEFT, false, shiftPrefix, reducePrefix,
            "")
        ("(+)", s) :: operators'
    if isThisOperator(operator, "-")
        s := Syntax("(-)", p, p, PREFIX, LEFT, false, shiftPrefix, reducePrefix,
            "")
        ("(-)", s) :: operators'
    operators'


define reduceLeftErase(State(stack, operators), operator)
    reduceLeft(State(erase(stack, " "), operators), operator)


define shiftNewline(state, operator)
    state' @ State(stack', operators') := reduceLeftErase(state, operator)
    top := head(stack')
    if isSyntaxDefinition(top)
        definition := defineSyntax(operators', top,
            getDefinee(top), getDefinedValue(top))
        operators'' := addSyntax(operators', getDefinedValue(definition))
        State(operator :: definition :: tail(stack'), operators'')
    if isOperator(top)
        state'
    State(operator :: stack', operators')


define coreAlias(lexeme, alias, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)
    (lexeme, Syntax(alias, leftPrecedence, rightPrecedence, fixity,
        associativity, true, shifter, reducer, ""))


define coreSyntax(lexeme, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)
    coreAlias(lexeme, lexeme, leftPrecedence, rightPrecedence, fixity,
        associativity, shifter, reducer)


OPERATORS := [
    coreSyntax("\0", 0, 0, CLOSEFIX, RIGHT, shiftClose, reduceEOF),
    coreSyntax("(", 95, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched),
    coreSyntax(")", 0, 95, CLOSEFIX, RIGHT, shiftClose, reduceParentheses),
    coreSyntax("[", 95, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched),
    coreSyntax("]", 0, 95, CLOSEFIX, RIGHT, shiftClose, reduceSquare),
    coreSyntax("{", 95, 0, OPENFIX, RIGHT, shiftOpen, reduceUnmatched),
    coreSyntax("}", 0, 95, CLOSEFIX, RIGHT, shiftClose, reduceCurly),
    coreSyntax("|", 1, 1, INFIX, NEITHER, shiftInfix, reduceReserved),
    coreSyntax(",", 2, 2, INFIX, LEFT, shiftInfix, reduceCommaPair),
    coreSyntax("\n", 3, 3, INFIX, RIGHTVALUE, shiftNewline, reduceNewline),
    coreSyntax(";;", 4, 4, INFIX, RIGHT, shiftInfix, reduceNewline),
    coreSyntax("define", 5, 5, PREFIX, LEFT, shiftPrefix, reducePrefix),
    coreSyntax(":=", 5, 5, INFIX, RIGHT, shiftInfix, reduceDefine),
    coreAlias("≔", ":=", 5, 5, INFIX, RIGHT, shiftInfix, reduceDefine),
    coreSyntax("::=", 5, 5, INFIX, RIGHT, shiftInfix, reduceADTDefine),
    coreAlias("⩴", "::=", 5, 5, INFIX, RIGHT, shiftInfix, reduceADTDefine),
    coreSyntax("where", 5, 5, INFIX, RIGHT, shiftInfix, reduceWhere),
    coreSyntax("|>", 6, 6, INFIX, LEFT, shiftInfix, reducePipeline),
    coreAlias("⦊", "|>", 6, 6, INFIX, LEFT, shiftInfix, reducePipeline),
    coreSyntax("<|", 6, 6, INFIX, RIGHT, shiftInfix, reduceApply),
    coreAlias("⦉","<|", 6, 6, INFIX, RIGHT, shiftInfix, reduceApply),
    coreSyntax(";", 8, 8, INFIX, RIGHT, shiftInfix, reduceNewline),
    coreSyntax("->", 9, 9, INFIX, RIGHT, shiftInfix, reduceArrow),
    coreAlias("↦", "->", 9, 9, INFIX, RIGHT, shiftInfix, reduceArrow),
    coreSyntax("case", 10, 10, PREFIX, NEITHER, shiftPrefix, reducePrefix),
    coreSyntax("@", 12, 12, INFIX, NEITHER, shiftInfix, reduceAsPattern),
    coreSyntax("abort", 15, 15, PREFIX, LEFT, shiftPrefix, reducePrefix),
    coreSyntax(".", 97, 97, INFIX, LEFT, shiftInfix, reducePipeline),
    coreSyntax("( )", 99, 99, INFIX, LEFT, shiftSpace, reduceInvalid),
    coreSyntax("$", 99, 99, PREFIX, LEFT, shiftPrefix, reduceReserved)
]

#*
