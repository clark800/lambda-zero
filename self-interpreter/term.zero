#* term.zero

Metadata ::= {Metadata(
    getAnnotation : (Scheme)?,
    getAscription : (Scheme)?,
    getConstructorDebruijnIndices : List(ℕ)
)}

Closure(term) ::= {Closure(
    getTerm : term,
    getEnvironment : List(ℕ && FullBinaryTree(Closure(term)))
)}

Term ::= {
    Variable(_ : Tag, _debruijn : ℕ),
    Abstraction(_ : Tag, _ : Metadata, _body : Term),
    Application(_ : Tag, _let : 𝔹, _applicand : Term, _argument : Term),
    Numeral(_ :  Tag, _value : ℕ),
    Operation(_ : Tag, _arity : ℕ, _operator :
        ((Closure(Term) => Closure(Term)) =>
            List(Closure(Term)) => Closure(Term)))
}

define getTermTag
    Variable(tag, _) -> tag
    Abstraction(tag, _, _) -> tag
    Application(tag, _, _, _) -> tag
    Numeral(tag, _) -> tag
    Operation(tag, _, _) -> tag


isVariable := Variable(_, _) -> True; _ -> False
isAbstraction := Abstraction(_, _, _) -> True; _ -> False
isApplication := Application(_, _, _, _) -> True; _ -> False
isNumeral := Numeral(_, _) -> True; _ -> False
isOperation := Operation(_, _, _) -> True; _ -> False


define setMetadata(metadata, term)
    with term as Abstraction(tag, _, body)
        Abstraction(tag, metadata, body)
    term


define maybeDebruijnIndex(term)
    with term as Variable(_, debruijn)
        Just(debruijn)
    Void


define maybeBody(term)
    with term as Abstraction(_, _, body)
        Just(body)
    Void


define maybeApplicand(term)
    with term as Application(_, _, applicand, _)
        Just(applicand)
    Void


define maybeArgument(term)
    with term as Application(_, _, _, argument)
        Just(argument)
    Void


define maybeNatural(term)
    with term as Numeral(_, value)
        Just(value)
    Void


define maybeHead(term)
    maybe body := maybeBody(term)
    maybe body' := maybeBody(body)
    maybe applicand := maybeApplicand(body')
    maybeArgument(applicand)


define maybeTail(term)
    maybe body := maybeBody(term)
    maybe body' := maybeBody(body)
    maybeArgument(body')


define maybeIsNil(term)
    # returns True for [], False for non-nil list, Void for non-list
    # term should be (n -> p -> n) or (n -> p -> ((p c) cs))

    define ifNil(result)
        maybe body := maybeBody(term)
        maybe body' := maybeBody(body)
        maybe debruijn := maybeDebruijnIndex(body')
        if debruijn = 2 then Just(result) else Void

    define ifPush(result)
        maybe body := maybeBody(term)
        maybe body' := maybeBody(body)
        maybe applicand := maybeApplicand(body')
        maybe applicand' := maybeApplicand(applicand)
        maybe debruijn := maybeDebruijnIndex(applicand')
        if debruijn = 1 then Just(result) else Void

    ifNil(Just(True)) ?? ifPush(Just(False)) ?? Void


define showTerm
    Variable(tag, n) -> showTag(tag) ++ "#" ++ showNatural(n)
    Abstraction(tag, _, body) ->
        "(" ++ showTag(tag) ++ " -> " ++ showTerm(body) ++ ")"
    Application(_, _, applicand, argument) ->
        "(" ++ showTerm(applicand) ++ " " ++ showTerm(argument) ++ ")"
    Numeral(_, n) -> showNatural(n)
    Operation(tag, _, _) -> showTag(tag)

#*
