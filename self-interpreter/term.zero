#* term.zero

Constraint(term) ::= {
    Annotation(_ : term), # assume type of lambda parameter and verify body
    Ascription(_ : term), # assume type of lambda parameter but don't check body
    PolarAnnotation(_ : term, _ : term)  # annotation for case lambdas
}

ClosureT(term) ::= {Closure(
    getTerm : term,
    getEnvironment : ArrayT(ClosureT(term))
)}

Term ::= {
    Top(_ : TagT),
    Constant(_ : TagT, _id : ℕ),
    Variable(_ : TagT, _debruijn : ℕ),
    MetaVariable(_ : TagT, _id : ℕ),
    Abstraction(_ : TagT, _ : Constraint(Term), _body : Term),
    Implication(_ : TagT, _antecedent : Term, _consequent : Term),
    Implicit(_ : TagT, _type : Term, _body : Term),
    Application(_ : TagT, _applicand : Term, _argument : Term),
    Construction(_ : TagT, _parameters : List(Term), _objectType : Term),
    Numeral(_ :  TagT, _type : Term, _value : ℕ),
    Operation(_ : TagT, _type : Term, _arity : ℕ, _operator :
        ((ClosureT(Term) => ClosureT(Term)) =>
            List(ClosureT(Term)) => ClosureT(Term)))
}

define getTermTag
    Top(tag) -> tag
    Constant(tag, _) -> tag
    Variable(tag, _) -> tag
    MetaVariable(tag, _) -> tag
    Abstraction(tag, _, _) -> tag
    Implication(tag, _, _) -> tag
    Implicit(tag, _, _) -> tag
    Application(tag, _, _) -> tag
    Construction(tag, _, _) -> tag
    Numeral(tag, _, _) -> tag
    Operation(tag, _, _, _) -> tag


isTop := Top(_) -> True; _ -> False
isConstant := Constant(_, _) -> True; _ -> False
isVariable := Variable(_, _) -> True; _ -> False
isMetaVariable := MetaVariable(_, _) -> True; _ -> False
isAbstraction := Abstraction(_, _, _) -> True; _ -> False
isImplication := Implication(_, _, _) -> True; _ -> False
isImplicit := Implicit(_, _, _) -> True; _ -> False
isApplication := Application(_, _, _) -> True; _ -> False
isConstruction := Construction(_, _, _) -> True; _ -> False
isNumeral := Numeral(_, _, _) -> True; _ -> False
isOperation := Operation(_, _, _, _) -> True; _ -> False


define isLambdaConstraint
    Annotation(_) -> True
    Ascription(_) -> False
    PolarAnnotation(_, _) -> False


define FreeAbstraction(tag, body)
    Abstraction(tag, Annotation(MetaVariable(veil(tag), 0)), body)


define splitSpine(term)
    with term as Application(_, left, right)
        (applicand, arguments) := splitSpine(left)
        (applicand, arguments ++ [right])
    (term, [])


define getTermHead(term)
    first(splitSpine(term))


define setAscription(type, term)
    with term as Abstraction(tag, _, body)
        Abstraction(tag, Ascription(type), body)
    with term as Numeral(tag, _, value)
        Numeral(tag, type, value)
    with term as Operation(tag, _, arity, operator)
        Operation(tag, type, arity, operator)
    term


define maybeAscription(node)
    with node as Abstraction(_, constraint, _)
        with constraint as Ascription(type)
            Just(type)
        Void
    with node as Numeral(_, type, _)
        Just(type)
    with node as Operation(_, type, _, _)
        Just(type)
    Void


define maybeDebruijnIndex(term)
    with term as Variable(_, debruijn)
        Just(debruijn)
    Void


define maybeBody(term)
    with term as Abstraction(_, _, body)
        Just(body)
    Void


define maybeApplicand(term)
    with term as Application(_, applicand, _)
        Just(applicand)
    Void


define maybeArgument(term)
    with term as Application(_, _, argument)
        Just(argument)
    Void


define maybeNatural(term)
    with term as Numeral(_, _, value)
        Just(value)
    Void


define maybeAddress(type)
    with type as MetaVariable(_, address)
        Just(address)
    Void


define maybeCount(node)
    with node as Constructor(_, _, _, _, count, _)
        Just(count)
    Void


define maybeConstructorIndex(node)
    with node as Constructor(_, _, _, _, _, index)
        Just(index)
    Void


define maybeHead(term)
    maybe body := maybeBody(term)
    maybe body' := maybeBody(body)
    maybe applicand := maybeApplicand(body')
    maybeArgument(applicand)


define maybeTail(term)
    maybe body := maybeBody(term)
    maybe body' := maybeBody(body)
    maybeArgument(body')


define maybeIsNil(term)
    # returns True for [], False for non-nil list, Void for non-list
    # term should be (n -> p -> n) or (n -> p -> ((p c) cs))

    define ifNil(result)
        maybe body := maybeBody(term)
        maybe body' := maybeBody(body)
        maybe debruijn := maybeDebruijnIndex(body')
        if debruijn = 2 then Just(result) else Void

    define ifPush(result)
        maybe body := maybeBody(term)
        maybe body' := maybeBody(body)
        maybe applicand := maybeApplicand(body')
        maybe applicand' := maybeApplicand(applicand)
        maybe debruijn := maybeDebruijnIndex(applicand')
        if debruijn = 1 then Just(result) else Void

    ifNil(Just(True)) ?? ifPush(Just(False)) ?? Void


define setTag(tag)
    Top(_) -> Top(tag)
    Constant(_, index) -> Constant(tag, index)
    Variable(_, debruijn) -> Variable(tag, debruijn)
    MetaVariable(_, index) -> MetaVariable(tag, index)
    Abstraction(_, metadata, body) -> Abstraction(tag, metadata, body)
    Implication(_, parameter, body) -> Implication(tag, parameter, body)
    Implicit(_, type, body) -> Implicit(tag, type, body)
    Application(_, left, right) -> Application(tag, left, right)
    Construction(_, parameters, type) -> Construction(tag, parameters, type)
    Numeral(_, type, value) -> Numeral(tag, type, value)
    Operation(_, type, arity, operator) -> Operation(tag, type, arity, operator)


define setLocation(Tag(_, _, location), term)
    term.setTag(getTermTag(term).setTagLocation(location))


define sameConstant(a, b)
    with a as Constant(_, indexA)
        with b as Constant(_, indexB)
            indexA = indexB
        False
    False


define sameHead(term)
    case Top(_)
        isTop(term)
    case Constant(_, index)
        with term as Constant(_, index')
            index = index'
        False
    case Variable(tag, _)
        False
    case MetaVariable(_, address)
        with term as MetaVariable(_, address')
            address = address'
        False
    case Abstraction(_, _, _)
        isAbstraction(term)
    case Implication(_, _, _)
        isImplication(term)
    case Implicit(_, _, _)
        isImplicit(term)
    case Application(_, _, _)
        isApplication(term)
    case Construction(tag, _, _)
        isConstruction(term) and
            getTagLexeme(tag) =*= getTagLexeme(getTermTag(term))
    case Numeral(_, _, value)
        with term as Numeral(_, _, value')
            value = value'
        False
    case Operation(tag, _, _, _)
        with term as Operation(tag', _, _, _)
            getTagLexeme(tag) =*= getTagLexeme(tag')
        False


define getComponents
    Top(_) -> []
    Constant(_, _) -> []
    Variable(_, _) -> []
    MetaVariable(_, _) -> []
    Abstraction(_, _, body) -> [body]  # todo: should also include annotation
    Implication(_, parameter, body) -> [parameter, body]
    Implicit(_, type, body) -> [type, body]
    Application(_, left, right) -> [left, right]
    Construction(_, parameters, _) -> parameters
    Numeral(_, _, _) -> []
    Operation(_, _, _, _) -> []


define mapComponents(f, term)
    match term
        Top(_) -> term
        Constant(_, _) -> term
        Variable(_, _) -> term
        MetaVariable(_, _) -> term
        Abstraction(tag, metadata, body) ->
            Abstraction(tag, metadata, f(body))
        Implication(tag, parameter, body) ->
            Implication(tag, f(parameter), f(body))
        Implicit(tag, type, body) -> Implicit(tag, f(type), f(type))
        Application(tag, left, right) ->
            Application(tag, mapComponents(f, left), f(right))
        Construction(tag, parameters, type) ->
            Construction(tag, parameters.map(f), type)
        Numeral(_, _, _) -> term
        Operation(_, _, _, _) -> term


define getSuffix(count, index)
    if count <= 1 or index = 0 then ""
    subscripts := ["₀", "₁", "₂", "₃", "₄", "₅", "₆", "₇", "₈", "₉"]
    showNatural(index).map(x -> subscripts.at(x -- '0') ?? "").join


define showConstruction(showTerm, headTag, arguments)
    argumentStrings := arguments.map(showTerm)
    with argumentStrings as argumentString :: argumentStrings'
        fixity := getTagFixity(headTag)
        lexeme := getTagLexeme(headTag)
        if fixity = INFIX and length(arguments) = 2
            items := argumentString :: lexeme :: argumentStrings'
            "(" ++ items.joinWith(" ") ++ ")"
        if fixity = PREFIX and length(arguments) = 1
            lexeme ++ "(" ++ argumentString ++ ")"
        if fixity = POSTFIX and length(arguments) = 1
            "(" ++ argumentString ++ ")" ++ lexeme
        showTag(headTag) ++ "(" ++ argumentStrings.joinWith(", ") ++ ")"
    showTag(headTag)


define showApplication(showTerm, applicand, argument)
    (headTerm, applicandArguments) := splitSpine(applicand)
    headTag := getTermTag(headTerm)
    arguments := applicandArguments ++ [argument]
    showConstruction(showTerm, headTag, arguments)


define showMetaVariable(n)
    characters := ['a', 'b', 'c', 'd']
    if n < 4
        [characters.at(n) ?? '#']
    showMetaVariable((n // 4) -- 1) ++ [characters.at(n % 4) ?? '#']


define showTerm
    Top(_) -> "⊤"
    Constant(tag, n) -> showTag(tag) # ++ "$" ++ showNatural(n)
    Variable(tag, n) -> showTag(tag) # ++ "#" ++ showNatural(n)
    MetaVariable(tag, n) -> showMetaVariable(n)
    Abstraction(tag, _, body) ->
        "(" ++ showTag(tag) ++ " ↦ " ++ showTerm(body) ++ ")"
    Implication(tag, parameter, body) ->
        if isImplication(parameter) then
            "(" ++ showTerm(parameter) ++ ")" ++
            " ⇒ " ++ showTerm(body) else
                showTerm(parameter) ++ " ⇒ " ++ showTerm(body)
    Implicit(tag, type, body) ->
        "(" ++ showTag(tag) ++ " ⇝ " ++ showTerm(body) ++ ")"
    Application(_, applicand, argument) ->
        showApplication(showTerm, applicand, argument)
    Construction(tag, parameters, _) ->
        showConstruction(showTerm, tag, parameters)
    Numeral(_, _, n) -> showNatural(n)
    Operation(tag, _, _, _) -> showTag(tag)


define showTermLocation(term)
    showLocation(getTagLocation(getTermTag(term)))


define showTermAndLocation(term)
    showTerm(term) ++ " at " ++ showTermLocation(term)


define pushMeta(environment)
    # use MetaVariable 0 to indicate that we don't have a value for the variable
    environment.push(Closure(MetaVariable(noTag, 0), newArray([])))


# for any variable in term that has a value in the environment, substitute
# the variable with the value from the environment recursively
# todo: can remove this when we use closures instead of schemes for types
define flattenClosure(Closure(term, environment))
    match term
        case Top(_)
            term
        case Constant(_, _)
            term
        case Variable(tag, debruijn)
            with environment.peek(debruijn -- 1) as Just(closure)
                with getTerm(closure) as MetaVariable(_, n)
                    if n = 0 then term else pass
                flattenClosure(closure)
            term
        case MetaVariable(_, _)
            term
        case Abstraction(tag, constraint, body)
            # todo: flatten constraint too
            body' := flattenClosure(Closure(body, pushMeta(environment)))
            Abstraction(tag, constraint, body')
        case Implication(tag, type, body)
            type' := flattenClosure(Closure(type, environment))
            body' := flattenClosure(Closure(body, pushMeta(environment)))
            Implication(tag, type', body')
        case Implicit(tag, type, body)
            type' := flattenClosure(Closure(type, environment))
            body' := flattenClosure(Closure(body, pushMeta(environment)))
            Implicit(tag, type', body')
        case Application(tag, left, right)
            left' := flattenClosure(Closure(left, environment))
            right' := flattenClosure(Closure(right, environment))
            Application(tag, left', right')
        case Construction(tag, parameters, objectType)
            parameters' := parameters.map(x ->
                flattenClosure(Closure(x, environment)))
            Construction(tag, parameters', objectType)
        case Numeral(_, _, _)
            term
        case Operation(_, _, _, _)
            term

#*
