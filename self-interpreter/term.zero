#* term.zero

Constraint ::= {
    Ascription(_ : Scheme),
    Annotation(_ : Scheme),
    PolarAnnotation(_ : Scheme, _ : Scheme)
}

Closure(term) ::= {Closure(
    getTerm : term,
    getEnvironment : List(ℕ && FullBinaryTree(Closure(term)))
)}

Term ::= {
    Top(_ : Tag),
    Variable(_ : Tag, _debruijn : ℕ),
    MetaVariable(_ : Tag, _id : ℕ),
    Abstraction(_ : Tag, _ : Constraint, _body : Term),
    Implication(_ : Tag, _antecedent : Term, _consequent : Term),
    Implicit(_ : Tag, _type : Term, _body : Term),
    Application(_ : Tag, _let : 𝔹, _applicand : Term, _argument : Term),
    Construction(_ : Tag, _components : List(Term)),
    Numeral(_ :  Tag, _type : Term, _value : ℕ),
    Operation(_ : Tag, _type : Term, _arity : ℕ, _operator :
        ((Closure(Term) => Closure(Term)) =>
            List(Closure(Term)) => Closure(Term)))
}

Scheme ::= {Scheme(getUniversals : List(Term), getType : Term)}

NoConstraint := Annotation(Scheme([v], v)) where v := MetaVariable(noTag, 0)

define getTermTag
    Top(tag) -> tag
    Variable(tag, _) -> tag
    MetaVariable(tag, _) -> tag
    Abstraction(tag, _, _) -> tag
    Implication(tag, _, _) -> tag
    Implicit(tag, _, _) -> tag
    Application(tag, _, _, _) -> tag
    Construction(tag, _) -> tag
    Numeral(tag, _, _) -> tag
    Operation(tag, _, _, _) -> tag


isTop := Top(_) -> True; _ -> False
isVariable := Variable(_, _) -> True; _ -> False
isMetaVariable := MetaVariable(_, _) -> True; _ -> False
isAbstraction := Abstraction(_, _, _) -> True; _ -> False
isImplication := Implication(_, _, _) -> True; _ -> False
isImplicit := Implicit(_, _, _) -> True; _ -> False
isApplication := Application(_, _, _, _) -> True; _ -> False
isConstruction := Construction(_, _) -> True; _ -> False
isNumeral := Numeral(_, _, _) -> True; _ -> False
isOperation := Operation(_, _, _, _) -> True; _ -> False


define setAscription(scheme, term)
    with term as Abstraction(tag, _, body)
        Abstraction(tag, Ascription(scheme), body)
    with term as Numeral(tag, _, value)
        Numeral(tag, getType(scheme), value)
    with term as Operation(tag, _, arity, operator)
        Operation(tag, getType(scheme), arity, operator)
    term


define maybeDebruijnIndex(term)
    with term as Variable(_, debruijn)
        Just(debruijn)
    Void


define maybeBody(term)
    with term as Abstraction(_, _, body)
        Just(body)
    Void


define maybeApplicand(term)
    with term as Application(_, _, applicand, _)
        Just(applicand)
    Void


define maybeArgument(term)
    with term as Application(_, _, _, argument)
        Just(argument)
    Void


define maybeNatural(term)
    with term as Numeral(_, _, value)
        Just(value)
    Void


define maybeAddress(type)
    with type as MetaVariable(_, address)
        Just(address)
    Void


define maybeHead(term)
    maybe body := maybeBody(term)
    maybe body' := maybeBody(body)
    maybe applicand := maybeApplicand(body')
    maybeArgument(applicand)


define maybeTail(term)
    maybe body := maybeBody(term)
    maybe body' := maybeBody(body)
    maybeArgument(body')


define maybeIsNil(term)
    # returns True for [], False for non-nil list, Void for non-list
    # term should be (n -> p -> n) or (n -> p -> ((p c) cs))

    define ifNil(result)
        maybe body := maybeBody(term)
        maybe body' := maybeBody(body)
        maybe debruijn := maybeDebruijnIndex(body')
        if debruijn = 2 then Just(result) else Void

    define ifPush(result)
        maybe body := maybeBody(term)
        maybe body' := maybeBody(body)
        maybe applicand := maybeApplicand(body')
        maybe applicand' := maybeApplicand(applicand)
        maybe debruijn := maybeDebruijnIndex(applicand')
        if debruijn = 1 then Just(result) else Void

    ifNil(Just(True)) ?? ifPush(Just(False)) ?? Void


define setTag(tag)
    Top(_) -> Top(tag)
    Variable(_, debruijn) -> Variable(tag, debruijn)
    MetaVariable(_, index) -> MetaVariable(tag, index)
    Abstraction(_, metadata, body) -> Abstraction(tag, metadata, body)
    Implication(_, parameter, body) -> Implication(tag, parameter, body)
    Implicit(_, type, body) -> Implication(tag, type, body)
    Application(_, isLet, left, right) -> Application(tag, isLet, left, right)
    Construction(_, parameters) -> Construction(tag, parameters)
    Numeral(_, type, value) -> Numeral(tag, type, value)
    Operation(_, type, arity, operator) -> Operation(tag, type, arity, operator)


define setLocation(Tag(_, _, location), term)
    term.setTag(getTermTag(term).setTagLocation(location))


define sameHead(term)
    case Top(_)
        isTop(term)
    case Variable(_, debruijn)
        with term as Variable(_, debruijn')
            debruijn = debruijn'
        False
    case MetaVariable(_, address)
        with term as MetaVariable(_, address')
            address = address'
        False
    case Abstraction(_, _, _)
        isAbstraction(term)
    case Implication(_, _, _)
        isImplication(term)
    case Implicit(_, _, _)
        isImplicit(term)
    case Application(_, _, _, _)
        isApplication(term)
    case Construction(tag, parameters)
        with term as Construction(tag', parameters')
            getTagLexeme(tag) =*= getTagLexeme(tag')
        False
    case Numeral(_, _, value)
        with term as Numeral(_, _, value')
            value = value'
        False
    case Operation(tag, _, _, _)
        with term as Operation(tag', _, _, _)
            getTagLexeme(tag) =*= getTagLexeme(tag')
        False


define getComponents
    Top(_) -> []
    Variable(_, _) -> []
    MetaVariable(_, _) -> []
    Abstraction(_, _, body) -> [body]
    Implication(_, parameter, body) -> [parameter, body]
    Implicit(_, type, body) -> [type, body]
    Application(_, _, left, right) -> [left, right]
    Construction(_, parameters) -> parameters
    Numeral(_, _, _) -> []
    Operation(_, _, _, _) -> []


define mapComponents(f, term)
    match term
        Top(_) -> term
        Variable(_, _) -> term
        MetaVariable(_, _) -> term
        Abstraction(tag, metadata, body) ->
            Abstraction(tag, metadata, f(body))
        Implication(tag, parameter, body) ->
            Implication(tag, f(parameter), f(body))
        Implicit(tag, type, body) ->
            Implication(tag, f(type), f(type))
        Application(tag, isLet, left, right) ->
            Application(tag, isLet, f(left), f(right))
        Construction(tag, parameters) ->
            Construction(tag, parameters.map(f))
        Numeral(_, _, _) -> term
        Operation(_, _, _, _) -> term


define getSuffix(count, index)
    if count <= 1 or index = 0 then ""
    subscripts := ["₀", "₁", "₂", "₃", "₄", "₅", "₆", "₇", "₈", "₉"]
    showNatural(index).map(x -> subscripts.safeAt(x -- '0') ?? "").join


define showConstruction(Tag(name, fixity, _), arguments)
    with arguments as argument :: arguments'
        if fixity = INFIX and length(arguments) = 2
            "(" ++ (argument :: name :: arguments').joinWith(" ") ++ ")"
        if fixity = PREFIX and length(arguments) = 1
            name ++ "(" ++ argument ++ ")"
        if fixity = POSTFIX and length(arguments) = 1
            "(" ++ argument ++ ")" ++ name
        name ++ "(" ++ arguments.joinWith(", ") ++ ")"
    name


define showMetaVariable(n)
    characters := ['a', 'b', 'c', 'd']
    if n < 4
        [characters.safeAt(n) ?? '#']
    showMetaVariable((n // 4) -- 1) ++ [characters.safeAt(n % 4) ?? '#']


define showTerm
    Top(_) -> "⊤"
    Variable(tag, n) -> showTag(tag) #++ "#" ++ showNatural(n)
    MetaVariable(tag, n) -> showMetaVariable(n)
    Abstraction(tag, _, body) ->
        "(" ++ showTag(tag) ++ " ↦ " ++ showTerm(body) ++ ")"
    Implication(tag, parameter, body) ->
        if isImplication(parameter) then
            "(" ++ showTerm(parameter) ++ ")" ++
            " ⇒ " ++ showTerm(body) else
                showTerm(parameter) ++ " ⇒ " ++ showTerm(body)
    Implicit(tag, type, body) ->
        "(" ++ showTag(tag) ++ " ⇝ " ++ showTerm(body) ++ ")"
    Application(_, _, applicand, argument) ->
        "(" ++ showTerm(applicand) ++ " " ++ showTerm(argument) ++ ")"
    Construction(tag, parameters) ->
        showConstruction(tag, parameters.map(showTerm))
    Numeral(_, _, n) -> showNatural(n)
    Operation(tag, _, _, _) -> showTag(tag)


define showScheme(Scheme(universals, term))
    universals.map(universal -> "∀" ++ showTerm(universal) ++ " ").join ++
        showTerm(term)


define getDefinitions(term)
    with term as Application(_, isLet, applicand, argument)
        if isLet
            with applicand as Abstraction(_, _, body)
                (getTermTag(applicand), argument) :: getDefinitions(body)
            []
        []
    []

#*
