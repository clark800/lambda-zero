#* term.zero

MetadataType ::= {Metadata(
    getAnnotation : SchemeType,
    getAscription : SchemeType,
    getConstructorDebruijnIndices : List(ℕ)
)}

ClosureT(term) ::= {Closure(
    getTerm : term,
    getEnvironment : List(ℕ && FullBinaryTree(ClosureT(term)))
)}

Term ::= {
    Variable(_ : TagType, getDebruijnIndex : ℕ),
    Abstraction(_ : TagType, getMetadata : MetadataType, getBody : Term),
    Application(_ : TagType, isLet : 𝔹,
        getApplicand : Term, getArgument : Term),
    Numeral(_ :  TagType, getNatural : ℕ),
    Operation(_ : TagType, getArity : ℕ,
        getOperator : ((ClosureT(Term) => ClosureT(Term)) =>
            List(ClosureT(Term)) => ClosureT(Term)))
}

define getTermTag
    Variable(tag, _) -> tag
    Abstraction(tag, _, _) -> tag
    Application(tag, _, _, _) -> tag
    Numeral(tag, _) -> tag
    Operation(tag, _, _) -> tag


define indexTerm
    Variable(_, _) -> 0
    Abstraction(_, _, _) -> 1
    Application(_, _, _, _) -> 2
    Numeral(_, _) -> 3
    Operation(_, _, _) -> 4


isVariable(term) := indexTerm(term) = 0
isAbstraction(term) := indexTerm(term) = 1
isApplication(term) := indexTerm(term) = 2
isNumeral(term) := indexTerm(term) = 3
isOperation(term) := indexTerm(term) = 4


define maybeDebruijnIndex(term)
    if isVariable(term) then just(getDebruijnIndex(term)) else void


define maybeBody(term)
    if isAbstraction(term) then just(getBody(term)) else void


define maybeApplicand(term)
    if isApplication(term) then just(getApplicand(term)) else void


define maybeArgument(term)
    if isApplication(term) then just(getArgument(term)) else void


define maybeNatural(term)
    if isNumeral(term) then just(getNatural(term)) else void


define maybeHead(term)
    maybe body := maybeBody(term)
    maybe body' := maybeBody(body)
    maybe applicand := maybeApplicand(body')
    maybeArgument(applicand)


define maybeTail(term)
    maybe body := maybeBody(term)
    maybe body' := maybeBody(body)
    maybeArgument(body')


define maybeIsNil(term)
    # returns true for [], false for non-nil list, void for non-list
    # term should be (n -> p -> n) or (n -> p -> ((p c) cs))

    define ifNil(result)
        maybe body := maybeBody(term)
        maybe body' := maybeBody(body)
        maybe debruijn := maybeDebruijnIndex(body')
        if debruijn = 2 then just(result) else void

    define ifPush(result)
        maybe body := maybeBody(term)
        maybe body' := maybeBody(body)
        maybe applicand := maybeApplicand(body')
        maybe applicand' := maybeApplicand(applicand)
        maybe debruijn := maybeDebruijnIndex(applicand')
        if debruijn = 1 then just(result) else void

    ifNil(just(true)) ?? ifPush(just(false)) ?? void


define showTerm
    Variable(tag, n) -> showTag(tag) ++ "#" ++ showNatural(n)
    Abstraction(tag, _, body) ->
        "(" ++ showTag(tag) ++ " -> " ++ showTerm(body) ++ ")"
    Application(_, _, applicand, argument) ->
        "(" ++ showTerm(applicand) ++ " " ++ showTerm(argument) ++ ")"
    Numeral(_, n) -> showNatural(n)
    Operation(tag, _, _) -> showTag(tag)

noTerm := Variable(noTag, 0)
isNoTerm(term) := isVariable(term) and getDebruijnIndex(term) = 0

#*
