#* type.zero

# note: types contain source terms so that we have the ability to serialize the
# whole source term if there is a type error
Type ::= {
    FreeType,
    BottomType(_source : Term),
    TypeVariable(_source : Term, _address : ℕ),
    FunctionType(_source : Term, _parameterType : Type, _bodyType : Type),
    ADT(_source : Term, _name : List(ℕ), _fixity : ℕ,
        _parameterTypes : List(Type), _matchType : Type,
        _count : ℕ, _index : ℕ)
        # when getMatchType=FreeType, it can't be applied as a function;
        # ADT instances can only be applied as functions in the desugared
        # form of case expressions
}

Scheme ::= {Scheme(getUniversals : List(Type), getType : Type)}

Free := Scheme([], FreeType)

#*
