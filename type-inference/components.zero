#* components.zero

def getDomainComponents
    Inferred -> []
    Annotation(term) -> [term]
    PatternMatch(term) -> []


def getComponents
    Unknown(_) -> []
    MetaVariable(_, _) -> []
    Type(_, _) -> []
    Variable(_, _) -> []
    Function(_, domain, body) -> getDomainComponents(domain) ++ [body]
    Implication(_, domain, body) -> [domain, body]
    Intersection(_, domain, body) -> [domain, body]
    Application(_, left, right) -> [left, right]
    Construction(_, domain, parameters, body) -> domain :: parameters
    Numeral(_, _, _) -> []
    Operation(_, _, _) -> []


# PatternMatch will never contain metavariables or unbound
# Variables, so we can skip them here
def mapDomain(f)
    Inferred -> Inferred
    Annotation(domain) -> Annotation(f(domain))
    PatternMatch(domain) -> PatternMatch(domain)


def mapComponentsWithDepth(f, depth, term)
    match term
        Unknown(_) -> term
        MetaVariable(_, _) -> term
        Type(_, _) -> term
        Variable(_, _) -> term
        Function(tag, domain, body) ->
            Function(tag, domain.mapDomain(f(depth)), body.f(up depth))
        Implication(tag, domain, body) ->
            Implication(tag, domain.f(depth), body.f(up depth))
        Intersection(tag, domain, body) ->
            Intersection(tag, domain.f(depth), body.f(up depth))
        Application(tag, left, right) ->
            Application(tag, left.f(depth), right.f(depth))
        Construction(tag, domain, parameters, body) ->
            Construction(tag, domain.f(depth), parameters.map(f(depth)),
                body.f(up depth))
        Numeral(_, _, _) -> term
        Operation(_, _, _) -> term


def mapComponents(f, term)
    mapComponentsWithDepth(_ -> f, 0, term)

#*
