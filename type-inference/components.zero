#* components.zero

def getDomainComponents
    Annotation(term) -> [term]
    PatternMatch(term) -> [term]


def getComponents
    Unknown(_) -> []
    MetaVariable(_, _) -> []
    Type(_, _) -> []
    Variable(_, _) -> []
    Singleton(_, type, _) -> [type]
    Function(_, domain, body) -> getDomainComponents(domain) ++ [body]
    Implication(_, domain, body) -> [domain, body]
    Intersection(_, domain, body) ->
        if isSingleton(domain) then [domain] else [domain, body]
    Application(_, left, right) -> [left, right]
    Numeral(_, _, _) -> []
    Operation(_, _, _) -> []


# PatternMatch will never contain metavariables or unbound
# Variables, so we can skip them here
def mapDomain(f)
    Annotation(domain) -> Annotation(f(domain))
    PatternMatch(domain) -> PatternMatch(f(domain))


def mapComponentsWithDepth(f, depth, term)
    match term
        Unknown(_) -> term
        MetaVariable(_, _) -> term
        Type(_, _) -> term
        Variable(_, _) -> term
        Singleton(tag, type, index) -> Singleton(tag, type.f(depth), index)
        Function(tag, domain, body) ->
            Function(tag, domain.mapDomain(f(depth)), body.f(up depth))
        Implication(tag, domain, body) ->
            Implication(tag, domain.f(depth), body.f(up depth))
        Intersection(tag, domain, body) ->
            Intersection(tag, domain.f(depth), body.f(up depth))
        Application(tag, left, right) ->
            Application(tag, left.f(depth), right.f(depth))
        Numeral(_, _, _) -> term
        Operation(_, _, _) -> term


def mapComponents(f, term)
    mapComponentsWithDepth(_ -> f, 0, term)

#*
