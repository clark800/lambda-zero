#* components.zero

def isSameHead(term)
    case Unknown(_)
        False
    case MetaVariable(_, address)
        if term is MetaVariable(_, address')
            address = address'
        False
    case Universe(_, level)
        if term is Universe(_, level')
            level = level'
        False
    case Variable(_, index)
        if term is Variable(_, index')
            index =:= index'
        False
    case Function(_, _, _)
        isFunction(term)
    case Implication(_, _, _)
        isImplication(term)
    case Intersection(_, _, _)
        isIntersection(term)
    case Application(_, _, _)
        isApplication(term)
    case Construction(tag, _, _, _)
        isConstruction(term) and
            getTagLexeme(tag) =*= getTagLexeme(getTermTag(term))
    case Element(_, _, _)
        isElement(term)
    case Numeral(_, _, value)
        if term is Numeral(_, _, value')
            value = value'
        False
    case Operation(tag, _, _)
        if term is Operation(tag', _, _)
            getTagLexeme(tag) =*= getTagLexeme(tag')
        False


def getAnnotationComponents
    Inferred -> []
    Domain(term) -> [term]
    PatternMatch(term) -> [term]


def getComponents
    Unknown(_) -> []
    MetaVariable(_, _) -> []
    Universe(_, _) -> []
    Variable(_, _) -> []
    Function(_, type, body) -> getAnnotationComponents(type) ++ [body]
    Implication(_, domain, body) -> [domain, body]
    Intersection(_, domain, body) -> [domain, body]
    Application(_, left, right) -> [left, right]
    Construction(_, parameters, _, _) -> parameters
    Element(_, type, term) -> [type, term]
    Numeral(_, _, _) -> []
    Operation(_, _, _) -> []


def mapAnnotation(f)
    Inferred -> Inferred
    Domain(term) -> Domain(f(term))
    PatternMatch(term) -> PatternMatch(f(term))


def mapComponents(f, term)
    match term
        Unknown(_) -> term
        MetaVariable(_, _) -> term
        Universe(_, _) -> term
        Variable(_, _) -> term
        Function(tag, type, body) ->
            Function(tag, type.mapAnnotation(f), f(body))
        Implication(tag, domain, body) -> Implication(tag, f(domain), f(body))
        Intersection(tag, domain, body) -> Intersection(tag, f(domain), f(body))
        Application(tag, left, right) -> Application(tag, f(left), f(right))
        Construction(tag, parameters, type, signatures) ->
            Construction(tag, parameters.map(f), type, signatures)
        Element(tag, type, term) -> Element(tag, f(type), f(term))
        Numeral(_, _, _) -> term
        Operation(_, _, _) -> term

#*
