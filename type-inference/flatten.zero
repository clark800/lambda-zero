#* flatten.zero

define isUnknown(term)
    with term as Variable(_, n)
        n = 0
    False


define pushUnknown(environment)
    # use Variable 0 to indicate that we don't have a value for the variable
    environment.push(Closure(Variable(noTag, 0), newArray([])))


# for any variable in term that has a value in the environment, substitute
# the variable with the value from the environment recursively
# todo: can remove this when we use closures instead of schemes for types
define flattenClosure(Closure(term, environment))
    match term
        case Top(_)
            term
        case Constant(_, index)
            term
        case Variable(tag, debruijn)
            with environment.peek(debruijn -- 1) as Just(closure)
                if isUnknown(getTerm(closure))
                    term
                flattenClosure(evaluateClosure(closure))
            term
        case MetaVariable(_, _)
            term
        case Binder(tag, variety, type, body)
            type' := flattenClosure(Closure(type, environment))
            body' := flattenClosure(Closure(body, pushUnknown(environment)))
            Binder(tag, variety, type', body')
        case Implication(tag, type, body)
            type' := flattenClosure(Closure(type, environment))
            body' := flattenClosure(Closure(body, pushUnknown(environment)))
            Implication(tag, type', body')
        case Implicit(tag, type, body)
            type' := flattenClosure(Closure(type, environment))
            body' := flattenClosure(Closure(body, pushUnknown(environment)))
            Implicit(tag, type', body')
        case Application(tag, left, right)
            left' := flattenClosure(Closure(left, environment))
            right' := flattenClosure(Closure(right, environment))
            Application(tag, left', right')
        case Construction(tag, parameters, objectType)
            parameters' := parameters.map(x ->
                flattenClosure(Closure(x, environment)))
            objectType' := flattenClosure(Closure(objectType, environment))
            Construction(tag, parameters', objectType')
        case Element(tag, type, term)
            type' := flattenClosure(Closure(type, environment))
            term' := flattenClosure(Closure(term, environment))
            Element(tag, type', term')
        case Numeral(_, _, _)
            term
        case Operation(_, _, _, _)
            term

#*
