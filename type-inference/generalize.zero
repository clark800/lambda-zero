#* generalize.zero

def substitute(indices, depth, term)
    # depth should start as the length of indices
    # we only allow generalizing top-level terms, so we don't have to
    # adjust any variable indices
    if term is MetaVariable(tag, index)
        if indices.findIndex((=:= index)) is Just(depth')
            tag' := renameTag(tag, showMetaVariable(+_ depth'), NOFIX)
            Variable(tag', +_(depth -- depth'))
        term
    mapComponentsWithDepth(substitute(indices), depth, term)


def getMetaVariableIndices'(term)
    if term is MetaVariable(_, index)
        if isPositive(index) then [abs(index)] else []
    join(getComponents(term).map(getMetaVariableIndices'))


def getMetaVariableIndices(term)
    getMetaVariableIndices'(term).deduplicateBy((=))


def wrapIntersection(tag, index, body)
    domain := Type(veil(tag), +_ 0)
    tag' := renameTag(tag, showMetaVariable(+_ index), NOFIX)
    Intersection(tag', domain, body)


def generalize(metacontext, closure)
    type := normalize(closure.resolve(metacontext))
    # after resolve, all metavariables in type are free metavariables
    indices := getMetaVariableIndices(type)
    depth := length(indices)
    type' := type.substitute(indices.map((+_)), depth)
    indices' := (0...)[0, depth]
    indices'.fold(wrapIntersection(getTermTag(type)), type')

#*
