#* generalize.zero

def substituteVariable(tag, metaIndex, depth, term)
    if term is MetaVariable(_, index)
        if index =:= metaIndex then Variable(tag, -_ depth) else term
    if term is Variable(tag, index)
        match index
            +_ n -> term
            -_ n -> if n >= depth then Variable(tag, -_(up n)) else term
    mapComponentsWithDepth(substituteVariable(tag, metaIndex), depth, term)


def generalize(metavariable, term)
    # todo: pass domain in as a parameter
    if metavariable is MetaVariable(tag, metaIndex)
        domain := Type(veil(tag), +_ 0)
        body := substituteVariable(tag, metaIndex, 1, term)
        Intersection(tag, domain, body)
    throwError("generalize expects a metavariable", getTermTag(metavariable))


def getMetaVariables'(term)
    if term is MetaVariable(_, index)
        if isPositive(index) then [(abs(index), term)] else []
    join(getComponents(term).map(getMetaVariables'))


def getMetaVariables(term)
    getMetaVariables'(term).deduplicateBy((=).on(first)).map(second)


def renameMetavariable(n, metavariable)
    tag := getTermTag(metavariable)
    metavariable.setTag(renameTag(tag, showMetaVariable(+_ n), NOFIX))


def generalizeAll(metacontext, closure)
    type := closure.resolve(metacontext)
    # after resolve, all metavariables in type are free metavariables
    universals := getMetaVariables(type)
    metavariables := zip(0 ..., universals).map(uncurry(renameMetavariable))
    metavariables.fold(generalize, type)

#*
