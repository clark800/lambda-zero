#* inference.zero

def getAllFreeVariables(metacontext, metacontext')
    indices := (0 ...)[0, metacontext.getSize]
    join(indices.map(MetaVariable(noTag)).map(
        getFreeVariables(metacontext'))).deduplicateBy(isSameHead)


def generalize(metacontext, oldMetacontext, type)
    # generalize over only metavariables newly introduced in the current
    # definition and leave the rest in the type because they may correspond to
    # the types of local variables that haven't yet been determined
    syntax(\\) := syntax(\)
    vs \\ vs' := vs |: (v -> not vs'.any(isSameHead(v)))
    type' := type.substitute(metacontext)
    universals := type'.getFreeVariables(metacontext) \\
        metacontext.getAllFreeVariables(oldMetacontext)
    Scheme(universals, type')


def instantiate(tag, scheme)
    Scheme(_, type) <- renameScheme(scheme)
    lift type.setLocation(tag)


def convertToScheme(term)
    # note: term must be closed
    if term is Intersection(tag, type, body)
        metavariable <- newMetaVariable(tag)
        body' := resolve(Closure(body, newArray([enclose(metavariable)])))
        Scheme(universals, term) <- convertToScheme(body')
        lift Scheme(metavariable :: universals, term)
    lift Scheme([], term)


def peelIntersections(term)
    Scheme(_, term) <- convertToScheme(term)
    lift term


def pushContext(scheme, term, context @ (environment, schemes))
    (environment.push(Closure(term, environment)), schemes.push(scheme))


def metaevaluate(closure @ Closure(term, environment))
    # we have to resolve to a closed term before calling peelIntersections
    term := resolve(evaluateClosure(closure))
    term <- peelIntersections(term)
    lift resolve(evaluateClosure(Closure(term, environment)))


def getDomain(tag, environment)
    case Inferred
        metavariable <- newMetaVariable(tag)
        lift (metavariable, Scheme([], metavariable))
    case Domain(domain)
        domain <- metaevaluate(Closure(domain, environment))
        lift (domain, Scheme([], domain))
    case PatternMatch(domain)
        domain <- metaevaluate(Closure(domain, environment))
        if domain is Construction(_, _, type, _)
            scheme <- convertToScheme(type)
            lift (domain, scheme)
        throwError("expected construction in case annotation", tag)
    case Opaque(type)
        throwError("cannot get domain of instance", tag)


def infer(context @ (environment, schemes))
    case Unknown(tag)
        lift Unknown(tag)
    case MetaVariable(tag, address)
        # todo: check for type in metacontext
        metacontext <- getState
        if metacontext.get(address) ?? Void is Just(term)
            term.infer(context)
        newMetaVariable(tag)
    case Universe(tag, level)
        lift Universe(tag, up level)
    case Variable(tag, index)
        scheme := schemes.seek(index) ?? throwError("unbound variable", tag)
        scheme.instantiate(tag)
    case Function(tag, type, body)
        if type is Opaque(type')
            # type should always be a closed term, so this should be safe
            peelIntersections(type')
        (domain, scheme) <- type.getDomain(tag, environment)
        range <- body.infer(context.pushContext(scheme, Unknown(tag)))
        lift Implication(tag, domain, range)
    case Implication(tag, domain, body)
        domain' := resolve(evaluateClosure(Closure(domain, environment)))
        _ <- body.infer(context.pushContext(Scheme([], domain'), Unknown(tag)))
        lift Universe(tag, 0)
    case Intersection(tag, domain, body)
        domain' := resolve(evaluateClosure(Closure(domain, environment)))
        body.infer(context.pushContext(Scheme([], domain'), Unknown(tag)))
    case Application(tag, applicand, argument)
        metacontext <- getState
        argumentType <- argument.infer(context)
        if applicand is Function(_, type, body)
            if type is Inferred
                # todo: support Domain annotations
                # suppport polymorphism in nested functions
                metacontext' <- getState
                scheme := argumentType.generalize(metacontext', metacontext)
                context' := context.pushContext(scheme, argument)
                body.infer(context')
            pass
        applicandType <- applicand.infer(context)
        returnType <- newMetaVariable(tag)
        applicandTag := getTermTag(applicand)
        functionType := Implication(applicandTag, argumentType, returnType)
        # applicandType <: functionType  =>  argumentType <: parameterType
        _ <- unify(resolve(Closure(applicandType, environment)),
                  resolve(Closure(functionType, environment)))
        lift returnType
    case Construction(tag, parameters, objectType, signatures)
        _ <- signatures.mapState(infer(context))
        lift Universe(tag, 0)
    case Numeral(tag, type, value)
        lift type
    case Operation(tag, term, _)
        term.infer(context)


def getFixScheme(tag)
    syntax(=>>) := syntax(++)
    (=>>) := Implication(tag)
    a := MetaVariable(veil(tag), 0)
    Scheme([a], (a =>> a) =>> a)


def normalize(term)
    # todo: evaluateTerm will return Unknown for variables inside binders
    resolve(evaluateTerm(term)).mapComponents(normalize)


def inferType(schemes, Binding(tag, closure @ Closure(term, environment)))
    if getTagLexeme(tag) =*= "fix"
        schemes.push(getFixScheme(tag))
    metacontext := newArray([])
    context := (environment, schemes)
    (type, metacontext') := infer(context, term, metacontext)
    type' := normalize(resolve(Closure(type, environment)))
    schemes.push(type'.generalize(metacontext', metacontext))


def main(input)
    bindings := reverse(parse(getBuiltin, input))
    schemes := bindings.cascade(inferType, newArray([]))
    tags := bindings.map(getBindingTag)
    showTypings(zip(tags, schemes.toList))

#*
