#* inference.zero

def pushContext(type, term, context @ (environment, types))
    (environment.push(Closure(term, environment)), types.push(type))


def getDomain(tag, environment)
    case Inferred
        metavariable <- newPositiveMetaVariable(tag)
        lift (metavariable, metavariable)
    case Domain(domain)
        domain := resolve(evaluateClosure(Closure(domain, environment)))
        lift (domain, domain)
    case PatternMatch(domain)
        outerDomain <- instantiateClosure(Closure(domain, environment))
        if outerDomain is Construction(_, _, innerDomain, _)
            lift (outerDomain, innerDomain)
        throwError("expected construction in pattern match annotation", tag)
    case Opaque(type)
        throwError("cannot get domain of instance", tag)


def infer(context @ (environment, types))
    case Unknown(tag)
        lift Unknown(tag)
    case MetaVariable(tag, index)
        # todo: check for annotated type in metacontext
        throwError("not implemented", tag)
    case Universe(tag, level)
        lift Universe(tag, up level)
    case Variable(tag, index)
        type := types.seek(index) ?? throwError("unbound variable", tag)
        instantiateAll(type)  # todo: remove this after implementing subtyping
    case Function(tag, type, body)
        if type is Opaque(type')
            instantiateClosure(Closure(type', environment))
        (outerDomain, innerDomain) <- type.getDomain(tag, environment)
        range <- body.infer(context.pushContext(innerDomain, Unknown(tag)))
        lift Implication(tag, outerDomain, range)
    case Implication(tag, domain, body)
        domain' := resolve(evaluateClosure(Closure(domain, environment)))
        _ <- body.infer(context.pushContext(domain', Unknown(tag)))
        lift Universe(tag, 0)
    case Intersection(tag, domain, body)
        domain' := resolve(evaluateClosure(Closure(domain, environment)))
        body.infer(context.pushContext(domain', Unknown(tag)))
    case Application(tag, applicand, argument)
        metacontext <- getState
        argumentType <- argument.infer(context)
        if applicand is Function(_, type, body)
            if type is Inferred
                # todo: support Domain annotations
                # suppport polymorphism in nested functions
                metacontext' <- getState
                type' := argumentType.generalizeAll(metacontext', metacontext)
                body.infer(context.pushContext(type', argument))
            pass
        applicandType <- applicand.infer(context)
        returnType <- newPositiveMetaVariable(tag)
        applicandTag := getTermTag(applicand)
        functionType := Implication(applicandTag, argumentType, returnType)
        # applicandType <: functionType  =>  argumentType <: parameterType
        _ <- unify(resolve(Closure(applicandType, environment)),
                  resolve(Closure(functionType, environment)))
        lift returnType
    case Construction(tag, parameters, objectType, signatures)
        _ <- signatures.mapState(infer(context))
        lift Universe(tag, 0)
    case Numeral(tag, type, value)
        lift type
    case Operation(tag, term, _)
        term.infer(context)


def getFixType(tag)
    syntax(=>>) := syntax(++)
    tag := renameTag(tag, "a", NOFIX)
    (=>>) := Implication(veil(tag))
    a1 := Variable(tag, -_ 1)
    a2 := Variable(tag, -_ 2)
    Intersection(tag, Universe(veil(tag), 0), (a1 =>> a2) =>> a2)


def normalize(term)
    # todo: evaluateTerm will return Unknown for variables inside binders
    resolve(evaluateTerm(term)).mapComponents(normalize)


def inferType(types, Binding(tag, closure @ Closure(term, environment)))
    if getTagLexeme(tag) =*= "fix"
        types.push(getFixType(tag))
    metacontext := emptyMetacontext
    context := (environment, types)
    (type, metacontext') := infer(context, term, metacontext)
    type := normalize(resolve(Closure(type, environment)))
    types.push(type.generalizeAll(metacontext', metacontext))


def showType(type)
    if type is Intersection(tag, _, body)
        "âˆ€" ++ showTag(tag) ++ " " ++ showType(body)
    showTerm(type)


def showTyping((tag, type))
    showTag(tag) ++ " : " ++ showType(type)


def showTypings(typings)
    typings.map(showTyping).joinWith("\n") ++ "\n"


def main(input)
    bindings := reverse(parse(getBuiltin, input))
    types := bindings.cascade(inferType, newArray([]))
    tags := bindings.map(getBindingTag)
    showTypings(zip(tags, types.toList))

#*
