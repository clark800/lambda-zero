#* inference.zero

def pushContext(term, scheme, context @ (terms, schemes))
    # TODO: replace schemes with an array of closures of types
    (terms.push(Closure(term, terms)), schemes.push(scheme))


def pushParameter(scheme, context)
    pushContext(Unknown, scheme, context)


def getAllFreeVariables(metacontext, metacontext')
    indices := (0 ...)[0, metacontext.getSize]
    join(indices.map(MetaVariable(noTag)).map(
        getFreeVariables(metacontext'))).deduplicateBy(sameHead)


def generalize(metacontext, oldMetacontext, type)
    syntax(\\) := syntax(\)
    vs \\ vs' := vs |: (v -> not vs'.any(sameHead(v)))
    type' := type.substitute(metacontext)
    universals := type'.getFreeVariables(metacontext) \\
        metacontext.getAllFreeVariables(oldMetacontext)
    Scheme(universals, type')


def newInstantiationMapping(universals, metacontext)
    tags := universals.map(getTermTag)
    (metaVariables, metacontext') := newMetaVariables(tags, metacontext)
    addresses := universals.map(maybeAddress).prune
    mapping := newMapping(zip(addresses, metaVariables))
    (mapping, metacontext')


def instantiate(tag, metacontext, Scheme(universals, type))
    (mapping, metacontext') := newInstantiationMapping(universals, metacontext)
    (type.applyMapping(mapping).setLocation(tag), metacontext')


def getInnerScheme(tag, outerType, environment)
    _ @ Closure(construction, environment') :=
        evaluateClosure(Closure(outerType, environment))
    if construction is Construction(_, _, type, _)
        universals := type.getFreeVariables(newArray([]))
        Scheme(universals, flattenClosure(Closure(type, environment')))
    throwError("expected construction in case annotation", tag)


def unifyCodomain(codomain, bodyType, context, metacontext)
    if isWildcard(codomain)
        (bodyType, metacontext)
    metacontext' := unify(context, metacontext, (codomain, bodyType))
    if getSize(metacontext') < 0  # todo: remove this when unify returns Either
        abort("force unification errors")
    (codomain, metacontext')


def infer(context @ (environment, types), metacontext)
    case Wildcard(tag)
        (Wildcard(tag), metacontext)
    case Top(tag)
        (Top(tag), metacontext)
    case Constant(tag, index)
        scheme := types.get(index) ?? throwError("unbound constant", tag)
        scheme.instantiate(tag, metacontext)
    case Variable(tag, debruijn)
        scheme := types.peek(debruijn -- 1) ??
            throwError("unbound variable", tag)
        scheme.instantiate(tag, metacontext)
    case MetaVariable(tag, address)
        # todo: check for type in metacontext
        if metacontext.get(address) ?? Void is Just(Closure(term, _))
            infer(context, metacontext, term)
        newMetaVariable(tag, metacontext)
    case Function(tag, isCase, domain, codomain, body)
        parameterScheme := if isCase then
            getInnerScheme(tag, domain, environment) else Scheme([], domain)
        # todo: type may contain variables which would get lost here
        context' := context.pushParameter(parameterScheme)
        (bodyType, metacontext) := infer(context', metacontext, body)
        (codomain, metacontext) :=
            unifyCodomain(codomain, bodyType, context, metacontext)
        (Implication(tag, domain, codomain), metacontext)
    case Implication(tag, type, body)
        context' := context.pushParameter(Scheme([], type))
        infer(context', metacontext, body).mapFirst(_ -> Top(veil(tag)))
    case Application(tag, applicand, argument)
        (argumentType, metacontext') := infer(context, metacontext, argument)
        if applicand is Function(_, isCase, domain, codomain, body)
            if not isCase and isMetaVariable(domain)
                # suppport polymorphism in nested functions
                scheme := argumentType.generalize(metacontext', metacontext)
                context' := context.pushParameter(scheme)
                infer(context', metacontext', body)
            pass
        (applicandType, metacontext'') :=
            infer(context, metacontext', applicand)
        (returnType, metacontext''') := metacontext''.newMetaVariable(tag)
        applicandTag := getTermTag(applicand)
        functionType := Implication(applicandTag, argumentType, returnType)
        (returnType, unify(context, metacontext''',
            (applicandType, functionType)))
    case Construction(tag, parameters, objectType, signatures)
        metacontext' := signatures.cascade(m -> s ->
            second(infer(context, m, s)), metacontext)
        (Top(veil(tag)), metacontext')
    case Element(tag, type, term)
        (type, metacontext)
    case Numeral(tag, type, value)
        (type, metacontext)
    case Operation(tag, type, _, _)
        (type, metacontext)


def getFixScheme(tag)
    syntax(>->) := syntax(++)
    (>->) := Implication(tag)
    a := MetaVariable(veil(tag), 0)
    Scheme([a], (a >-> a) >-> a)


def inferType(context, Binding(tag, MetaClosure(metacontext, closure)))
    term := getTerm(closure)
    if getTagLexeme(tag) =*= "fix"
        context.pushContext(term, getFixScheme(getTermTag(term)))
    (type, metacontext') := infer(context, metacontext, term)
    scheme := type.generalize(metacontext', newArray([]))
    context.pushContext(term, scheme)


def main(input)
    bindings := reverse(parse(getBuiltin, input))
    context := (newArray([]), newArray([])) # environment and schemes
    context' := bindings.cascade(inferType, context)
    schemes := second(context').toList
    tags := bindings.map(getBindingTag)
    showTypings(zip(tags, schemes))

#*
