#* inference.zero

def getAllFreeVariables(metacontext, metacontext')
    indices := (0 ...)[0, metacontext.getSize]
    join(indices.map(MetaVariable(noTag)).map(
        getFreeVariables(metacontext'))).deduplicateBy(isSameHead)


def generalize(metacontext, oldMetacontext, type)
    # generalize over only metavariables newly introduced in the current
    # definition and leave the rest in the type because they may correspond to
    # the types of local variables that haven't yet been determined
    syntax(\\) := syntax(\)
    vs \\ vs' := vs |: (v -> not vs'.any(isSameHead(v)))
    type' := type.substitute(metacontext)
    universals := type'.getFreeVariables(metacontext) \\
        metacontext.getAllFreeVariables(oldMetacontext)
    Scheme(universals, type')


def instantiate(tag, metacontext, scheme)
    (Scheme(_, type), metacontext') := renameScheme(scheme, metacontext)
    (type.setLocation(tag), metacontext')


def getParameterScheme(tag, isCase, domain, metacontext)
    if isCase
        if getTerm(domain) is Construction(_, _, type, _)
            # we have to be careful to not resolve type until after we
            # rename it or we'll get a collision with the metavariable
            # for the return type in type.
            scheme := Scheme(type.getFreeVariables(newArray([])), type)
            (scheme', metacontext') := renameScheme(scheme, metacontext)
            _ @ Scheme(universals, type') := scheme'
            type'' := resolve(Closure(type', getEnvironment(domain)))
            (Scheme(universals, type''), metacontext')
        throwError("expected construction in case annotation", tag)
    (Scheme([], resolve(domain)), metacontext)


def unifyCodomain(codomain, bodyType, environment, metacontext)
    if isWildcard(codomain)
        (bodyType, metacontext)
    metacontext' := unify(environment, metacontext, (codomain, bodyType))
    if getSize(metacontext') < 0  # todo: remove this when unify returns Either
        abort("force unification errors")
    (codomain, metacontext')


def infer(schemes, metacontext, closure @ Closure(term, environment))
    match term
    case Unknown(tag)
        (term, metacontext)
    case Wildcard(tag)
        (term, metacontext)
    case MetaVariable(tag, address)
        # todo: check for type in metacontext
        if metacontext.get(address) ?? Void is Just(closure')
            infer(schemes, metacontext, closure')
        newMetaVariable(tag, metacontext)
    case Universe(tag, level)
        (Universe(tag, up level), metacontext)
    case Constant(tag, index)
        scheme := schemes.get(index) ?? throwError("unbound constant", tag)
        scheme.instantiate(tag, metacontext)
    case Variable(tag, index)
        scheme := schemes.peek(index -- 1) ??
            throwError("unbound variable", tag)
        scheme.instantiate(tag, metacontext)
    case Function(tag, isCase, domain, codomain, body)
        domain' := evaluateClosure(Closure(domain, environment))
        (scheme, metacontext) :=
            getParameterScheme(tag, isCase, domain', metacontext)
        schemes' := schemes.push(scheme)
        bodyClosure := Closure(body, pushUnknown(tag, environment))
        (bodyType, metacontext) := infer(schemes', metacontext, bodyClosure)
        (codomain, metacontext) :=
            unifyCodomain(codomain, bodyType, environment, metacontext)
        (Implication(tag, domain, codomain), metacontext)
    case Implication(tag, type, body)
        type' := resolve(evaluateClosure(Closure(type, environment)))
        schemes' := schemes.push(Scheme([], type'))
        bodyClosure := Closure(body, pushUnknown(tag, environment))
        (_, metacontext') := infer(schemes', metacontext, bodyClosure)
        (Universe(tag, 1), metacontext')
    case Application(tag, applicand, argument)
        argument' := Closure(argument, environment)
        applicand' := Closure(applicand, environment)
        (argumentType, metacontext') := infer(schemes, metacontext, argument')
        if applicand is Function(_, isCase, domain, codomain, body)
            if not isCase and isMetaVariable(domain)
                # suppport polymorphism in nested functions
                scheme := argumentType.generalize(metacontext', metacontext)
                body' := Closure(body, environment.push(argument'))
                infer(schemes.push(scheme), metacontext', body')
            pass
        (applicandType, metacontext) := infer(schemes, metacontext', applicand')
        (returnType, metacontext) := metacontext.newMetaVariable(tag)
        applicandTag := getTermTag(applicand)
        functionType := Implication(applicandTag, argumentType, returnType)
        (returnType, unify(environment, metacontext,
            (applicandType, functionType)))
    case Construction(tag, parameters, objectType, signatures)
        metacontext' := signatures.cascade(m -> s ->
            second(infer(schemes, m, Closure(s, environment))), metacontext)
        (Universe(tag, 1), metacontext')
    case Element(tag, type, term)
        (type, metacontext)
    case Numeral(tag, type, value)
        (type, metacontext)
    case Operation(tag, type, _, _)
        (type, metacontext)


def getFixScheme(tag)
    syntax(>->) := syntax(++)
    (>->) := Implication(tag)
    a := MetaVariable(veil(tag), 0)
    Scheme([a], (a >-> a) >-> a)


def inferType(schemes, Binding(tag, MetaClosure(metacontext, closure)))
    if getTagLexeme(tag) =*= "fix"
        schemes.push(getFixScheme(tag))
    (type, metacontext') := infer(schemes, metacontext, closure)
    schemes.push(type.generalize(metacontext', newArray([])))


def main(input)
    bindings := reverse(parse(getBuiltin, input))
    schemes := bindings.cascade(inferType, newArray([]))
    tags := bindings.map(getBindingTag)
    showTypings(zip(tags, schemes.toList))

#*
