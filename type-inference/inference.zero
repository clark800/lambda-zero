#* inference.zero

def pushContext(type, term, context @ (environment, types))
    (environment.push(Closure(term, environment)), types.push(type))


def instantiate(closure @ Closure(term, environment))
    if term is Intersection(tag, _, body)
        if isConstruction(term)
            lift closure
        metavariable <- newPositiveMetavariable(tag)
        instantiate(Closure(body, environment.push(enclose(metavariable))))
    lift closure


def convertFunctionsToIntersections(term)
    if term is Function(tag, domain, body)
        Intersection(tag, domain, convertFunctionsToIntersections(body))
    term


def getPatternMatchDomain(Closure(typeConstructor, environment))
    term := convertFunctionsToIntersections(typeConstructor)
    closure <- instantiate(Closure(term, environment))
    lift evaluateClosure(closure)  # evaluate application of type constructor


def getTypeConstructor(construction, environment)
    if getConstructionTypeFamily(construction) is Just(family)
        if family is Type(tag, index)
            if index is -_ n
                environment.get(n)
            Void
        Void
    Void


def instantiateConstruction(closure, environment)
    _ @ Closure(construction, environment') := evaluateClosure(closure)
    if getTypeConstructor(construction, environment) is Just(typeConstructor)
        if construction is Intersection(_, _, body)
            instantiate(Closure(body, environment'.push(typeConstructor)))
        throwError("expected intersection", getTermTag(construction))
    throwError("expected construction", getTermTag(construction))


def getDomain(closure @ Closure(domain, environment))
    if domain is Type(tag, index)
        if index is -_ n
            if environment.get(n) is Just(typeConstructor)
                getPatternMatchDomain(typeConstructor)
            throwError("undefined type family", tag)
        lift closure
    if isUnknown(domain)
        metavariable <- newPositiveMetavariable(getTermTag(domain))
        lift enclose(metavariable)
    lift closure


def newFunctionType(tag, domainClosure, body)
    _ @ Closure(domain, environment) := domainClosure
    Closure(Implication(tag, domain, body), environment)


def infer(context @ (environment, types))
    enclose'(term) := Closure(term, environment)

    case Metavariable(tag, index)
        # todo: check for annotated type in metacontext
        throwError("not implemented", tag)
    case Type(tag, index)
        match index
            +_ level -> lift enclose(Type(tag, +_(up level)))
            -_ family -> lift enclose(Type(tag, +_ 1))
    case Variable(tag, index)
        type := types.seek(-_ abs(index)) ?? throwError("unbound variable", tag)
        if isNegative(index)
            instantiateConstruction(type, environment)
        instantiate(type)
    case Singleton(tag, type, element)
        type.infer(context)   # todo: support unknown type, verify type
    case Function(tag, domain, body)
        domainClosure <- getDomain(enclose'(domain))
        argument <- newNegativeMetavariable(tag)
        range <- body.infer(context.pushContext(domainClosure, argument))
        codomain <- addPositiveMetavariable(tag, range)
        lift newFunctionType(tag, domainClosure, codomain)
    case Implication(tag, domain, body)
        argument <- newNegativeMetavariable(tag)
        _ <- body.infer(context.pushContext(enclose'(domain), argument))
        lift enclose(Type(tag, +_ 0))
    case Intersection(tag, domain, body)
        if getConstructionTypeFamily(this) is Just(family)
            lift enclose'(family)
        argument <- newNegativeMetavariable(tag)
        _ <- body.infer(context.pushContext(enclose'(domain), argument))
        lift enclose(Type(tag, +_ 0))
    case Application(tag, applicand, argument)
        argumentType <- argument.infer(context)
        if applicand is Function(tag', domain, body)
            # handle local definitions specially so that we have argument in env
            if isUnknown(domain)  # avoid creating unnecessary metavariable
                body.infer(context.pushContext(argumentType, argument))
            domainClosure <- getDomain(enclose'(domain))
            _ <- unify(argumentType, domainClosure)
            body.infer(context.pushContext(domainClosure, argument))
        applicandType <- applicand.infer(context)
        returnType <- newPositiveMetavariable(tag)
        tag := getTermTag(applicand)
        functionType := newFunctionType(tag, argumentType, returnType)
        # applicandType <: functionType  =>  argumentType <: parameterType
        _ <- unify(applicandType, functionType)
        lift enclose(returnType)
    case Numeral(tag, type, value)
        lift enclose'(type)
    case Operation(tag, term, _)
        term.infer(context)


def getFixType(tag)
    syntax(=>>) := syntax(++)
    tag := renameTag(tag, "a", NOFIX)
    (=>>) := Implication(veil(tag))
    a1 := Variable(tag, +_ 1)
    a2 := Variable(tag, +_ 2)
    Intersection(tag, Type(veil(tag), +_ 0), (a1 =>> a2) =>> a2)


def renameUniversals(closure)
    (closure', metacontext) := instantiate(closure, emptyMetacontext)
    closure'.generalize(metacontext)


def inferType(types, Binding(tag, closure, annotation, isConstruct))
    if getTagLexeme(tag) =*= "fix"
        types.push(enclose(getFixType(tag)))
    if annotation is Just(type)
        if isConstruct  # skip inference for constructors and deconstructors
            types.push(enclose(renameUniversals(type)))
        pass
    _ @ Closure(term, environment) := closure
    context := (environment, types)
    (type, metacontext) := infer(context, term, emptyMetacontext)
    if annotation is Just(type')
        (_, metacontext') := unify(type, type', metacontext)
        types.push(enclose(type.generalize(metacontext')))
    types.push(enclose(type.generalize(metacontext)))


def showTyping((tag, type))
    showTag(tag) ++ " : " ++ showClosure(type)


def showTypings(typings)
    typings.map(showTyping).joinWith("\n") ++ "\n"


def main(input)
    bindings := reverse(parse(getBuiltin, input))
    types := bindings.cascade(inferType, newArray([]))
    tags := bindings.map(getBindingTag)
    showTypings(zip(tags, types.toList))

#*
