#* inference.zero

define getFreeVariables(type, variables)
    if isTypeVariable(type)
        if type.isFree(variables)
            [type]
        getFreeVariables(variables.get(type, undefined), variables)
    join(getComponentTypes(type).map(`getFreeVariables(variables))).
        deduplicateBy((=~=))

define getAllFreeVariables(variables, variables')
    join(variables.getKeys.map(`getFreeVariables(variables'))).
        deduplicateBy((=~=))

define substitute(type, variables)
    if isTypeVariable(type)
        if type.isFree(variables)
            type
        type' := variables.get(type, undefined).setSource(getSource(type))
        if type'.getFreeVariables(empty).any((=~= type))
            recursionError(type, type, variables)
        type'.substitute(variables)

    type.mapComponents(`substitute(variables))

# Robinson's Unification Algorithm
# see Comparing Unification Algorithms in First-Order Theorem Proving
# by Krystof Hoder and Andrei Voronkov
define unify'(originals, variables, (left, right))
    if isTypeVariable(left) and not left.isFree(variables)
        unify'(originals, variables, (left.substitute(variables), right))
    if isTypeVariable(right) and not right.isFree(variables)
        unify'(originals, variables, (left, right.substitute(variables)))
    if isBottomType(left) or isBottomType(right)
        variables
    if left =~= right
        variables
    if isTypeVariable(left)
        variables.insert(left, right)
    if isTypeVariable(right)
        variables.insert(right, left)
    if (getTypeCode(left) = getTypeCode(right) and
        getIndex(left) = getIndex(right) and
        length(getComponentTypes(left)) = length(getComponentTypes(right)))
        zip(getComponentTypes(left), getComponentTypes(right)).
            cascade(unify'(originals), variables)
    unificationError(originals.mapPair(`substitute(variables)),
        left.substitute(variables), right.substitute(variables))

define unify(variables, types)
    unify'(types, variables, types)

define unifyAll(variables, types)
    if isNil(types)
        variables
    zip(repeat(head(types)), tail(types)).cascade(unify, variables)

define generalize(type, variables, oldVariables)
    syntax(\\) := infix(17)
    vs \\ vs' := vs |: (v -> not vs'.any((=~= v)))
    type' := type.substitute(variables)
    universals := type'.getFreeVariables(variables) \\
        oldVariables.getAllFreeVariables(variables)
    newScheme(universals, type')

define instantiate(scheme, variables, term)
    (universals, type) := scheme
    (freshVariables, variables') := newTypeVariables(universals, variables)
    renaming := newVariableMap(zip(universals, freshVariables))
    (type.rename(renaming).setSource(term), variables')


define isFix(term)
    isReference(term) and getTagLexeme(getTermTag(term)) =*= "fix"


# stack is a list of type schemes for all the lambda-bound symbols in scope
# variables is a table that maps type variables to types (either type
#   variables or concrete types); every type variable appears in variables
define infer(stack, variables)
    case term @ Reference(_, debruijn)
        stack[debruijn - 1].instantiate(variables, term)
    case term @ Function(_, body)
        (parameterType, variables') := variables.newTypeVariable(term)
        stack' := newScheme([], parameterType) :: stack
        (bodyType, variables'') := infer(stack', variables', body)
        (newFunctionType(term, parameterType, bodyType), variables'')
    case term @ Application(left, right)
        if isFunction(left)     # treat this as a let
            (valueType, variables') := infer(stack, variables, right)
            stack' := valueType.generalize(variables', variables) :: stack
            infer(stack', variables', getFunctionBody(left))
        if isFix(left) and isFunction(right)
            function := getFunctionBody(right)
            (functionType, variables') := variables.newTypeVariable(term)
            stack' := newScheme([], functionType) :: stack
            (functionType', variables'') := infer(stack', variables', function)
            (functionType, variables''.unify((functionType', functionType)))
        (rightType, variables') := infer(stack, variables, right)
        (leftType, variables'') := infer(stack, variables', left)
        (returnType, variables''') := variables''.newTypeVariable(term)
        functionType := newFunctionType(noTerm, rightType, returnType)
        (returnType, variables'''.unify((leftType, functionType)))
    case term @ Natural(_, _)
        (newNaturalType(term), variables)
    case term @ Optimization(_)
        (getBuiltinType(term), variables)


define inferType(stack, definition)
    (tag, value) := definition
    knownTypeScheme := getKnownTypeScheme(getTagLexeme(tag), value)
    if not isFreeType(second(knownTypeScheme))
        knownTypeScheme :: stack
    (type, variables') := infer(stack, empty, value)
    type.generalize(variables', empty) :: stack


define main(input)
    term := parse(input)
    definitions := getDefinitions(term)
    schemes := reverse(definitions.cascade(inferType, []))
    (names, _) := unzip(definitions)
    showTypings(zip(names, schemes))

#*
