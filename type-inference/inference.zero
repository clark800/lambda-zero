#* inference.zero

define getValue(type, variables)
    with type as MetaVariable(_, address)
        with variables.access(address) ?? Void as Just(type')
            type'
        throwError("internal error", getTermTag(type))
    type


define isFree(variable, variables)
    with variable as MetaVariable(_, address)
        isVoid(variables.access(address) ?? Void)
    False


define getFreeVariables(variables, type)
    with type as MetaVariable(_, address)
        with variables.access(address) ?? Void as Just(type')
            getFreeVariables(variables, type')
        [type]
    join(getComponents(type).map(getFreeVariables(variables))).
        deduplicateBy(sameHead)


define getAllFreeVariables(variables, variables')
    join(variables.dump.map(first).map(MetaVariable(noTag)).map(
        getFreeVariables(variables'))).deduplicateBy(sameHead)


define substitute(variables, type)
    with type as MetaVariable(tag, address)
        with variables.access(address) ?? Void as Just(type')
            type'' := type'.setLocation(tag)
            if type''.getFreeVariables(newStore([])).any(sameHead(type))
                recursionError(type, type, variables)
            type''.substitute(variables)
        type
    type.mapComponents(substitute(variables))


define unifyFailure(originals, variables, (left, right))
    unificationError(originals.mapPair(substitute(variables)),
        left.substitute(variables), right.substitute(variables))


# Robinson's Unification Algorithm
# see Comparing Unification Algorithms in First-Order Theorem Proving
# by Krystof Hoder and Andrei Voronkov
define unify'(originals, variables, (left, right))
    if isMetaVariable(left) and not isFree(left, variables)
        unify'(originals, variables, (variables.getValue(left), right))
    if isMetaVariable(right) and not isFree(right, variables)
        unify'(originals, variables, (left, variables.getValue(right)))
    if sameHead(left, right)
        zip(getComponents(left), getComponents(right)).
            cascade(unify'(originals), variables)
    with left as MetaVariable(_, address)
        variables.assign(address, Just(right))
    with right as MetaVariable(_, address)
        variables.assign(address, Just(left))
    unifyFailure(originals, variables, (left, right))


define unify(variables, types)
    unify'(types, variables, types)


define unifyAll(variables, types)
    with types as type :: types'
        zip(repeat(type), types').cascade(unify, variables)
    variables


define generalize(variables, oldVariables, type)
    syntax(\\) := syntax(\)
    vs \\ vs' := vs |: (v -> not vs'.any(sameHead(v)))
    type' := type.substitute(variables)
    universals := type'.getFreeVariables(variables) \\
        variables.getAllFreeVariables(oldVariables)
    Scheme(universals, type')


define newInstantiationMap(universals, variables)
    (freshVariables, variables') := newMetaVariables(universals, variables)
    addresses := universals.map(maybeAddress).prune
    renaming := newRenaming(zip(addresses, freshVariables))
    (renaming, variables')


define instantiateType(tag, mapping, type)
    type.rename(mapping).setLocation(tag)


define coinstantiate(tag, variables, schemes)
    (Scheme(universalsA, typeA), Scheme(universalsB, typeB)) := schemes
    universals := universalsB ++ universalsA
    (mapping, variables') := newInstantiationMap(universals, variables)
    (typeA', typeB') := (typeA, typeB).mapPair(instantiateType(tag, mapping))
    universals' := universalsB.map(instantiateType(tag, mapping))
    (typeA', Scheme(universals', typeB'), variables')


define instantiate(tag, variables, Scheme(universals, type))
    (mapping, variables') := newInstantiationMap(universals, variables)
    (type.instantiateType(tag, mapping), variables')


# stack is a list of type schemes for all the lambda-bound symbols in scope
# variables is a table that maps type variables to types (either type
#   variables or concrete types); every type variable appears in variables
define infer(stack, variables)
    case Top(tag)
        (Top(tag), variables)
    case Variable(tag, debruijn)
        scheme := stack.seek(debruijn -- 1) ??
            throwError("unbound variable", tag)
        scheme.instantiate(tag, variables)
    case MetaVariable(tag, address)
        with variables.access(address) ?? Void as Just(term)
            infer(stack, variables, term)
        newMetaVariable(tag, variables)
    case Abstraction(tag, constraint, body)
        match constraint
            case Ascription(scheme)
                scheme.instantiate(tag, variables)
            case Annotation(scheme)
                (parameterType, variables') :=
                    scheme.instantiate(tag, variables)
                stack' := stack.push(Scheme([], parameterType))
                (bodyType, variables'') := infer(stack', variables', body)
                (Implication(tag, parameterType, bodyType), variables'')
            case PolarAnnotation(outerScheme, innerScheme)
                (outerType, innerScheme, variables') :=
                    coinstantiate(tag, variables, (outerScheme, innerScheme))
                (bodyType, variables'') :=
                    infer(stack.push(innerScheme), variables', body)
                (Implication(tag, outerType, bodyType), variables'')
    case Implication(tag, parameter, body)
        (Top(veil(tag)), variables)
    case Application(tag, isLet, applicand, argument)
        if isLet
            (valueType, variables') := infer(stack, variables, argument)
            stack' := stack.push(valueType.generalize(variables', variables))
            with applicand as Abstraction(_, _, body)
                infer(stack', variables', body)
            infer(stack, variables,
                Application(tag, False, applicand, argument))
        (argumentType, variables') := infer(stack, variables, argument)
        (applicandType, variables'') := infer(stack, variables', applicand)
        (returnType, variables''') := variables''.newMetaVariable(tag)
        applicandTag := getTermTag(applicand)
        functionType := Implication(applicandTag, argumentType, returnType)
        (returnType, unify(variables''', (applicandType, functionType)))
    case Construction(tag, _)
        (Top(veil(tag)), variables)
    case Numeral(tag, type, value)
        (type, variables)
    case Operation(tag, type, _, _)
        getBuiltinType(tag, variables)


define inferType(stack, definition)
    if getTagLexeme(first(definition)) =*= "fix"
        stack.push(getFixScheme(getTermTag(second(definition))))
    (type, variables') := infer(stack, newStore([]), second(definition))
    stack.push(type.generalize(variables', newStore([])))


define getDefinitions(term)
    with term as Application(_, isLet, applicand, argument)
        if isLet
            with applicand as Abstraction(_, _, body)
                (getTermTag(applicand), argument) :: getDefinitions(body)
            []
        []
    []


define main(input)
    term := parse(input)
    definitions := getDefinitions(term)
    stack := definitions.cascade(inferType, newRandomAccessList([]))
    schemes := stack.getList.reverse
    (names, _) := unzip(definitions)
    showTypings(zip(names, schemes))

#*
