#* inference.zero

def pushContext(type, term, context @ (environment, types))
    (environment.push(Closure(term, environment)), types.push(type))


def convertFunctionsToIntersections(term)
    if term is Function(tag, domain, body)
        Intersection(tag, domain, convertFunctionsToIntersections(body))
    term


def getPatternMatchDomain(closure @ Closure(typeConstructor, environment))
    term := convertFunctionsToIntersections(typeConstructor)
    outerDomain <- instantiateClosure(Closure(term, environment))
    if outerDomain is Intersection(_, _, body)
        innerDomain := resolveClosure(Closure(body, environment.push(closure)))
        lift (outerDomain, innerDomain)
    throwError("invalid type family", getTermTag(typeConstructor))


def getDomain(environment, domain)
    if isUnknown(domain)
        metavariable <- newPositiveMetaVariable(getTermTag(domain))
        lift (metavariable, metavariable)
    if domain is Type(tag, index)
        if index is -_ n
            if environment.get(n) is Just(closure)
                getPatternMatchDomain(closure)
            throwError("undefined type family", tag)
        lift (domain, domain)
    closure := Closure(domain, environment)
    domain := resolveClosure(evaluateClosure(closure))
    lift (domain, domain)


def infer(context @ (environment, types))
    case MetaVariable(tag, index)
        # todo: check for annotated type in metacontext
        throwError("not implemented", tag)
    case Type(tag, index)
        match index
            +_ level -> lift Type(tag, +_(up level))
            -_ family -> lift Type(tag, +_ 1)
    case Variable(tag, index)
        type := types.seek(index) ?? throwError("unbound variable", tag)
        instantiateAll(type)  # todo: remove this after implementing subtyping
    case Singleton(tag, type, index)
        lift Type(tag, +_ 0)
    case Function(tag, domain, body)
        (outerDomain, innerDomain) <- domain.getDomain(environment)
        range <- body.infer(context.pushContext(innerDomain, Unknown(tag)))
        lift Implication(tag, outerDomain, range)
    case Implication(tag, domain, body)
        domain' := resolveClosure(evaluateClosure(Closure(domain, environment)))
        _ <- body.infer(context.pushContext(domain', Unknown(tag)))
        lift Type(tag, +_ 0)
    case Intersection(tag, domain, body)
        domain' := resolveClosure(evaluateClosure(Closure(domain, environment)))
        body.infer(context.pushContext(domain', Unknown(tag)))
    case Application(tag, applicand, argument)
        argumentType <- argument.infer(context)
        if applicand is Function(tag', domain, body)
            # handle local definitions specially so that we have argument in env
            (outerDomain, innerDomain) <- domain.getDomain(environment)
            _ <- unify(Closure(argumentType, environment),
                      Closure(outerDomain, environment))
            body.infer(context.pushContext(innerDomain, argument))
        applicandType <- applicand.infer(context)
        returnType <- newPositiveMetaVariable(tag)
        applicandTag := getTermTag(applicand)
        functionType := Implication(applicandTag, argumentType, returnType)
        # applicandType <: functionType  =>  argumentType <: parameterType
        _ <- unify(Closure(applicandType, environment),
                  Closure(functionType, environment))
        lift returnType
    case Numeral(tag, type, value)
        lift type
    case Operation(tag, term, _)
        term.infer(context)


def getFixType(tag)
    syntax(=>>) := syntax(++)
    tag := renameTag(tag, "a", NOFIX)
    (=>>) := Implication(veil(tag))
    a1 := Variable(tag, -_ 1)
    a2 := Variable(tag, -_ 2)
    Intersection(tag, Type(veil(tag), +_ 0), (a1 =>> a2) =>> a2)


def reduceTerm(term)
    if term is Application(tag, left, right)
        left' := reduceTerm(left)
        right' := reduceTerm(right)
        if left' is Function(tag', domain, body)
            reduceTerm(substituteArgument(right', body))
        Application(tag, left', right')
    term


def normalize(term)
    reduceTerm(term).mapComponents(normalize)


def renameUniversals(closure)
    term := closure.resolve(emptyMetacontext)
    (term', metacontext) := instantiateAll(term, emptyMetacontext)
    normalize(enclose(term').generalize(metacontext))


def inferType(types, Binding(tag, closure, ascription))
    if getTagLexeme(tag) =*= "fix"
        types.push(getFixType(tag))
    if ascription is Just(closure)
        types.push(renameUniversals(closure))
    _ @ Closure(term, environment) := closure
    context := (environment, types)
    (type, metacontext) := infer(context, term, emptyMetacontext)
    type' := Closure(type, environment).generalize(metacontext)
    types.push(normalize(type'))


def showType(type)
    if type is Intersection(tag, domain, body)
        if isSingleton(domain)
            showTerm(type)
        "âˆ€" ++ showTag(tag) ++ " " ++ showType(body)
    showTerm(type)


def showTyping((tag, type))
    showTag(tag) ++ " : " ++ showType(type)


def showTypings(typings)
    typings.map(showTyping).joinWith("\n") ++ "\n"


def main(input)
    bindings := reverse(parse(getBuiltin, input))
    types := bindings.cascade(inferType, newArray([]))
    tags := bindings.map(getBindingTag)
    showTypings(zip(tags, types.toList))

#*
