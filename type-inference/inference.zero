#* inference.zero

def pushContext(type, term, context @ (environment, types))
    (environment.push(Closure(term, environment)), types.push(type))


def newInstantiationMetavariable(tag, domainClosure)
    _ @ Closure(domain, environment) := evaluateClosure(domainClosure)
    if isType(domain) or isSingleton(domain) or isConstruction(domain)
        # TODO: verify construction is non-empty
        newPositiveMetavariable(tag)
    if domain is Equation(_, left, right)
        _ <- unify(Closure(left, environment), Closure(right, environment))
        newPositiveMetavariable(tag)
    throwError("cannot determine that domain is nonempty", getTermTag(domain))


def instantiateWith(newMetavariable, closure @ Closure(term, environment))
    if term is Intersection(tag, domain, body)
        metavariable <- newMetavariable(tag, Closure(domain, environment))
        closure' := Closure(body, environment.push(enclose(metavariable)))
        closure'.instantiateWith(newMetavariable)
    lift closure


def instantiate(closure)
    instantiateWith(newInstantiationMetavariable, closure)


def convertFunctionsToIntersections(term)
    if term is Function(tag, domain, body)
        Intersection(tag, domain, convertFunctionsToIntersections(body))
    term


def getPatternMatchDomain(Closure(typeConstructor, environment))
    term := convertFunctionsToIntersections(typeConstructor)
    closure <- instantiate(Closure(term, environment))
    lift evaluateClosure(closure)  # evaluate application of type constructor


def instantiateConstruction(closure, environment)
    _ @ Closure(construction, environment') := evaluateClosure(closure)
    if construction is Construction(tag, index, arguments, term)
        if environment.get(index) is Just(typeConstructor)
            if term is Intersection(tag, domain, body)
                closure' := Closure(body, environment'.push(typeConstructor))
                instantiate(closure')  # instantiate "r"
            throwError("expected intersection", getTermTag(term))
        throwError("invalid construction", getTermTag(construction))
    throwError("expected construction", getTermTag(construction))


def getDomain(closure @ Closure(domain, environment))
    if domain is Type(tag, index)
        if index is -_ n
            if environment.get(n) is Just(typeConstructor)
                getPatternMatchDomain(typeConstructor)
            throwError("undefined type family", tag)
        lift closure
    if isUnknown(domain)
        metavariable <- newPositiveMetavariable(getTermTag(domain))
        lift enclose(metavariable)
    lift closure


def newFunctionType(tag, domainClosure, body)
    _ @ Closure(domain, environment) := domainClosure
    Closure(Implication(tag, domain, body), environment)


def getVariableType(context @ (_, types), tag, index)
    types.seek(-_ abs(index)) ?? throwError("unbound variable", tag)


def infer(context @ (environment, types))
    enclose'(term) := Closure(term, environment)

    case Metavariable(tag, index)
        # todo: check for annotated type in metacontext
        throwError("not implemented", tag)
    case Type(tag, index)
        match index
            +_ level -> lift enclose(Type(tag, +_(up level)))
            -_ family -> lift enclose(Type(tag, +_ 1))
    case Variable(tag, index)
        type := getVariableType(context, tag, index)
        if isNegative(index)
            instantiateConstruction(type, environment)
        instantiate(type)
    case Singleton(tag, type, index)
        lift enclose(Type(tag, +_ 0))
    case Function(tag, domain, body)
        domainClosure <- getDomain(enclose'(domain))
        argument <- newNegativeMetavariable(tag)
        range <- body.infer(context.pushContext(domainClosure, argument))
        codomain <- addPositiveMetavariable(tag, range)
        lift newFunctionType(tag, domainClosure, codomain)
    case Implication(tag, domain, body)
        argument <- newNegativeMetavariable(tag)
        _ <- body.infer(context.pushContext(enclose'(domain), argument))
        lift enclose(Type(tag, +_ 0))
    case Intersection(tag, domain, body)
        argument <- newNegativeMetavariable(tag)
        _ <- body.infer(context.pushContext(enclose'(domain), argument))
        lift enclose(Type(tag, +_ 0))
    case Application(tag, applicand, argument)
        argumentType <- argument.infer(context)
        if applicand is Function(tag', domain, body)
            # handle local definitions specially so that we have argument in env
            if isUnknown(domain)  # avoid creating unnecessary metavariable
                body.infer(context.pushContext(argumentType, argument))
            domainClosure <- getDomain(enclose'(domain))
            _ <- unify(argumentType, domainClosure)
            body.infer(context.pushContext(domainClosure, argument))
        applicandType <- applicand.infer(context)
        metacontext <- getState
        _ @ Closure(term', environment') :=
            tryEvaluate(metacontext, applicandType)
        if term' is Implication(tag, domain, body)
            _ <- unify(argumentType, Closure(domain, environment'))
            lift Closure(body, environment'.push(argumentType))
        returnType <- newPositiveMetavariable(tag)
        tag := getTermTag(applicand)
        functionType := newFunctionType(tag, argumentType, returnType)
        # applicandType <: functionType  =>  argumentType <: parameterType
        _ <- unify(applicandType, functionType)
        lift enclose(returnType)
    case Equation(tag, left, right)
        lift enclose(Type(tag, +_ 0))
    case Construction(tag, index, arguments, term)
        lift enclose(Type(tag, +_ 0))
    case Numeral(tag, type, value)
        lift enclose'(type)
    case Operation(tag, term, _)
        term.infer(context)


def inferType(context, term)
    if term is Variable(tag, index)
        # prevent re-generalization, which could change forall names
        lift getVariableType(context, tag, index)
    type <- term.infer(context)
    metacontext <- getState
    lift enclose(type.generalize(metacontext))

#*
