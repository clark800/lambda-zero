#* inference.zero

define getValue(type, variables)
    with type as TypeVariable(_, address)
        variables.access(address) ?? FreeType
    type


define isFree(variable, variables)
    isFreeType(variables.getValue(variable))


define getFreeVariables(variables, type)
    with type as TypeVariable(_, address)
        type' := variables.access(address) ?? FreeType
        if isFreeType(type')
            [type]
        getFreeVariables(variables, type')
    join(getComponentTypes(type).map(getFreeVariables(variables))).
        deduplicateBy(sameRoot)


define getAllFreeVariables(variables, variables')
    join(variables.dump.map(first).map(TypeVariable(noTag)).map(
        getFreeVariables(variables'))).deduplicateBy(sameRoot)


define substitute(variables, type)
    with type as TypeVariable(tag, address)
        type' := variables.access(address) ?? FreeType
        if isFreeType(type')
            type
        type'' := type'.setLocation(tag)
        if type''.getFreeVariables(newStore([])).any(sameRoot(type))
            recursionError(type, type, variables)
        type''.substitute(variables)

    type.mapInternalTypes(substitute(variables))


define unifyFailure(originals, variables, (left, right))
    unificationError(originals.mapPair(substitute(variables)),
        left.substitute(variables), right.substitute(variables))


# Robinson's Unification Algorithm
# see Comparing Unification Algorithms in First-Order Theorem Proving
# by Krystof Hoder and Andrei Voronkov
define unify'(originals, variables, (left, right))
    if isTypeVariable(left) and not isFree(left, variables)
        unify'(originals, variables, (variables.getValue(left), right))
    if isTypeVariable(right) and not isFree(right, variables)
        unify'(originals, variables, (left, variables.getValue(right)))
    if sameRoot(left, right)
        zip(getComponentTypes(left), getComponentTypes(right)).
            cascade(unify'(originals), variables)
    with left as TypeVariable(_, address)
        variables.assign(address, right)
    with right as TypeVariable(_, address)
        variables.assign(address, left)
    unifyFailure(originals, variables, (left, right))

define unify(variables, types)
    unify'(types, variables, types)

define unifyAll(variables, types)
    with types as type :: types'
        zip(repeat(type), types').cascade(unify, variables)
    variables

define generalize(variables, oldVariables, type)
    syntax(\\) := syntax(\)
    vs \\ vs' := vs |: (v -> not vs'.any(sameRoot(v)))
    type' := type.substitute(variables)
    universals := type'.getFreeVariables(variables) \\
        variables.getAllFreeVariables(oldVariables)
    Scheme(universals, type')

define instantiate(variables, tag, Scheme(universals, type))
    (freshVariables, variables') := newTypeVariables(universals, variables)
    addresses := universals.map(maybeAddress).prune
    mappings := zip(addresses, freshVariables)
    renaming := newRenaming(mappings)
    (type.rename(renaming).setLocation(tag), variables')


define getResultType(type)
    with type as FunctionType(_, _, bodyType)
        getResultType(bodyType)
    type


define convertConstructorType(variable, type)
    if isADT(type)
        variable
    with type as FunctionType(tag, parameterType, bodyType)
        FunctionType(tag, parameterType,
            convertConstructorType(variable, bodyType))
    abort "Type error: invalid constructor at " ++ showTypeLocation(type)


define constructInnerParameterType(types, variable, tag)
    types' := types.map(convertConstructorType(variable))
    types'.fold(FunctionType(tag), variable)


define constructParameterType(variables, schemes, tag)
    if isNil(schemes)
        throwError("Type error: no cases:", tag)
    types := schemes.map(getType)
    adtTypes := types.map(getResultType)
    if not adtTypes.all(isADT)
        throwError("Type error: invalid cases:", tag)
    names := deduplicateBy((=*=), adtTypes.map(getTagLexeme <> getTypeTag))
    counts := deduplicate(adtTypes.map(maybeCount).prune)
    if length(names) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := safeHead(counts) ?? 0
    indices := adtTypes.map(maybeIndex).prune
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)

    # note: all schemes should have the same universals
    universals := getUniversals(safeHead(schemes) ?? Free)
    variable := TypeVariable(tag, length(universals))
    universals' := variable :: universals

    outerType := safeHead(adtTypes) ?? FreeType   # todo: set index to zero
    innerType := constructInnerParameterType(types, variable, veil(tag))

    # note: the variables in inner and outer must be instantiated together
    # so we use a trick of packaging them together in a FunctionType
    scheme := Scheme(universals', FunctionType(veil(tag), outerType, innerType))
    (polarType, variables') := scheme.instantiate(variables, tag)
    with polarType as FunctionType(_, outerType, matchType)
        universal := getResultType(matchType)
        innerScheme := Scheme([universal], matchType)
        (outerType, innerScheme, variables')
    throwError("Type error: internal error", tag)


define inferParameterType(stack, variables, metadata, tag)
    schemes := getConstructorDebruijnIndices(metadata).map(k ->
        stack.seek(k -- 1)).prune
    if isNil(schemes)
        (parameterType, variables') := variables.newTypeVariable(tag)
        (parameterType, Scheme([], parameterType), variables')
    constructParameterType(variables, schemes, tag)


# stack is a list of type schemes for all the lambda-bound symbols in scope
# variables is a table that maps type variables to types (either type
#   variables or concrete types); every type variable appears in variables
define infer(stack, variables)
    case Variable(tag, debruijn)
        scheme := stack.seek(debruijn -- 1) ?? Free
        scheme.instantiate(variables, tag)
    case Abstraction(tag, metadata, body)
        if not isFreeType(getType(getAscription(metadata)))
            getAscription(metadata).instantiate(newStore([]), tag)
        (type, scheme, variables') :=
            inferParameterType(stack, variables, metadata, tag)
        (bodyType, variables'') := infer(stack.push(scheme), variables', body)
        (FunctionType(tag, type, bodyType), variables'')
    case Application(tag, isLet, applicand, argument)
        if isLet
            (valueType, variables') := infer(stack, variables, argument)
            stack' := stack.push(valueType.generalize(variables', variables))
            with applicand as Abstraction(_, _, body)
                infer(stack', variables', body)
            infer(stack, variables,
                Application(tag, False, applicand, argument))
        (argumentType, variables') := infer(stack, variables, argument)
        (applicandType, variables'') := infer(stack, variables', applicand)
        (returnType, variables''') := variables''.newTypeVariable(tag)
        applicandTag := getTermTag(applicand)
        functionType := FunctionType(applicandTag, argumentType, returnType)
        (returnType, unify(variables''', (applicandType, functionType)))
    case Numeral(tag, value)
        index := if value = 0 then 1 else 2
        (ADT(renameTag(tag, "â„•", NOFIX), [], 2, index), variables)
    case Operation(tag, _, _)
        getBuiltinType(tag, variables)


define inferType(stack, definition)
    if getTagLexeme(first(definition)) =*= "fix"
        stack.push(getFixScheme(getTermTag(second(definition))))
    (type, variables') := infer(stack, newStore([]), second(definition))
    stack.push(type.generalize(variables', newStore([])))


define getDefinitions(term)
    with term as Application(_, isLet, applicand, argument)
        if isLet
            with applicand as Abstraction(_, _, body)
                (getTermTag(applicand), argument) :: getDefinitions(body)
            []
        []
    []


define main(input)
    term := parse(input)
    definitions := getDefinitions(term)
    stack := definitions.cascade(inferType, newRandomAccessList([]))
    schemes := stack.getList.reverse
    (names, _) := unzip(definitions)
    showTypings(zip(names, schemes))

#*
