#* inference.zero

def pushContext(type, term, context @ (environment, types))
    (environment.push(Closure(term, environment)), types.push(type))


def instantiate(closure @ Closure(term, environment))
    if term is Intersection(_, _, body)
        if isConstruction(term)
            lift closure
        metavariable <- newPositiveMetaVariable(getTermTag(term))
        instantiate(Closure(body, environment.push(enclose(metavariable))))
    lift closure


def convertFunctionsToIntersections(term)
    if term is Function(tag, domain, body)
        Intersection(tag, domain, convertFunctionsToIntersections(body))
    term


def getPatternMatchDomain(closure @ Closure(typeConstructor, environment))
    term := convertFunctionsToIntersections(typeConstructor)
    closure' <- instantiate(Closure(term, environment))
    outerDomain @ Closure(term', environment') := evaluateClosure(closure')
    if term' is Intersection(_, _, body)
        innerDomain := Closure(body, environment'.push(closure))
        lift (outerDomain, innerDomain)
    throwError("invalid type family", getTermTag(typeConstructor))


def getDomain(closure @ Closure(domain, environment))
    if domain is Type(tag, index)
        if index is -_ n
            if environment.get(n) is Just(closure')
                getPatternMatchDomain(closure')
            throwError("undefined type family", tag)
        lift duplicate(closure)
    if isUnknown(domain)
        metavariable <- newPositiveMetaVariable(getTermTag(domain))
        lift duplicate(enclose(metavariable))
    lift duplicate(closure)


def newFunctionType(tag, domainClosure, body)
    _ @ Closure(domain, environment) := domainClosure
    Closure(Implication(tag, domain, body), environment)


def infer(context @ (environment, types))
    enclose'(term) := Closure(term, environment)

    case MetaVariable(tag, index)
        # todo: check for annotated type in metacontext
        throwError("not implemented", tag)
    case Type(tag, index)
        match index
            +_ level -> lift enclose(Type(tag, +_(up level)))
            -_ family -> lift enclose(Type(tag, +_ 1))
    case Variable(tag, index)
        type := types.seek(-_ abs(index)) ?? throwError("unbound variable", tag)
        instantiate(type)
    case Singleton(tag, type, element)
        type.infer(context)   # todo: support unknown type, verify type
    case Function(tag, domain, body)
        (outerDomain, innerDomain) <- getDomain(enclose'(domain))
        argument <- newNegativeMetaVariable(tag)
        range <- body.infer(context.pushContext(innerDomain, argument))
        codomain <- addPositiveMetaVariable(tag, range)
        lift newFunctionType(tag, outerDomain, codomain)
    case Implication(tag, domain, body)
        argument <- newNegativeMetaVariable(tag)
        _ <- body.infer(context.pushContext(enclose'(domain), argument))
        lift enclose(Type(tag, +_ 0))
    case Intersection(tag, domain, body)
        this := Intersection(tag, domain, body)
        if getConstructionTypeFamily(this) is Just(family)
            lift enclose'(family)
        argument <- newNegativeMetaVariable(tag)
        body.infer(context.pushContext(enclose'(domain), argument))
    case Application(tag, applicand, argument)
        argumentType <- argument.infer(context)
        if applicand is Function(tag', domain, body)
            # handle local definitions specially so that we have argument in env
            if isUnknown(domain)  # avoid creating unnecessary metavariable
                body.infer(context.pushContext(argumentType, argument))
            (outerDomain, innerDomain) <- getDomain(enclose'(domain))
            _ <- unify(argumentType, outerDomain)
            body.infer(context.pushContext(innerDomain, argument))
        applicandType <- applicand.infer(context)
        returnType <- newPositiveMetaVariable(tag)
        tag := getTermTag(applicand)
        functionType := newFunctionType(tag, argumentType, returnType)
        # applicandType <: functionType  =>  argumentType <: parameterType
        _ <- unify(applicandType, functionType)
        lift enclose(returnType)
    case Numeral(tag, type, value)
        lift enclose'(type)
    case Operation(tag, term, _)
        term.infer(context)


def getFixType(tag)
    syntax(=>>) := syntax(++)
    tag := renameTag(tag, "a", NOFIX)
    (=>>) := Implication(veil(tag))
    a1 := Variable(tag, +_ 1)
    a2 := Variable(tag, +_ 2)
    Intersection(tag, Type(veil(tag), +_ 0), (a1 =>> a2) =>> a2)


def renameUniversals(closure)
    (closure', metacontext) := instantiate(closure, emptyMetacontext)
    closure'.generalize(metacontext)


def inferType(types, Binding(tag, closure, ascription))
    if getTagLexeme(tag) =*= "fix"
        types.push(enclose(getFixType(tag)))
    if ascription is Just(closure)
        types.push(enclose(renameUniversals(closure)))
    _ @ Closure(term, environment) := closure
    context := (environment, types)
    (type, metacontext) := infer(context, term, emptyMetacontext)
    types.push(enclose(type.generalize(metacontext)))


def showTyping((tag, type))
    showTag(tag) ++ " : " ++ showClosure(type)


def showTypings(typings)
    typings.map(showTyping).joinWith("\n") ++ "\n"


def main(input)
    bindings := reverse(parse(getBuiltin, input))
    types := bindings.cascade(inferType, newArray([]))
    tags := bindings.map(getBindingTag)
    showTypings(zip(tags, types.toList))

#*
