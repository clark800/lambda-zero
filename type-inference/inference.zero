--* inference.zero

getFreeVariables(type, variables) := (
    if isTypeVariable(type)
        if type.isFree(variables)
            [type]
        getFreeVariables(variables.get(type, undefined), variables)
    join(getComponentTypes(type).map(`getFreeVariables(variables))).
        deduplicateBy((=~=))
)

getAllFreeVariables(variables, variables') :=
    join(variables.getKeys.map(`getFreeVariables(variables'))).
        deduplicateBy((=~=))

substitute(type, variables) := (
    if isTypeVariable(type)
        if type.isFree(variables)
            type
        type' := variables.get(type, undefined).setNode(getNode(type))
        if type'.getFreeVariables(empty).any((=~= type))
            recursionError(type, type, variables)
        type'.substitute(variables)

    type.mapComponents(`substitute(variables))
)

-- Robinson's Unification Algorithm
-- see Comparing Unification Algorithms in First-Order Theorem Proving
-- by Krystof Hoder and Andrei Voronkov
unify'(originals, variables, (left, right)) := (
    if isTypeVariable(left) /\ not left.isFree(variables)
        unify'(originals, variables, (left.substitute(variables), right))
    if isTypeVariable(right) /\ not right.isFree(variables)
        unify'(originals, variables, (left, right.substitute(variables)))
    if isBottomType(left) \/ isBottomType(right)
        variables
    if left =~= right
        variables
    if isTypeVariable(left)
        variables.insert(left, right)
    if isTypeVariable(right)
        variables.insert(right, left)
    if (getTypeCode(left) = getTypeCode(right) /\
        getIndex(left) = getIndex(right) /\
        length(getComponentTypes(left)) = length(getComponentTypes(right)))
        zip(getComponentTypes(left), getComponentTypes(right)).
            cascade(unify'(originals), variables)
    unificationError(originals.mapPair(`substitute(variables)),
        left.substitute(variables), right.substitute(variables))
)

unify(variables, types) := unify'(types, variables, types)

unifyAll(variables, types) := (
    if isNil(types)
        variables
    zip(repeat(head(types)), tail(types)).cascade(unify, variables)
)

generalize(type, variables, oldVariables) := (
    syntax(\\) := infix(17)
    vs \\ vs' := vs |: (v -> not vs'.any((=~= v)))
    type' := type.substitute(variables)
    universals := type'.getFreeVariables(variables) \\
        oldVariables.getAllFreeVariables(variables)
    newScheme(universals, type')
)

instantiate(scheme, variables, node) := (
    (universals, type) := scheme
    (freshVariables, variables') := newTypeVariables(universals, variables)
    renaming := newVariableMap(zip(universals, freshVariables))
    (type.rename(renaming).setNode(node), variables')
)

isRecursiveFunction(node) := false      -- todo: fix

-- stack is a list of type schemes for all the lambda-bound symbols in scope
-- variables is a table that maps type variables to types (either type
--   variables or concrete types); every type variable appears in variables
infer(node, stack, variables) := (
    if isNatural(node)
        (newNaturalType(node), variables)
    if isBuiltin(node)
        (getBuiltinType(node), variables)
    if isSymbol(node)
        stack[getDebruijnIndex(node) - 1].instantiate(variables, node)
    if isRecursiveFunction(node)
        function := getBody(getRight(node))
        (functionType, variables') := variables.newTypeVariable(function)
        stack' := newScheme([], functionType) :: stack
        (functionType', variables'') := function.infer(stack', variables')
        (functionType, variables''.unify((functionType', functionType)))
    if isLambda(node)
        parameter := getParameter(node)
        (parameterType, variables') := variables.newTypeVariable(parameter)
        stack' := newScheme([], parameterType) :: stack
        (bodyType, variables'') := getBody(node).infer(stack', variables')
        (newFunctionType(node, parameterType, bodyType), variables'')
    if isDefinition(node)
        (valueType, variables') := getRight(node).infer(stack, variables)
        stack' := valueType.generalize(variables', variables) :: stack
        getDefinitionScope(node).infer(stack', variables')
    if isApplication(node)
        (rightType, variables') := getRight(node).infer(stack, variables)
        (leftType, variables'') := getLeft(node).infer(stack, variables')
        (returnType, variables''') := variables''.newTypeVariable(node)
        functionType := newFunctionType(NULL, rightType, returnType)
        (returnType, variables'''.unify((leftType, functionType)))
    undefined
)

inferType(stack, definition) := (
    (name, value) := definition
    knownTypeScheme := getKnownTypeScheme(name)
    if not isFreeType(second(knownTypeScheme))
        knownTypeScheme :: stack
    (type, variables') := infer(value, stack, empty)
    type.generalize(variables', empty) :: stack
)

main(input) := (
    node := parse(input, "")
    definitions := getDefinitions(node)
    schemes := reverse(definitions.cascade(inferType, []))
    (names, _) := unzip(definitions)
    showTypings(zip(names, schemes))
)

--*
