#* inference.zero

# temporary function that can be removed after schemes are removed
define convertToSchemeType(implicits, level, type)
    with type as Implication(tag, left, right)
        left' := convertToSchemeType(implicits, level, left)
        right' := convertToSchemeType(implicits, up level, right)
        Implication(tag, left', right')
    with type as Application(tag, left, right)
        left' := convertToSchemeType(implicits, level, left)
        right' := convertToSchemeType(implicits, level, right)
        Application(tag, left', right')
    with type as Variable(tag, debruijn)
        if debruijn > level -- implicits
            MetaVariable(tag, level -- debruijn + 1)
        Variable(tag, debruijn)
    type


# temporary function that can be removed after schemes are removed
define convertToScheme(level, type)
    with type as Implicit(tag, parameter, body)
        match convertToScheme(up level, body)
            case Scheme(universals, type')
                id := length(universals) + 1
                Scheme(universals ++ [MetaVariable(tag, id)], type')
    Scheme([], convertToSchemeType(level, level, type))


define pushContext(term, scheme, context @ (terms, schemes))
    # TODO: replace schemes with an array of closures of types
    (terms.push(Closure(term, terms)), schemes.push(scheme))


define pushParameter(scheme, context)
    # TODO: term should be an atom
    pushContext(Top(noTag), scheme, context)


define getAllFreeVariables(metacontext, metacontext')
    indices := (0 ...)[0, metacontext.getSize]
    join(indices.map(MetaVariable(noTag)).map(
        getFreeVariables(metacontext'))).deduplicateBy(sameHead)


define generalize(metacontext, oldMetacontext, type)
    syntax(\\) := syntax(\)
    vs \\ vs' := vs |: (v -> not vs'.any(sameHead(v)))
    type' := type.substitute(metacontext)
    universals := type'.getFreeVariables(metacontext) \\
        metacontext.getAllFreeVariables(oldMetacontext)
    Scheme(universals, type')


define newInstantiationMap(universals, metacontext)
    (metaVariables, metacontext') := newMetaVariables(universals, metacontext)
    addresses := universals.map(maybeAddress).prune
    renaming := newRenaming(zip(addresses, metaVariables))
    (renaming, metacontext')


define instantiateType(tag, mapping, type)
    type.rename(mapping).setLocation(tag)


define coinstantiate(tag, metacontext, schemes)
    (Scheme(universalsA, typeA), Scheme(universalsB, typeB)) := schemes
    universalsB' := universalsB.drop(length(universalsA))
    universals := universalsB' ++ universalsA
    (mapping, metacontext') := newInstantiationMap(universals, metacontext)
    (typeA', typeB') := (typeA, typeB).mapPair(instantiateType(tag, mapping))
    universals' := universalsB'.map(instantiateType(tag, mapping))
    (typeA', Scheme(universals', typeB'), metacontext')


define instantiate(tag, metacontext, Scheme(universals, type))
    (mapping, metacontext') := newInstantiationMap(universals, metacontext)
    (type.instantiateType(tag, mapping), metacontext')


define infer(context @ (terms, types), metacontext)
    case Top(tag)
        (Top(tag), metacontext)
    case Constant(tag, index)
        scheme := types.get(index) ?? throwError("unbound constant", tag)
        scheme.instantiate(tag, metacontext)
    case Variable(tag, debruijn)
        scheme := types.peek(debruijn -- 1) ??
            throwError("unbound variable", tag)
        scheme.instantiate(tag, metacontext)
    case MetaVariable(tag, address)
        with metacontext.get(address) ?? Void as Just(Closure(term, _))
            infer(context, metacontext, term)
        newMetaVariable(tag, metacontext)
    case Abstraction(tag, constraint, body)
        match constraint
            case Annotation(parameterType)
                (parameterType', metacontext') :=
                    if isMetaVariable(parameterType) then
                    metacontext.newMetaVariable(tag) else
                    (parameterType, metacontext)
                context' := context.pushParameter(Scheme([], parameterType'))
                (bodyType, metacontext'') := infer(context', metacontext', body)
                (Implication(tag, parameterType', bodyType), metacontext'')
            case Ascription(type)
                scheme := convertToScheme(0, type)
                scheme.instantiate(tag, metacontext)
            case PolarAnnotation(outerType, innerType)
                outerScheme := convertToScheme(0, outerType)
                innerScheme := convertToScheme(0, innerType)
                (outerType', innerScheme', metacontext') :=
                    coinstantiate(tag, metacontext, (outerScheme, innerScheme))
                context' := context.pushParameter(innerScheme')
                (bodyType, metacontext'') := infer(context', metacontext', body)
                (Implication(tag, outerType', bodyType), metacontext'')
    case Implication(tag, parameter, body)
        (parameterType, metacontext') := infer(context, metacontext, parameter)
        context' := context.pushParameter(Scheme([], parameterType))
        (bodyType, metacontext'') := infer(context', metacontext', body)
        (Top(veil(tag)), metacontext'')
    case Implicit(tag, type, body)
        infer(context.pushParameter(Scheme([], type)), metacontext, body)
    case Application(tag, applicand, argument)
        (argumentType, metacontext') := infer(context, metacontext, argument)
        with applicand as Abstraction(_, constraint, body)
            if isLambdaConstraint(constraint)
                context' := context.pushParameter(
                    argumentType.generalize(metacontext', metacontext))
                infer(context', metacontext', body)
            pass
        (applicandType, metacontext'') :=
            infer(context, metacontext', applicand)
        (returnType, metacontext''') := metacontext''.newMetaVariable(tag)
        applicandTag := getTermTag(applicand)
        functionType := Implication(applicandTag, argumentType, returnType)
        (returnType, unify(context, metacontext''',
            (applicandType, functionType)))
    case Construction(tag, parameters, objectType)
        (Top(veil(tag)), metacontext)
    case Numeral(tag, type, value)
        (type, metacontext)
    case Operation(tag, type, _, _)
        scheme := convertToScheme(0, type)
        scheme.instantiate(tag, metacontext)


define getFixScheme(tag)
    syntax(>->) := syntax(++)
    (>->) := Implication(tag)
    a := MetaVariable(veil(tag), 0)
    Scheme([a], (a >-> a) >-> a)


define inferType(context, (tag, term))
    if getTagLexeme(tag) =*= "fix"
        context.pushContext(term, getFixScheme(getTermTag(term)))
    metacontext := newArray([])
    (type, metacontext') := infer(context, metacontext, term)
    scheme := type.generalize(metacontext', metacontext)
    context.pushContext(term, scheme)


define main(input)
    (tags, _, environment) := parse(input)
    terms := environment.toList.map(getTerm)
    context := (newArray([]), newArray([]))
    context' := zip(tags, terms).cascade(inferType, context)
    schemes := second(context').toList
    showTypings(zip(tags, schemes))

#*
