#* inference.zero

define getFreeVariables(type, variables)
    if isTypeVariable(type)
        if type.isFree(variables)
            [type]
        getFreeVariables(variables.get(type), variables)
    join(getComponentTypes(type).map(`getFreeVariables(variables))).
        deduplicateBy(sameRoot)

define getAllFreeVariables(variables, variables')
    join(variables.getKeys.map(`getFreeVariables(variables'))).
        deduplicateBy(sameRoot)

define substitute(type, variables)
    if isTypeVariable(type)
        if type.isFree(variables)
            type
        type' := variables.get(type).setSource(getSource(type))
        if type'.getFreeVariables(empty).any(sameRoot(type))
            recursionError(type, type, variables)
        type'.substitute(variables)

    type.mapComponents(`substitute(variables))

# Robinson's Unification Algorithm
# see Comparing Unification Algorithms in First-Order Theorem Proving
# by Krystof Hoder and Andrei Voronkov
define unify'(originals, variables, (left, right))
    if isTypeVariable(left) and not left.isFree(variables)
        unify'(originals, variables, (left.substitute(variables), right))
    if isTypeVariable(right) and not right.isFree(variables)
        unify'(originals, variables, (left, right.substitute(variables)))
    if isBottomType(left) or isBottomType(right)
        variables
    if sameRoot(left, right)
        zip(getComponentTypes(left), getComponentTypes(right)).
            cascade(unify'(originals), variables)
    if isTypeVariable(left)
        variables.insert(left, right)
    if isTypeVariable(right)
        variables.insert(right, left)
    unificationError(originals.mapPair(`substitute(variables)),
        left.substitute(variables), right.substitute(variables))

define unify(variables, types)
    unify'(types, variables, types)

define unifyAll(variables, types)
    if isNil(types)
        variables
    zip(repeat(head(types)), tail(types)).cascade(unify, variables)

define generalize(type, variables, oldVariables)
    syntax(\\) := syntax(\)
    vs \\ vs' := vs |: (v -> not vs'.any(sameRoot(v)))
    type' := type.substitute(variables)
    universals := type'.getFreeVariables(variables) \\
        oldVariables.getAllFreeVariables(variables)
    Scheme(universals, type')

define instantiate(Scheme(universals, type), variables, term)
    (freshVariables, variables') := newTypeVariables(universals, variables)
    renaming := newVariableMap(zip(universals, freshVariables))
    (type.rename(renaming).setSource(term), variables')


define getResultType(type)
    if isFunctionType(type) then getResultType(getBodyType(type)) else type


define convertConstructorType(variable, type)
    if isADT(type)
        variable
    if isFunctionType(type)
        FunctionType(getSource(type), getParameterType(type),
            convertConstructorType(variable, getBodyType(type)))
    abort "Type error: invalid constructor at " ++ showTypeLocation(type)


define constructInnerParameterType(types, variable, term)
    types' := types.map(convertConstructorType(variable))
    types'.fold(FunctionType(term), variable)


define constructParameterType(variables, schemes, term)
    tag := getTermTag(term)
    if isNil(schemes)
        throwError("Type error: no cases:", tag)
    types := schemes.map(getType)
    adtTypes := types.map(getResultType)
    if not adtTypes.all(isADT)
        throwError("Type error: invalid cases:", tag)
    names := deduplicateBy(adtTypes.map(getName), (=*=))
    counts := deduplicate(adtTypes.map(getCount))
    if length(names) =/= 1 or length(counts) =/= 1
        throwError("Type error: inconsistent cases:", tag)
    count := head(counts)
    indices := adtTypes.map(getIndex)
    if length(indices) < count
        throwError("Type error: missing case:", tag)
    if length(indices) > count
        throwError("Type error: too many cases:", tag)
    if not indices =*= sort(indices)
        throwError("Type error: cases out of order:", tag)

    # note: all schemes should have the same universals
    universals := getUniversals(head(schemes))
    variable := TypeVariable(term, length(universals))
    universals' := variable :: universals

    outerType := head(adtTypes)   # todo: set index to zero
    innerType := constructInnerParameterType(types, variable, term)

    # note: the variables in inner and outer must be instantiated together
    # so we use a trick of packaging them together in a FunctionType
    scheme := Scheme(universals', FunctionType(term, outerType, innerType))
    (polarType, variables') := scheme.instantiate(variables, term)
    outerType := getParameterType(polarType)
    innerType := getBodyType(polarType)
    universal := getResultType(innerType)
    innerScheme := Scheme([universal], innerType)
    (outerType, innerScheme, variables')


define inferParameterType(stack, variables, term)
    metadata := getMetadata(term)
    schemes := getConstructorDebruijnIndices(metadata).map(k -> stack[k - 1])
    if isNil(schemes)
        (parameterType, variables') := variables.newTypeVariable(term)
        (parameterType, Scheme([], parameterType), variables')
    constructParameterType(variables, schemes, term)


# stack is a list of type schemes for all the lambda-bound symbols in scope
# variables is a table that maps type variables to types (either type
#   variables or concrete types); every type variable appears in variables
define infer(stack, variables)
    case term @ Variable(_, debruijn)
        stack[debruijn - 1].instantiate(variables, term)
    case term @ Abstraction(_, metadata, body)
        if not isFreeType(getType(getAscription(metadata)))
            getAscription(metadata).instantiate(empty, term)
        (outerParameterType, innerParameterScheme, variables') :=
            inferParameterType(stack, variables, term)
        stack' := innerParameterScheme :: stack
        (bodyType, variables'') := infer(stack', variables', body)
        (FunctionType(term, outerParameterType, bodyType), variables'')
    case term @ Application(_, isLet, applicand, argument)
        if isLet
            (valueType, variables') := infer(stack, variables, argument)
            stack' := valueType.generalize(variables', variables) :: stack
            infer(stack', variables', getBody(applicand))
        (argumentType, variables') := infer(stack, variables, argument)
        (applicandType, variables'') := infer(stack, variables', applicand)
        (returnType, variables''') := variables''.newTypeVariable(term)
        functionType := FunctionType(noTerm, argumentType, returnType)
        (returnType, variables'''.unify((applicandType, functionType)))
    case term @ Numeral(_, value)
        index := if value = 0 then 1 else 2
        (ADT(term, "â„•", NOFIX, [], 2, index), variables)
    case term @ Operation(_, _, _)
        (getBuiltinType(term), variables)


define inferType(stack, definition)
    if getTagLexeme(first(definition)) =*= "fix"
        getFixScheme(getSource(second(definition))) :: stack
    (type, variables') := infer(stack, empty, second(definition))
    type.generalize(variables', empty) :: stack


define getDefinitions
    Variable(_, _) -> []
    Abstraction(_, _, _) -> []
    Application(_, isLet, applicand, argument) ->
        if isLet then (getTermTag(applicand), argument) ::
            getDefinitions(getBody(applicand)) else []
    Numeral(_, _) -> []
    Operation(_, _, _) -> []


define main(input)
    term := parse(input)
    definitions := getDefinitions(term)
    schemes := reverse(definitions.cascade(inferType, []))
    (names, _) := unzip(definitions)
    showTypings(zip(names, schemes))

#*
