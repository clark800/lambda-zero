#* resolve.zero

def pushUnknown(tag, environment)
    environment.push(enclose(Unknown(tag)))


# for any variable in term that has a value in the environment, replace
# the variable with the value from the environment recursively
def resolve(Closure(term, environment))
    resolve'(t) := resolve(Closure(t, environment))
    match term
        Unknown(tag) -> term
        MetaVariable(tag, id) -> term
        Universe(tag, level) -> term
        Variable(tag, index) -> (
            if environment.seek(index) is Just(closure)
                if isUnknown(getTerm(closure)) then term else
                    resolve(evaluateClosure(closure))
            term
        )
        Function(tag, type, body) ->
            Function(tag, type.mapDomain(resolve'),
                resolve(Closure(body, pushUnknown(tag, environment))))
        Implication(tag, type, body) ->
            Implication(tag, resolve'(type),
                resolve(Closure(body, pushUnknown(tag, environment))))
        Intersection(tag, type, body) ->
            Intersection(tag, resolve'(type),
                resolve(Closure(body, pushUnknown(tag, environment))))
        Application(tag, left, right) ->
            Application(tag, resolve'(left), resolve'(right))
        Construction(tag, parameters, objectType, signatures) ->
            Construction(tag, parameters.map(resolve'),
                resolve'(objectType), signatures.map(resolve'))
        Numeral(_, _, _) -> term
        Operation(_, _, _) -> term

#*
