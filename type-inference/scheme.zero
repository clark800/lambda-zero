#* scheme.zero

SchemeT(term) ::= {Scheme(universals : List(term), type : term)}

getUniversals(Scheme(universals, _)) := universals
getType(Scheme(_, type)) := type

def newMetaVariable(tag, metacontext)
    (index, metacontext') := metacontext.append(Void)
    (MetaVariable(tag, index), metacontext')


def convertMapping((metavariable, term))
    if metavariable is MetaVariable(_, address)
        Just((address, term))
    Void


def newMapping(mappings)
    # mappings is a list of (metavariable, term) pairs
    # the returned mapping is a table from metavariable address to term
    newTable((<=), mappings.filterMap(convertMapping))


def applyMapping(mapping, type)
    if type is MetaVariable(_, address)
        mapping.lookup(address) ?? type
    type.mapComponents(applyMapping(mapping))


def renameScheme(Scheme(universals, type), metacontext)
    tags := universals.map(getTermTag)
    (universals', metacontext') := tags.cascadeMap(newMetaVariable, metacontext)
    mapping := newMapping(zip(universals, universals'))
    (Scheme(universals', type.applyMapping(mapping)), metacontext')


def normalizeScheme(scheme)
    first(renameScheme(scheme, newArray([])))


def showUniversal(universal)
    "∀" ⧺ showTerm(universal) ⧺ " "


def showScheme(Scheme(universals, type))
    universals.map(showUniversal).join ++ showTerm(type)


def showTyping((tag, scheme))
    showTag(tag) ++ " : " ++ showScheme(normalizeScheme(scheme))


def showTypings(typings)
    typings.map(showTyping).joinWith("\n") ++ "\n"

#*
