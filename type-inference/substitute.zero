#* substitute.zero

newMetaVariables(tags, metacontext) :=
    tags.cascadeMap(newMetaVariable, metacontext)


newMapping(mappings) := newTable((<=), mappings)


def applyMapping(mapping, type)
    if type is MetaVariable(_, address)
        mapping.lookup(address) ?? type
    type.mapComponents(applyMapping(mapping))


def getFreeVariables(metacontext, type)
    if type is MetaVariable(_, address)
        if metacontext.get(address) ?? Void is Just(closure)
            getFreeVariables(metacontext, flattenClosure(closure))
        [type]
    join(getComponents(type).map(getFreeVariables(metacontext))).
        deduplicateBy(sameHead)


def showMaybeClosure(maybeClosure)
    if maybeClosure is Just(Closure(type, _))
        showTerm(type)
    "Free"


def showMetacontext(metacontext)
    zip(0 ..., metacontext.toList).map((address, maybeClosure) ->
        showMetaVariable(address) ++ " := " ++
        showMaybeClosure(maybeClosure)).joinWith("\n")


def recursionError(type, type', metacontext)
    abort("Type error: recursive type at " ++
        showTermLocation(type) ++ " and " ++ showTermLocation(type') ++
        ":\n" ++ showTerm(type) ++ " = " ++ showTerm(type') ++ "\n\n" ++
        showMetacontext(metacontext))


def substitute(metacontext, type)
    if type is MetaVariable(tag, address)
        if metacontext.get(address) ?? Void is Just(closure)
            type' := flattenClosure(closure).setLocation(tag)
            if type'.getFreeVariables(newArray([])).any(sameHead(type))
                recursionError(type, type', metacontext)
            type'.substitute(metacontext)
        type
    type.mapComponents(substitute(metacontext))

#*
