#* substitute.zero

def copyMetaVariables(metavariables, metacontext)
    tags := metavariables.map(getTermTag)
    tags.cascadeMap(newMetaVariable, metacontext)


def convertMapping((metavariable, term))
    if metavariable is MetaVariable(_, address)
        Just((address, term))
    Void


def newMapping(mappings)
    # mappings is a list of (metavariable, term) pairs
    # the returned mapping is a table from metavariable address to term
    newTable((<=), mappings.filterMap(convertMapping))


def applyMapping(mapping, type)
    if type is MetaVariable(_, address)
        mapping.lookup(address) ?? type
    type.mapComponents(applyMapping(mapping))


def getFreeVariables(metacontext, type)
    if type is MetaVariable(_, address)
        if metacontext.get(address) ?? Void is Just(closure)
            getFreeVariables(metacontext, flattenClosure(closure))
        [type]
    join(getComponents(type).map(getFreeVariables(metacontext))).
        deduplicateBy(isSameHead)


def showMaybeClosure(maybeClosure)
    if maybeClosure is Just(Closure(type, _))
        showTerm(type)
    "Free"


def showMetacontext(metacontext)
    zip(0 ..., metacontext.toList).map((address, maybeClosure) ->
        showMetaVariable(address) ++ " := " ++
        showMaybeClosure(maybeClosure)).joinWith("\n")


def recursionError(type, type', metacontext)
    abort("Type error: recursive type at " ++
        showTermLocation(type) ++ " and " ++ showTermLocation(type') ++
        ":\n" ++ showTerm(type) ++ " = " ++ showTerm(type') ++ "\n\n" ++
        showMetacontext(metacontext))


def substitute(metacontext, type)
    if type is MetaVariable(tag, address)
        if metacontext.get(address) ?? Void is Just(closure)
            type' := flattenClosure(closure).setLocation(tag)
            if type'.getFreeVariables(newArray([])).any(isSameHead(type))
                recursionError(type, type', metacontext)
            type'.substitute(metacontext)
        type
    type.mapComponents(substitute(metacontext))

#*
