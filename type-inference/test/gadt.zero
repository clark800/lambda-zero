#% dump

syntax(or) â‰” infixR(17)
syntax(and) â‰” infixR(18)
syntax(not) â‰” prefix(19)
syntax(â‰£) â‰” infix(20)
syntax(::) â‰” infixR(40)
syntax(:::) := infixR(40)
syntax(up) := prefix(90)
syntax(<>) := infixR(70)
syntax(match) := prefix(7)
syntax(if) := prefix(14)
syntax(then) := interfix(if _)
syntax(else) := interfix(if _ then _)
syntax(+) := infixL(50)
syntax(âŠ“) â‰” infixL(70)

f <> g â‰” x â†¦ f(g(x))
fix(f) â‰” ğ›š(f <> ğ›š) where ğ›š(x) â‰” x(x)
(match x)(f) := f(x)

a âŠ“ b â©´ {(_ : a, _ : b)}

ğ”¹ â©´ {False, True}
if b then x else y â‰” b â¦Š (case False â†¦ y; case True â†¦ x)
not b â‰” if b then False else True
b and c â‰” if b then c else False
b or c â‰” if b then True else c

Nat ::= {0, up(n : Nat)}
(+) := (case 0 -> m -> m; case up n -> m -> up(n + m))

List(a) â©´ {[], (head : a) :: (tail : List(a))}

abort(message : List(Nat)) â‰” abort(message)
impossible := abort("impossible")

Vector(n : Nat, a) ::= {
    Nil : Vector(0, a),
    ((_ : a) ::: (_ : Vector(n', a)) : Vector(up n', a)) for n' : Nat
}

vector := 1 ::: Nil

vector' := 2 ::: vector

# overly specific type
#sig Vector(1, Nat) => Vector(2, Nat)
#def pushOne(xs)
#    1 ::: xs

sig forall(n : Nat) >-> forall(a) >-> Vector(n, a) => Nat
def vlength
    case Nil -> 0
    case x ::: xs' -> up vlength(xs')

sig forall(n : Nat) >-> forall(m : Nat) >-> forall(a) >->
    Vector(n, a) => Vector(m, a) => Vector(n + m, a)
def concatenate(xs, ys)
    match xs
        case Nil -> ys
        case x ::: xs' -> x ::: concatenate(xs', ys)

sig forall(n : Nat) >-> forall(a) >-> forall(b) >->
    Vector(n, a) => Vector(n, b) => Vector(n, a âŠ“ b)
def vzip(xs, ys)
    match xs
        case Nil -> Nil
        case x ::: xs'
            match ys
                case Nil -> impossible
                case y ::: ys' -> (x, y) ::: vzip(xs', ys')

sig 1 + 1 == 2
def proof
    infer


F(s, R : Nat) â©´ {
    Sum(left : F(s, R), right : F(s, R)),
    Product(left : F(s, Râ€²), right : F(s, Râ€³)) :
                F(s, Râ€² + Râ€³) for Râ€² : Nat for Râ€³ : Nat
}


sig âˆ€(s) â†£ âˆ€ (R : Nat) â†£ F(s, R) â‡’ F(s, R) â‡’ ğ”¹
def left â‰£ right
    match left
    case Sum(left, right)
        if right is Sum(leftâ€², rightâ€²)
            left â‰£ leftâ€² and right â‰£ rightâ€²
        False
    case Product(left, right)
        if right is Product(leftâ€², rightâ€²)
            left â‰£ leftâ€² and right â‰£ rightâ€²
        False

0
