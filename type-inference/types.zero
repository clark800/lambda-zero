#* types.zero

define getSource
    FreeType -> noTerm
    BottomType(source) -> source
    TypeVariable(source, _) -> source
    FunctionType(source, _, _) -> source
    ADT(source, _, _, _, _, _) -> source


define maybeAddress(term)
    with term as TypeVariable(_, address)
        Just(address)
    Void

define maybeName(term)
    with term as ADT(_, name, _, _, _, _)
        Just(name)
    Void

define maybeCount(term)
    with term as ADT(_, _, _, _, count, _)
        Just(count)
    Void

define maybeIndex(term)
    with term as ADT(_, _, _, _, _, index)
        Just(index)
    Void

define setSource(source)
    FreeType -> FreeType
    BottomType(_) -> BottomType(source)
    TypeVariable(_, index) -> TypeVariable(source, index)
    FunctionType(_, parameter, body) ->
        FunctionType(source, parameter, body)
    ADT(_, name, fixity, parameters, count, index) ->
        ADT(source, name, fixity, parameters, count, index)


isFreeType := FreeType -> True; _ -> False
isBottomType := BottomType(_) -> True; _ -> False
isTypeVariable := TypeVariable(_, _) -> True; _ -> False
isFunctionType := FunctionType(_, _, _) -> True; _ -> False
isADT := ADT(_, _, _, _, _, _) -> True; _ -> False


define getVariableName(index)
    characters := ['a', 'b', 'c', 'd']
    if index < 4
        [characters.safeAt(index) ?? '#']
    getVariableName((index // 4) -- 1) ++ [characters.safeAt(index % 4) ?? '#']


define getSuffix(count, index)
    if count <= 1 or index = 0 then ""
    subscripts := ["₀", "₁", "₂", "₃", "₄", "₅", "₆", "₇", "₈", "₉"]
    showNatural(index).map(x -> subscripts.safeAt(x -- '0') ?? "").join


define showADT(name, fixity, arguments)
    with arguments as argument :: arguments'
        if fixity = INFIX and length(arguments) = 2
            "(" ++ (argument :: name :: arguments').joinWith(" ") ++ ")"
        if fixity = PREFIX and length(arguments) = 1
            name ++ "(" ++ argument ++ ")"
        if fixity = POSTFIX and length(arguments) = 1
            "(" ++ argument ++ ")" ++ name
        name ++ "(" ++ arguments.joinWith(", ") ++ ")"
    name


define showType
    case FreeType; "_"
    case BottomType(_); "⊥"
    case TypeVariable(_, address); getVariableName(address)
    case FunctionType(_, parameter, body)
        if isFunctionType(parameter)
            "(" ++ showType(parameter) ++ ")" ++ " ⇒ " ++ showType(body)
        showType(parameter) ++ " ⇒ " ++ showType(body)
    case ADT(_, name, fixity, parameters, count, index)
        showADT(name, fixity, parameters.map(showType))


define getComponentTypes
    FreeType -> []
    BottomType(_) -> []
    TypeVariable(_, _) -> []
    FunctionType(_, parameter, body) -> [parameter, body]
    ADT(_, _, _, parameters, _, _) -> parameters


define getInternalTypes
    FreeType -> []
    BottomType(_) -> []
    TypeVariable(_, _) -> []
    FunctionType(_, parameter, body) -> [parameter, body]
    ADT(_, _, _, parameters, _, _) -> parameters


define sameRoot(a, b)
    match a
        case FreeType
            False
        case BottomType(_)
            isBottomType(b)
        case TypeVariable(_, address)
            with b as TypeVariable(_, address')
                address = address'
            False
        case FunctionType(_, _, _)
            isFunctionType(b)
        case ADT(_, name, _, parameters, _, _)
            with b as ADT(_, name', _, parameters', _, _)
                name =*= name' and length(parameters) = length(parameters')
            False


define newTypeVariable(source, variables)
    (address, variables') := variables.allocate(FreeType)
    (TypeVariable(source, address), variables')

newTypeVariables(originals, variables) :=
    originals.map(getSource).cascadeMap(newTypeVariable, variables)

define mapInternalTypes(f, type)
    match type
        FreeType -> type
        BottomType(_) -> type
        TypeVariable(_, _) -> type
        FunctionType(source, parameter, body) ->
            FunctionType(source, f(parameter), f(body))
        ADT(source, name, fixity, parameters, count, index) ->
            ADT(source, name, fixity, parameters.map(f), count, index)

newRenaming(mappings) := newTable((<=), mappings)

define rename(renaming, type)
    with type as TypeVariable(_, address)
        renaming.lookup(address) ?? type
    type.mapInternalTypes(rename(renaming))

#*
