#* types.zero

# note: types contain source terms so that we have the ability to serialize the
# whole source term if there is a type error
newType(source, code, index, components) :=
    Node((source, code, index), components)
getSource := first_3 <> getData
getTypeCode := second_3 <> getData
getIndex := third_3 <> getData
getTypeVariableIndex := getIndex
getComponentTypes := getChildren
define setSource(type, source)
    newType(source, getTypeCode(type), getIndex(type), getComponentTypes(type))

noTerm := Variable(noTag, 0)

define isNoTerm
    case Variable(_, debruijn) -> debruijn = 0
    case Function(_, _) -> false
    case Application(_, _) -> false
    case Natural(_, _) -> false
    case Optimization(_, _, _) -> false

newFreeType(source) := newType(source, 1, 0, [])
newBooleanType(source) := newType(source, 2, 0, [])
newNaturalType(source) := newType(source, 3, 0, [])
newFunctionType(source, left, right) := newType(source, 4, 0, [left, right])
newTupleType(source, types) := newType(source, 5, 0, types)
newListType(source, type) := newType(source, 6, 0, [type])
newTreeType(source, type) := newType(source, 7, 0, [type])
newMaybeType(source, type) := newType(source, 8, 0, [type])
newBottomType(source) := newType(source, 9, 0, [])
define newTypeVariable(variables, source)
    type := newType(source, 0, cardinality(variables), [])
    (type, variables.insert(type, newFreeType(noTerm)))
newTypeVariables(originals, variables) :=
    originals.map(getSource).cascadeMap(`newTypeVariable, variables)
newProjectionType(source, elementTypes, returnType) :=
    newFunctionType(source, newTupleType(noTerm, elementTypes), returnType)
newStringType(source) := newListType(source, newNaturalType(noTerm))
newScheme(universals, type) := (universals, type)

isTypeVariable(type) := getTypeCode(type) = 0
isFreeType(type) := getTypeCode(type) = 1
isBooleanType(type) := getTypeCode(type) = 2
isNaturalType(type) := getTypeCode(type) = 3
isFunctionType(type) := getTypeCode(type) = 4
isTupleType(type) := getTypeCode(type) = 5
isListType(type) := getTypeCode(type) = 6
isTreeType(type) := getTypeCode(type) = 7
isMaybeType(type) := getTypeCode(type) = 8
isBottomType(type) := getTypeCode(type) = 9
isFree(type, variables) := not variables.hasKey(type) or
    isFreeType(variables.get(type, undefined))

syntax(=~=) := infix(13)
a =~= b := getTypeCode(a) = getTypeCode(b) and getIndex(a) = getIndex(b) and
    zip(getComponentTypes(a), getComponentTypes(b)).all(uncurry((=~=)))

mapComponents(type, f) := newType(getSource(type), getTypeCode(type),
    getIndex(type), getComponentTypes(type).map(f))

newVariableMap(mappings) := newTable((<=).on(getIndex), mappings)
empty := newVariableMap([])

define rename(type, variables)
    if isTypeVariable(type)
        variables.get(type, type)
    type.mapComponents(`rename(variables))

#*
