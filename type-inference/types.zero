#* types.zero

define getSource
    FreeType -> undefined
    BottomType(source) -> source
    TypeVariable(source, _) -> source
    FunctionType(source, _, _) -> source
    ADT(source, _, _, _, _, _, _) -> source


define setSource(type, source)
    match type
        FreeType -> FreeType
        BottomType(_) -> BottomType(source)
        TypeVariable(_, index) -> TypeVariable(source, index)
        FunctionType(_, parameter, body) ->
            FunctionType(source, parameter, body)
        ADT(_, name, fixity, parameters, type, count, index) ->
            ADT(source, name, fixity, parameters, type, count, index)


define setMatchType(adtType, type)
    match adtType
        FreeType -> undefined
        BottomType(_) -> undefined
        TypeVariable(_, index) -> undefined
        FunctionType(_, parameter, body) -> undefined
        ADT(source, name, fixity, parameters, _, count, index) ->
            ADT(source, name, fixity, parameters, type, count, index)


define indexType
    FreeType -> 0
    BottomType(_) -> 1
    TypeVariable(_, _) -> 2
    FunctionType(_, _, _) -> 3
    ADT(_, _, _, _, _, _, _) -> 4


isFreeType(type) := indexType(type) = 0
isBottomType(type) := indexType(type) = 1
isTypeVariable(type) := indexType(type) = 2
isFunctionType(type) := indexType(type) = 3
isADT(type) := indexType(type) = 4


define getVariableName(index)
    characters := ['a', 'b', 'c', 'd']
    if index < 4
        [characters[index]]
    getVariableName((index // 4) - 1) ++ [characters[index % 4]]


define getSuffix(count, index)
    if count <= 1 or index = 0 then ""
    subscripts := ["₀", "₁", "₂", "₃", "₄", "₅", "₆", "₇", "₈", "₉"]
    showNatural(index).map(x -> x - '0').map(x -> subscripts[x]).join


define showADT(name, fixity, arguments)
    if isNil(arguments)
        name
    if fixity = INFIX and length(arguments) = 2
        "(" ++ arguments[0] ++ " " ++ name ++ " " ++ arguments[1] ++ ")"
    if fixity = PREFIX and length(arguments) = 1
        name ++ "(" ++ arguments[0] ++ ")"
    if fixity = POSTFIX and length(arguments) = 1
        "(" ++ arguments[0] ++ ")" ++ name
    name ++ "(" ++ arguments.joinWith(", ") ++ ")"


define showType
    case FreeType; "_"
    case BottomType(_); "⊥"
    case TypeVariable(_, address); getVariableName(address)
    case FunctionType(_, parameter, body)
        if isFunctionType(parameter)
            "(" ++ showType(parameter) ++ ")" ++ " ⇒ " ++ showType(body)
        showType(parameter) ++ " ⇒ " ++ showType(body)
    case ADT(_, name, fixity, parameters, type, count, index)
        showADT(name, fixity, parameters.map(showType))


define getComponentTypes
    FreeType -> []
    BottomType(_) -> []
    TypeVariable(_, _) -> []
    FunctionType(_, parameter, body) -> [parameter, body]
    ADT(_, _, _, parameters, _, _, _) -> parameters


define getInternalTypes
    FreeType -> []
    BottomType(_) -> []
    TypeVariable(_, _) -> []
    FunctionType(_, parameter, body) -> [parameter, body]
    ADT(_, _, _, parameters, type, _, _) -> type :: parameters


define sameRoot(a, b)
    match a
        FreeType -> false
        BottomType(_) -> isBottomType(b)
        TypeVariable(_, _) -> isTypeVariable(b) and
            getAddress(a) = getAddress(b)
        FunctionType(_, _, _) -> isFunctionType(b)
        ADT(_, _, _, _, _, _, _) -> isADT(b) and getName(a) =*= getName(b) and
            length(getParameters(a)) = length(getParameters(b))


define newTypeVariable(variables, source)
    (address, variables') := variables.allocate(FreeType)
    (TypeVariable(source, address), variables')

newTypeVariables(originals, variables) :=
    originals.map(getSource).cascadeMap(`newTypeVariable, variables)

define isFree(type, variables)
    match variables.seek(getAddress(type))
        void -> true
        just(type') -> isFreeType(type')

define mapInternalTypes(type, f)
    match type
        FreeType -> type
        BottomType(_) -> type
        TypeVariable(_, _) -> type
        FunctionType(source, parameter, body) ->
            FunctionType(source, f(parameter), f(body))
        ADT(source, name, fixity, parameters, type, count, index) ->
            ADT(source, name, fixity, parameters.map(f), f(type), count, index)

newRenaming(mappings) := newTable(id, (<=).on(getAddress), mappings)

define rename(type, renaming)
    if isTypeVariable(type)
        renaming.lookup(type) ?? type
    type.mapInternalTypes(`rename(renaming))

#*
