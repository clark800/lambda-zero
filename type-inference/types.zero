#* types.zero

# note: types contain source terms so that we have the ability to serialize the
# whole source term if there is a type error
Type ::= {
    FreeType(_source : Term),
    BottomType(_source : Term),
    TypeVariable(_source : Term, getTypeVariableIndex : Natural),
    NominalType(_source : Term,
        getHeadName : String, getParameters : List(Type)),
    FunctionType(_source : Term, getParameterType : Type, getBodyType : Type)
}

define getSource
    case FreeType(source) -> source
    case BottomType(source) -> source
    case TypeVariable(source, _) -> source
    case NominalType(source, _, _) -> source
    case FunctionType(source, _, _) -> source


define setSource(type, source)
    match type
        case FreeType(_) -> FreeType(source)
        case BottomType(_) -> BottomType(source)
        case TypeVariable(_, index) -> TypeVariable(source, index)
        case NominalType(_, name, parameters) ->
            NominalType(source, name, parameters)
        case FunctionType(_, parameter, body) ->
            FunctionType(source, parameter, body)


define indexType
    case FreeType(_) -> 0
    case BottomType(_) -> 1
    case TypeVariable(_, _) -> 2
    case NominalType(_, _, _) -> 3
    case FunctionType(_, _, _) -> 4


isFreeType(type) := indexType(type) = 0
isBottomType(type) := indexType(type) = 1
isTypeVariable(type) := indexType(type) = 2
isNominalType(type) := indexType(type) = 3
isFunctionType(type) := indexType(type) = 4


define getVariableName(index)
    characters := ['a', 'b', 'c', 'd']
    if index < 4
        [characters[index]]
    getVariableName((index // 4) - 1) ++ [characters[index % 4]]


define showType
    case FreeType(_) -> "_"
    case BottomType(_) ->"⊥"
    case TypeVariable(_, index) -> getVariableName(index)
    case NominalType(_, name, parameters)
        if isNil(parameters) then name else
            name ++ "(" ++ parameters.map(showType).joinWith(", ") ++ ")"
    case FunctionType(_, parameter, body)
        if isFunctionType(parameter)
            "(" ++ showType(parameter) ++ ")" ++ " → " ++ showType(body)
        showType(parameter) ++ " → " ++ showType(body)


define getComponentTypes
    case FreeType(_) -> []
    case BottomType(_) -> []
    case TypeVariable(_, _) -> []
    case NominalType(_, _, parameters) -> parameters
    case FunctionType(_, parameter, body) -> [parameter, body]


syntax(=~=) := infix(18)

define a =~= b
    match a
        case FreeType(_) -> undefined
        case BottomType(_) -> isBottomType(b)
        case TypeVariable(_, _) -> isTypeVariable(b) and
            getTypeVariableIndex(a) = getTypeVariableIndex(b)
        case NominalType(_, _, _) -> isNominalType(b) and
            getHeadName(a) =*= getHeadName(b) and
            all(zipWith(getComponentTypes(a), (=~=), getComponentTypes(b)), id)
        case FunctionType(_, _, _) -> isFunctionType(b) and
            getParameterType(a) =~= getParameterType(b) and
            getBodyType(a) =~= getBodyType(b)


noTerm := Variable(noTag, 0)
isNoTerm(term) := isVariable(term) and getDebruijnIndex(term) = 0

define newTypeVariable(variables, source)
    type := TypeVariable(source, cardinality(variables))
    (type, variables.insert(type, FreeType(noTerm)))

newTypeVariables(originals, variables) :=
    originals.map(getSource).cascadeMap(`newTypeVariable, variables)

isFree(type, variables) := not variables.hasKey(type) or
    isFreeType(variables.get(type, undefined))

define mapComponents(type, f)
    match type
        case FreeType(_) -> type
        case BottomType(_) -> type
        case TypeVariable(_, _) -> type
        case NominalType(source, name, parameters) ->
            NominalType(source, name, parameters.map(f))
        case FunctionType(source, parameter, body) ->
            FunctionType(source, f(parameter), f(body))

newVariableMap(mappings) := newTable((<=).on(getTypeVariableIndex), mappings)
empty := newVariableMap([])

define rename(type, variables)
    if isTypeVariable(type)
        variables.get(type, type)
    type.mapComponents(`rename(variables))

newScheme(universals, type) := (universals, type)

#*
