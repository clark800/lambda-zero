#* types.zero

define getSource
    FreeType -> noTerm
    BottomType(source) -> source
    TypeVariable(source, _) -> source
    FunctionType(source, _, _) -> source
    ADT(source, _, _, _, _, _, _) -> source


define setSource(source)
    FreeType -> FreeType
    BottomType(_) -> BottomType(source)
    TypeVariable(_, index) -> TypeVariable(source, index)
    FunctionType(_, parameter, body) ->
        FunctionType(source, parameter, body)
    ADT(_, name, fixity, parameters, type, count, index) ->
        ADT(source, name, fixity, parameters, type, count, index)


define setMatchType(type, matchType)
    with type as ADT(source, name, fixity, parameters, _, count, index)
        ADT(source, name, fixity, parameters, matchType, count, index)
    type


isFreeType := FreeType -> True; _ -> False
isBottomType := BottomType(_) -> True; _ -> False
isTypeVariable := TypeVariable(_, _) -> True; _ -> False
isFunctionType := FunctionType(_, _, _) -> True; _ -> False
isADT := ADT(_, _, _, _, _, _, _) -> True; _ -> False


define getVariableName(index)
    characters := ['a', 'b', 'c', 'd']
    if index < 4
        [characters.safeAt(index) ?? '#']
    getVariableName((index // 4) -- 1) ++ [characters.safeAt(index % 4) ?? '#']


define getSuffix(count, index)
    if count <= 1 or index = 0 then ""
    subscripts := ["₀", "₁", "₂", "₃", "₄", "₅", "₆", "₇", "₈", "₉"]
    showNatural(index).map(x -> subscripts.safeAt(x -- '0') ?? "").join


define showADT(name, fixity, arguments)
    with arguments as argument :: arguments'
        if fixity = INFIX and length(arguments) = 2
            "(" ++ (argument :: name :: arguments').joinWith(" ") ++ ")"
        if fixity = PREFIX and length(arguments) = 1
            name ++ "(" ++ argument ++ ")"
        if fixity = POSTFIX and length(arguments) = 1
            "(" ++ argument ++ ")" ++ name
        name ++ "(" ++ arguments.joinWith(", ") ++ ")"
    name


define showType
    case FreeType; "_"
    case BottomType(_); "⊥"
    case TypeVariable(_, address); getVariableName(address)
    case FunctionType(_, parameter, body)
        if isFunctionType(parameter)
            "(" ++ showType(parameter) ++ ")" ++ " ⇒ " ++ showType(body)
        showType(parameter) ++ " ⇒ " ++ showType(body)
    case ADT(_, name, fixity, parameters, type, count, index)
        showADT(name, fixity, parameters.map(showType))


define getComponentTypes
    FreeType -> []
    BottomType(_) -> []
    TypeVariable(_, _) -> []
    FunctionType(_, parameter, body) -> [parameter, body]
    ADT(_, _, _, parameters, _, _, _) -> parameters


define getInternalTypes
    FreeType -> []
    BottomType(_) -> []
    TypeVariable(_, _) -> []
    FunctionType(_, parameter, body) -> [parameter, body]
    ADT(_, _, _, parameters, type, _, _) -> type :: parameters


define sameRoot(a, b)
    match a
        FreeType -> False
        BottomType(_) -> isBottomType(b)
        TypeVariable(_, _) -> isTypeVariable(b) and
            getAddress(a) = getAddress(b)
        FunctionType(_, _, _) -> isFunctionType(b)
        ADT(_, _, _, _, _, _, _) -> isADT(b) and getName(a) =*= getName(b) and
            length(getParameters(a)) = length(getParameters(b))


define newTypeVariable(source, variables)
    (address, variables') := variables.allocate(FreeType)
    (TypeVariable(source, address), variables')

newTypeVariables(originals, variables) :=
    originals.map(getSource).cascadeMap(newTypeVariable, variables)

define mapInternalTypes(f, type)
    match type
        FreeType -> type
        BottomType(_) -> type
        TypeVariable(_, _) -> type
        FunctionType(source, parameter, body) ->
            FunctionType(source, f(parameter), f(body))
        ADT(source, name, fixity, parameters, type, count, index) ->
            ADT(source, name, fixity, parameters.map(f), f(type), count, index)

newRenaming(mappings) := newTable((<=).on(getAddress), mappings)

define rename(renaming, type)
    if isTypeVariable(type)
        renaming.lookup(type) ?? type
    type.mapInternalTypes(rename(renaming))

#*
