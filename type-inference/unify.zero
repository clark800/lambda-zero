#* unify.zero

def unificationError(originals, left, right)
    error("Type error: Can't unify\n" ++
        showTermAndLocation(left) ++ "\nwith\n" ++ showTermAndLocation(right) ++
        "\nwhile trying to unify\n" ++
        showTermAndLocation(first(originals)) ++
        "\nwith\n" ++
        showTermAndLocation(second(originals)))


def recursionError(metavariable, closure, metacontext)
    error("Type error: recursion in " ++
        showTermAndLocation(metavariable) ++ "\n" ++
        showTerm(metavariable) ++ " = " ++ showClosure(closure) ++ "\n\n" ++
        showMetacontext(metacontext))


def unifyFailure(originals, metacontext, (left, right))
    unificationError(originals.mapPair(normalize <> resolveLocals(metacontext)),
        normalize(left.resolveLocals(metacontext)),
        normalize(right.resolveLocals(metacontext)))


def isSameMetavariable
    case Metavariable(_, index)
        case Metavariable(_, index') -> index =:= index'
        case _ -> False
    case _ -> _ -> False


def tryEvaluate(metacontext, closure)
    closure' := evaluate(metacontext, [], [], closure)
    term := getTerm(closure')
    if getMetavariableValue(term, metacontext) is Just(closure')
        recursionError(term, closure', metacontext)
    if isUnknown(term) then return closure else return closure'


def unify'(fail, metacontext, (left, right))
    fail' := fail(metacontext, (left, right))
    try left := left.tryEvaluate(metacontext)
    try right := right.tryEvaluate(metacontext)
    _ @ Closure(leftTerm, leftEnv) := left
    _ @ Closure(rightTerm, rightEnv) := right

    unify''(metacontext', left', right') := unify'(fail, metacontext',
        (Closure(left', leftEnv), Closure(right', rightEnv)))
    unify'''(metacontext', (left', right')) :=
        unify''(metacontext', left', right')

    if isSameMetavariable(leftTerm, rightTerm)
        return metacontext

    if leftTerm is Metavariable(tag, index)
        indices := getMetavariableIndices(right.resolve(metacontext))
        if indices.contains((=:= index))
            recursionError(leftTerm, right, metacontext)
        if index is +_ index'
            return metacontext.setMetaValue(index', right)
        if rightTerm is Metavariable(_, index')
            if index' is +_ index''
                return metacontext.setMetaValue(index'', left)
            fail'
        fail'

    if rightTerm is Metavariable(tag, index)
        indices := getMetavariableIndices(left.resolve(metacontext))
        if indices.contains((=:= index))
            recursionError(rightTerm, left, metacontext)
        if index is +_ index'
            return metacontext.setMetaValue(index', left)
        fail'

    def unifyBodies(tag, metacontext', leftBody, rightBody)
        (m, metacontext'') := metacontext'.newNegativeMetavariable(tag)
        unify'(fail, metacontext'',
            (Closure(leftBody, leftEnv.push(enclose(m))),
             Closure(rightBody, rightEnv.push(enclose(m)))))

    def unifyBinder(tag, leftDomain, rightDomain, leftBody, rightBody)
        try metacontext' := unify'(fail, metacontext,
            (Closure(rightDomain, rightEnv),
             Closure(leftDomain, leftEnv)))
        unifyBodies(tag, metacontext', leftBody, rightBody)

    match leftTerm
        case Metavariable(tag, index)
            fail'  # already handled above
        case Type(tag, index)
            if rightTerm is Type(_, index')
                if index =:= index' then return metacontext else fail'
            fail'
        case Variable(tag, index)
            fail'  # evaluate should never return a Variable
        case Singleton(tag, type, index)
            if rightTerm is Singleton(tag', type', index')
                if index = index' then return metacontext else fail'
            fail'
        case Function(tag, domain, body)
            if rightTerm is Function(tag', domain', body')
                if isUnknown(domain) and isUnknown(domain')
                    unifyBodies(tag, metacontext, body, body')
                unifyBinder(tag, domain, domain', body, body')
            fail'
        case Implication(tag, domain, body)
            if rightTerm is Implication(tag', domain', body')
                unifyBinder(tag, domain, domain', body, body')
            fail'
        case Intersection(tag, domain, body)
            if rightTerm is Intersection(tag', domain', body')
                unifyBinder(tag, domain, domain', body, body')
            fail'
        case Application(tag, left', right')
            if rightTerm is Application(tag', left'', right'')
                try metacontext' := unify''(metacontext, left', left'')
                unify''(metacontext', right', right'')
            fail'
        case Equation(tag, left', right')
            if rightTerm is Equation(tag', left'', right'')
                try metacontext' := unify''(metacontext, left', left'')
                unify''(metacontext', right', right'')
            fail'
        case Construction(tag, index, arguments, term)
            if rightTerm is Construction(tag', index', arguments', term')
                if index = index'
                    zip(arguments, arguments').tryCascade(unify''', metacontext)
                fail'
            fail'
        case Numeral(tag, type, value)
            if rightTerm is Numeral(_, _, value')
                if value = value' then return metacontext else fail'
            fail'
        case Operation(tag, term, optimization)
            fail'    # evaluate should never return an Operation


def unify(left, right, metacontext)
    originals := (left, right)
    match unify'(unifyFailure(originals), metacontext, originals)
        case Left(message) -> (Left(message), metacontext)
        case Right(metacontext') -> (Right(metacontext'), metacontext')

#*
