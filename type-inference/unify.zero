#* unify.zero

def unificationError(originals, left, right)
    abort("Type error: Can't unify\n" ++
        showTerm(left) ++ "\nwith\n" ++ showTerm(right) ++
        "\nwhile trying to unify\n" ++
        showTermAndLocation(first(originals)) ++
        "\nwith\n" ++
        showTermAndLocation(second(originals)))


def unifyFailure(originals, metacontext, (left, right))
    unificationError(originals.mapPair(resolve(metacontext)),
        left.resolve(metacontext), right.resolve(metacontext))


def isNegativeMetaVariable(term)
    if term is MetaVariable(_, index)
        isNegative(index)
    False


def isSamePrimitive(term)
    case Unknown(_) -> False
    case MetaVariable(_, index)
        if term is MetaVariable(_, index')
            index =:= index'
        False
    case Type(_, index)
        if term is Type(_, index')
            index =:= index'
        False
    case Variable(_, index)
        if term is Variable(_, index')
            index =:= index'
        False
    case Function(_, _, _) -> False
    case Implication(_, _, _) -> False
    case Intersection(_, _, _) -> False
    case Application(_, _, _) -> False
    case Construction(_, _, _, _) -> False
    case Numeral(_, _, value)
        if term is Numeral(_, _, value')
            value = value'
        False
    case Operation(_, _, _) -> False # evaluate will never return an Operation


def tryEvaluate(metacontext, closure)
    closure' := evaluate(metacontext, [], closure)
    if isUnknown(getTerm(closure')) then closure else closure'


# Robinson's Unification Algorithm
# see Comparing Unification Algorithms in First-Order Theorem Proving
# by Krystof Hoder and Andrei Voronkov
# unify' enforces that left <: right
def unify'(fail, metacontext, (left, right))
    fail' := fail(metacontext, (left, right))
    left := left.tryEvaluate(metacontext)
    right := right.tryEvaluate(metacontext)
    _ @ Closure(leftTerm, leftEnv) := left
    _ @ Closure(rightTerm, rightEnv) := right

    if isUnknown(leftTerm) or isUnknown(rightTerm)
        fail'

    if isSamePrimitive(leftTerm, rightTerm)
        metacontext

    if isNegativeMetaVariable(leftTerm) or isNegativeMetaVariable(rightTerm)
        fail'

    if rightTerm is MetaVariable(_, index)
        metacontext.setMetaValue(abs(index), left)

    def unifyBinder(tag, leftDomain, rightDomain, leftBody, rightBody)
        metacontext' := unify'(fail, metacontext,
            (Closure(rightDomain, rightEnv),
             Closure(leftDomain, leftEnv)))
        (m, metacontext'') := metacontext'.newNegativeMetaVariable(tag)
        unify'(fail, metacontext'',
            (Closure(leftBody, leftEnv.push(enclose(m))),
             Closure(rightBody, rightEnv.push(enclose(m)))))

    def unifyApplication(leftLeft, rightLeft, leftRight, rightRight)
        metacontext' := unify'(fail, metacontext,
            (Closure(leftLeft, leftEnv), Closure(rightLeft, rightEnv)))
        unify'(fail, metacontext',
            (Closure(leftRight, leftEnv), Closure(rightRight, rightEnv)))

    match leftTerm
        case Unknown(tag) -> fail'
        case MetaVariable(tag, index)
            metacontext.setMetaValue(abs(index), right)
        case Type(tag, index) -> fail'
        case Variable(tag, index) -> fail'  # should already be evaluated
        case Function(tag, domain, body) -> fail'
        case Implication(tag, domain, body)
            if rightTerm is Implication(tag', domain', body')
                unifyBinder(tag, domain, domain', body, body')
            fail'
        case Intersection(tag, domain, body)
            if rightTerm is Intersection(tag', domain', body')
                unifyBinder(tag, domain, domain', body, body')
            fail'
        case Application(tag, left', right')
            if rightTerm is Application(tag', left'', right'')
                unifyApplication(left', left'', right', right'')
            fail'
        case Construction(tag, domain, parameters, body)
            if rightTerm is Construction(tag', domain', parameters', body')
                if not isSamePrimitive(domain, domain')
                    fail'
                lefts := parameters.map(`Closure(leftEnv))
                rights := parameters'.map(`Closure(rightEnv))
                zip(lefts, rights).cascade(unify'(fail), metacontext)
            fail'
        case Numeral(tag, type, value) -> fail'
        case Operation(tag, term, optimization) -> fail'


def unify(left, right, metacontext)
    originals := (left, right)
    metacontext' := unify'(unifyFailure(originals), metacontext, originals)
    _ @ Metacontext(positives, negatives) := metacontext'
    if getSize(positives) < 0  # todo: remove this and use either type
        abort("force unification errors")
    ((), metacontext')

#*
