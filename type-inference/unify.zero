#* unify.zero

def unificationError(originals, left, right)
    abort("Type error: Can't unify\n" ++
        showTerm(left) ++ "\nwith\n" ++ showTerm(right) ++
        "\nwhile trying to unify\n" ++
        showTermAndLocation(first(originals)) ++
        "\nwith\n" ++
        showTermAndLocation(second(originals)))


def unifyFailure(originals, metacontext, (left, right))
    unificationError(originals.mapPair(substitute(metacontext)),
        left.substitute(metacontext), right.substitute(metacontext))


def getValue(index, Metacontext(positives, negatives))
    positives.get(index) ?? Void


def substituteAndEvaluate(metacontext, term)
    term' := substitute(metacontext, term)
    result := resolve(evaluateClosure(enclose(term')))
    if isUnknown(result) then term' else result


# Robinson's Unification Algorithm
# see Comparing Unification Algorithms in First-Order Theorem Proving
# by Krystof Hoder and Andrei Voronkov
# unify' enforces that left <: right
def unify'(fail, metacontext, (left, right))
    fail' := fail(metacontext, (left, right))
    left := substituteAndEvaluate(metacontext, left)
    right := substituteAndEvaluate(metacontext, right)

    if right is Unknown(_)
        fail'
    if right is MetaVariable(_, index)
        if isSameHead(left, right)
            metacontext
        if index is +_ index'
            if metacontext.getValue(index') is Just(right')
                unify'(fail, metacontext, (left, right'))
            metacontext.setMetaVariable(index', Just(left))
        fail'

    match left
        case Unknown(tag)
            fail'
        case MetaVariable(tag, index)
            if isSameHead(left, right)
                metacontext
            if index is +_ index'
                if metacontext.getValue(index') is Just(left')
                    unify'(fail, metacontext, (left', right))
                metacontext.setMetaVariable(index', Just(right))
            fail'
        case Type(tag, index)
            if isSameHead(left, right) then metacontext else fail'
        case Variable(tag, index)
            fail'
        case Function(tag, domain, body)
            fail'
        case Implication(tag, domain, body)
            if right is Implication(tag', domain', body')
                metacontext' := unify'(fail, metacontext, (domain', domain))
                (m, metacontext'') := newNegativeMetaVariable(tag, metacontext')
                unify'(fail, metacontext'',
                    (body.substituteArgument(m), body'.substituteArgument(m)))
            fail'
        case Intersection(tag, domain, body)
            if right is Intersection(tag', domain', body')
                metacontext' := unify'(fail, metacontext, (domain', domain))
                (m, metacontext'') := newNegativeMetaVariable(tag, metacontext')
                unify'(fail, metacontext'',
                    (body.substituteArgument(m), body'.substituteArgument(m)))
            fail'
        case Application(tag, left', right')
            if right is Application(tag', left'', right'')
                metacontext' := unify'(fail, metacontext, (left', left''))
                unify'(fail, metacontext', (right', right''))
            fail'
        case Construction(tag, domain, parameters, body)
            if right is Construction(tag', domain', parameters', body')
                if not isSameHead(domain, domain')
                    fail'
                zip(parameters, parameters').cascade(unify'(fail), metacontext)
                #(m, metacontext') := newNegativeMetaVariable(tag, metacontext)
                #unify'(fail, metacontext',
                #    (body.substituteArgument(m), body'.substituteArgument(m)))
            fail'
        case Numeral(tag, type, value)
            if isSameHead(left, right) then metacontext else fail'
        case Operation(tag, term, optimization)
            if isSameHead(left, right) then metacontext else fail'


def unify(left, right, metacontext)
    types := (left, right)
    metacontext' := unify'(unifyFailure(types), metacontext, types)
    _ @ Metacontext(positives, negatives) := metacontext'
    if getSize(positives) < 0  # todo: remove this and use either type
        abort("force unification errors")
    ((), metacontext')

#*
