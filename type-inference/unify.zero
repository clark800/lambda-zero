#* unify.zero

def newPositiveMetaVariable(tag, Metacontext(positives, negatives))
    (index, positives') := positives.append(Void)
    (MetaVariable(tag, +_ index), Metacontext(positives', negatives))


def newNegativeMetaVariable(tag, Metacontext(positives, negatives))
    (index, negatives') := negatives.append(Void)
    (MetaVariable(tag, -_ index), Metacontext(positives, negatives'))


def unificationError(originals, left, right)
    abort("Type error: Can't unify\n" ++
        showTerm(left) ++ "\nwith\n" ++ showTerm(right) ++
        "\nwhile trying to unify\n" ++
        showTermAndLocation(first(originals)) ++
        "\nwith\n" ++
        showTermAndLocation(second(originals)))


def unifyFailure(originals, metacontext, (left, right))
    unificationError(originals.mapPair(substitute(metacontext)),
        left.substitute(metacontext), right.substitute(metacontext))


def getValue(index, Metacontext(positives, negatives))
    positives.get(index) ?? Void


def substituteAndEvaluate(metacontext, term)
    resolve(evaluateClosure(enclose(substitute(metacontext, term))))


def insertMetaVariable(term, metacontext)
    tag := getTermTag(term)
    (metavariable, metacontext') := newPositiveMetaVariable(tag, metacontext)
    closure' := Closure(term, newArray([enclose(metavariable)]))
    (resolve(closure'), metacontext')


# Robinson's Unification Algorithm
# see Comparing Unification Algorithms in First-Order Theorem Proving
# by Krystof Hoder and Andrei Voronkov
# unify' enforces that left <: right
def unify'(fail, metacontext, (left, right))
    fail' := fail(metacontext, (left, right))
    left := substituteAndEvaluate(metacontext, left)
    right := substituteAndEvaluate(metacontext, right)

    if right is Unknown(_)
        fail'
    if right is MetaVariable(_, index)
        if isSameHead(left, right)
            metacontext
        if index is +_ index'
            if metacontext.getValue(index') is Just(right')
                unify'(fail, metacontext, (left, right'))
            metacontext.setMetaVariable(index', Just(left))
        fail'

    match left
        case MetaVariable(_, index)
            if isSameHead(left, right)
                metacontext
            if index is +_ index'
                if metacontext.getValue(index') is Just(left')
                    unify'(fail, metacontext, (left', right))
                metacontext.setMetaVariable(index', Just(right))
            fail'
        case Universe(_, _)
            if isSameHead(left, right) then metacontext else fail'
        case Implication(_, domain, body)
            if right is Implication(_, domain', body')
                metacontext' := unify'(fail, metacontext, (domain', domain))
                # todo: handle dependent types
                unify'(fail, metacontext', (body, body'))
            fail'
        case Intersection(_, domain, body)
            if right is Intersection(tag, domain', body')
                metacontext' := unify'(fail, metacontext, (domain', domain))
                # todo: handle dependent types
                unify'(fail, metacontext', (body, body'))
            (left', metacontext') := insertMetaVariable(body, metacontext)
            unify'(fail, metacontext', (left', right))
        case Construction(_, parameters, _, _)
            if not isSameHead(left, right)
                fail'
            if right is Construction(_, parameters', _, _)
                zip(parameters, parameters').cascade(unify'(fail), metacontext)
            fail'
        case _
            fail'


def unify(left, right, metacontext)
    types := (left, right)
    metacontext' := unify'(unifyFailure(types), metacontext, types)
    _ @ Metacontext(positives, negatives) := metacontext'
    if getSize(positives) < 0  # todo: remove this and use either type
        abort("force unification errors")
    ((), metacontext')

#*
