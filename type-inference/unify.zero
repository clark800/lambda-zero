#* unify.zero

def unificationError(originals, left, right)
    abort("Type error: Can't unify\n" ++
        showTerm(left) ++ "\nwith\n" ++ showTerm(right) ++
        "\nwhile trying to unify\n" ++
        showTermAndLocation(first(originals)) ++
        "\nwith\n" ++
        showTermAndLocation(second(originals)))


def unifyFailure(originals, metacontext, (left, right))
    unificationError(originals.mapPair(substitute(metacontext)),
        left.substitute(metacontext), right.substitute(metacontext))


def isFree(variable, metacontext)
    if variable is MetaVariable(_, address)
        isVoid(metacontext.get(address) ?? Void)
    False


def getValue(type, metacontext)
    if type is MetaVariable(_, address)
        if metacontext.get(address) ?? Void is Just(closure)
            closure
        pass
    throwError("internal error", getTermTag(type))


def getComponentClosures(Closure(term, environment))
    # TODO: right side of binders need an extra item in the environment
    getComponents(term).map(`Closure(environment))


def substituteAndEvaluate(metacontext, Closure(term, environment))
    evaluateClosure(Closure(substitute(metacontext, term), environment))


# Robinson's Unification Algorithm
# see Comparing Unification Algorithms in First-Order Theorem Proving
# by Krystof Hoder and Andrei Voronkov
def unify'(fail, metacontext, (leftClosureRaw, rightClosureRaw))
    leftClosure := substituteAndEvaluate(metacontext, leftClosureRaw)
    rightClosure := substituteAndEvaluate(metacontext, rightClosureRaw)
    _ @ Closure(left, leftEnvironment) := leftClosure
    _ @ Closure(right, rightEnvironment) := rightClosure

    if isWildcard(left) or isWildcard(right)
        metacontext
    if isMetaVariable(left) and not isFree(left, metacontext)
        unify'(fail, metacontext, (metacontext.getValue(left), rightClosure))
    if isMetaVariable(right) and not isFree(right, metacontext)
        unify'(fail, metacontext, (leftClosure, metacontext.getValue(right)))
    if sameHead(left, right)
        zip(getComponentClosures(leftClosure),
            getComponentClosures(rightClosure)).
            cascade(unify'(fail), metacontext)
    if left is MetaVariable(_, address)
        metacontext.set(address, Just(rightClosure))
    if right is MetaVariable(_, address)
        metacontext.set(address, Just(leftClosure))
    fail(metacontext, (left, right))


def unify(context, metacontext, types @ (left, right))
    (environment, _) := context
    closures := (Closure(left, environment), Closure(right, environment))
    fail := unifyFailure(types)
    unify'(fail, metacontext, closures)

#*
