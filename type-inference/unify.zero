#* unify.zero

def unificationError(originals, left, right)
    abort("Type error: Can't unify\n" ++
        showTerm(left) ++ "\nwith\n" ++ showTerm(right) ++
        "\nwhile trying to unify\n" ++
        showTermAndLocation(first(originals)) ++
        "\nwith\n" ++
        showTermAndLocation(second(originals)))


def unifyFailure(originals, metacontext, (left, right))
    unificationError(originals.mapPair(resolve(metacontext)),
        left.resolve(metacontext), right.resolve(metacontext))


def isNegativeMetaVariable(term)
    if term is MetaVariable(_, index)
        isNegative(index)
    False


def isSamePrimitive(term)
    case MetaVariable(_, index)
        if term is MetaVariable(_, index')
            index =:= index'
        False
    case Type(_, index)
        if term is Type(_, index')
            index =:= index'
        False
    case Variable(_, _) -> False
    case Singleton(_, _, _) -> False
    case Function(_, _, _) -> False
    case Implication(_, _, _) -> False
    case Intersection(_, _, _) -> False
    case Application(_, _, _) -> False
    case Numeral(_, _, value)
        if term is Numeral(_, _, value')
            value = value'
        False
    case Operation(_, _, _) -> False # evaluate will never return an Operation


def tryEvaluate(metacontext, closure)
    closure' := evaluate(metacontext, [], closure)
    if isUnknown(getTerm(closure')) then closure else closure'


# Robinson's Unification Algorithm
# see Comparing Unification Algorithms in First-Order Theorem Proving
# by Krystof Hoder and Andrei Voronkov
# unify' enforces that left <: right
def unify'(fail, metacontext, (left, right))
    fail' := fail(metacontext, (left, right))
    left := left.tryEvaluate(metacontext)
    right := right.tryEvaluate(metacontext)
    _ @ Closure(leftTerm, leftEnv) := left
    _ @ Closure(rightTerm, rightEnv) := right

    if isSamePrimitive(leftTerm, rightTerm)
        metacontext

    if isNegativeMetaVariable(leftTerm) or isNegativeMetaVariable(rightTerm)
        fail'

    if rightTerm is MetaVariable(_, index)
        metacontext.setMetaValue(abs(index), left)

    def unifyBinder(tag, leftDomain, rightDomain, leftBody, rightBody)
        metacontext' := unify'(fail, metacontext,
            (Closure(rightDomain, rightEnv),
             Closure(leftDomain, leftEnv)))
        (m, metacontext'') := metacontext'.newNegativeMetaVariable(tag)
        unify'(fail, metacontext'',
            (Closure(leftBody, leftEnv.push(enclose(m))),
             Closure(rightBody, rightEnv.push(enclose(m)))))

    match leftTerm
        case MetaVariable(tag, index)
            metacontext.setMetaValue(abs(index), right)
        case Type(tag, index) -> fail'
        case Variable(tag, index) -> fail'  # should already be evaluated
        case Singleton(tag, type, index)
            if rightTerm is Singleton(tag', type', index')
                if abs(index) =/= abs(index')
                    fail'
                unify'(fail, metacontext,
                    (Closure(type, leftEnv), Closure(type', rightEnv)))
            fail'
        case Function(tag, domain, body) -> fail'
        case Implication(tag, domain, body)
            if rightTerm is Implication(tag', domain', body')
                unifyBinder(tag, domain, domain', body, body')
            fail'
        case Intersection(tag, domain, body)
            if rightTerm is Intersection(tag', domain', body')
                if isSingleton(domain) and isSingleton(domain')
                    # we can optimize here by ignoring the body since we ensure
                    # that if singleton domains match then the bodies match
                    unify'(fail, metacontext,
                        (Closure(domain, leftEnv), Closure(domain', rightEnv)))
                unifyBinder(tag, domain, domain', body, body')
            fail'
        case Application(tag, left', right')
            if rightTerm is Application(tag', left'', right'')
                metacontext' := unify'(fail, metacontext,
                    (Closure(left', leftEnv), Closure(left'', rightEnv)))
                unify'(fail, metacontext',
                    (Closure(right', leftEnv), Closure(right'', rightEnv)))
            fail'
        case Numeral(tag, type, value) -> fail'
        case Operation(tag, term, optimization) -> fail'


def unify(left, right, metacontext)
    originals := (left, right)
    metacontext' := unify'(unifyFailure(originals), metacontext, originals)
    _ @ Metacontext(positives, negatives) := metacontext'
    if getSize(positives) < 0  # todo: remove this and use either type
        abort("force unification errors")
    ((), metacontext')

#*
