#* unify.zero

def unificationError(originals, left, right)
    abort("Type error: Can't unify\n" ++
        showTerm(left) ++ "\nwith\n" ++ showTerm(right) ++
        "\nwhile trying to unify\n" ++
        showTermAndLocation(first(originals)) ++
        "\nwith\n" ++
        showTermAndLocation(second(originals)))


def unifyFailure(originals, metacontext, (left, right))
    unificationError(originals.mapPair(substitute(metacontext)),
        left.substitute(metacontext), right.substitute(metacontext))


def isNegativeMetaVariable(term)
    if term is MetaVariable(_, index)
        isNegative(index)
    False


def isSamePrimitive(term)
    case Unknown(_) -> False
    case MetaVariable(_, index)
        if term is MetaVariable(_, index')
            index =:= index'
        False
    case Type(_, index)
        if term is Type(_, index')
            index =:= index'
        False
    case Variable(_, index)
        if term is Variable(_, index')
            index =:= index'
        False
    case Function(_, _, _) -> False
    case Implication(_, _, _) -> False
    case Intersection(_, _, _) -> False
    case Application(_, _, _) -> False
    case Construction(_, _, _, _) -> False
    case Numeral(_, _, value)
        if term is Numeral(_, _, value')
            value = value'
        False
    case Operation(tag, _, _)
        if term is Operation(tag', _, _)
            getTagLexeme(tag) =*= getTagLexeme(tag')
        False


def substituteAndEvaluate(metacontext, term)
    if term is MetaVariable(_, index)
        if index is +_ n
            if metacontext.getMetaValue(n) is Just(value)
                substituteAndEvaluate(metacontext, value)
            term
        term
    if isApplication(term)
        term' := term.substitute(metacontext)
        value := resolve(evaluateClosure(enclose(term')))
        if isUnknown(value) then term' else value
    term


# Robinson's Unification Algorithm
# see Comparing Unification Algorithms in First-Order Theorem Proving
# by Krystof Hoder and Andrei Voronkov
# unify' enforces that left <: right
def unify'(fail, metacontext, (left, right))
    fail' := fail(metacontext, (left, right))
    left := substituteAndEvaluate(metacontext, left)
    right := substituteAndEvaluate(metacontext, right)

    if isUnknown(left) or isUnknown(right)
        fail'

    if isSamePrimitive(left, right)
        metacontext

    if isNegativeMetaVariable(left) or isNegativeMetaVariable(right)
        fail'

    if right is MetaVariable(_, index)
        metacontext.setMetaValue(abs(index), left)

    match left
        case Unknown(tag) -> fail'
        case MetaVariable(tag, index)
            metacontext.setMetaValue(abs(index), right)
        case Type(tag, index) -> fail'
        case Variable(tag, index) -> fail'
        case Function(tag, domain, body) -> fail'
        case Implication(tag, domain, body)
            if right is Implication(tag', domain', body')
                metacontext' := unify'(fail, metacontext, (domain', domain))
                unify'(fail, metacontext', (body, body'))
            fail'
        case Intersection(tag, domain, body)
            if right is Intersection(tag', domain', body')
                metacontext' := unify'(fail, metacontext, (domain', domain))
                unify'(fail, metacontext', (body, body'))
            fail'
        case Application(tag, left', right')
            if right is Application(tag', left'', right'')
                metacontext' := unify'(fail, metacontext, (left', left''))
                unify'(fail, metacontext', (right', right''))
            fail'
        case Construction(tag, domain, parameters, body)
            if right is Construction(tag', domain', parameters', body')
                if not isSamePrimitive(domain, domain')
                    fail'
                #unify'(fail, metacontext, (body, body'))
                zip(parameters, parameters').cascade(unify'(fail), metacontext)
            fail'
        case Numeral(tag, type, value) -> fail'
        case Operation(tag, term, optimization) -> fail'


def unify(left, right, metacontext)
    types := (left, right)
    metacontext' := unify'(unifyFailure(types), metacontext, types)
    _ @ Metacontext(positives, negatives) := metacontext'
    if getSize(positives) < 0  # todo: remove this and use either type
        abort("force unification errors")
    ((), metacontext')

#*
