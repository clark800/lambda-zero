#* unify.zero

def unificationError(originals, left, right)
    abort("Type error: Can't unify\n" ++
        showTerm(left) ++ "\nwith\n" ++ showTerm(right) ++
        "\nwhile trying to unify\n" ++
        showTermAndLocation(first(originals)) ++
        "\nwith\n" ++
        showTermAndLocation(second(originals)))


def unifyFailure(originals, metacontext, (left, right))
    unificationError(originals.mapPair(substitute(metacontext)),
        left.substitute(metacontext), right.substitute(metacontext))


def isFree(metavariable, metacontext)
    if metavariable is MetaVariable(_, address)
        isVoid(metacontext.get(address) ?? Void)
    False


def getValue(type, metacontext)
    if type is MetaVariable(_, address)
        if metacontext.get(address) ?? Void is Just(term)
            term
        pass
    throwError("internal error", getTermTag(type))


def substituteAndEvaluate(metacontext, term)
    resolve(evaluateClosure(enclose(substitute(metacontext, term))))


def insertMetaVariable(term, metacontext)
    tag := getTermTag(term)
    (metavariable, metacontext') := newMetaVariable(tag, metacontext)
    closure' := Closure(term, newArray([enclose(metavariable)]))
    (resolve(closure'), metacontext')


# Robinson's Unification Algorithm
# see Comparing Unification Algorithms in First-Order Theorem Proving
# by Krystof Hoder and Andrei Voronkov
# unify' enforces that left <: right
def unify'(fail, metacontext, (left, right))
    fail' := fail(metacontext, (left, right))
    left := substituteAndEvaluate(metacontext, left)
    right := substituteAndEvaluate(metacontext, right)

    if right is Unknown(_)
        fail'
    if right is MetaVariable(_, address)
        if isFree(right, metacontext)
            if isSameHead(left, right)
                metacontext
            metacontext.set(address, Just(left))
        unify'(fail, metacontext, (left, metacontext.getValue(right)))

    match left
        case MetaVariable(_, address)
            if isFree(left, metacontext)
                if isSameHead(left, right)
                    metacontext
                metacontext.set(address, Just(right))
            unify'(fail, metacontext, (metacontext.getValue(left), right))
        case Universe(_, _)
            if isSameHead(left, right) then metacontext else fail'
        case Implication(_, domain, body)
            if right is Implication(_, domain', body')
                metacontext' := unify'(fail, metacontext, (domain', domain))
                # todo: handle dependent types
                unify'(fail, metacontext', (body, body'))
            fail'
        case Intersection(_, domain, body)
            if right is Intersection(tag, domain', body')
                metacontext' := unify'(fail, metacontext, (domain', domain))
                # todo: handle dependent types
                unify'(fail, metacontext', (body, body'))
            (left', metacontext') := insertMetaVariable(body, metacontext)
            unify'(fail, metacontext', (left', right))
        case Construction(_, parameters, _, _)
            if not isSameHead(left, right)
                fail'
            if right is Construction(_, parameters', _, _)
                zip(parameters, parameters').cascade(unify'(fail), metacontext)
            fail'
        case _
            fail'


def unify(left, right, metacontext)
    types := (left, right)
    metacontext' := unify'(unifyFailure(types), metacontext, types)
    if getSize(metacontext') < 0  # todo: remove this and use either type
        abort("force unification errors")
    ((), metacontext')

#*
